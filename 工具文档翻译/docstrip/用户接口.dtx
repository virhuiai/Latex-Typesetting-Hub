% \section{The user interface\\用户接口}
%
% \subsection{The main program\\主程序}
% \DescribeMacro{\processbatchFile} The `main program' starts with
%    trying to process a batch file, this is accomplished by calling
%    the macro |\processbatchFile|. It counts the number of batch
%    files it processes, so that when the number of files processed is
%    still zero after the call to |\processbatchFile| appropriate
%    action can be taken.\\“主程序”从尝试处理批处理文件开始，这是通过调用宏|\processbatchFile|来完成的。它计算处理的批处理文件数量，因此当调用|\processbatchFile|后处理的文件数量仍为零时，可以采取适当的措施。
%
% \DescribeMacro{\interactive} When no batch files have been processed
%    the macro |\interactive| is called. It prompts the user for
%    information. First the extensions of the input and output files
%    is determined. Then a question about optional code is asked and
%    finally the user can give a list of files that have to be
%    processed.\\当没有批处理文件被处理时，调用宏 |\interactive|。它提示用户输入信息。首先确定输入和输出文件的扩展名。然后询问有关可选代码的问题，最后用户可以给出需要处理的文件列表。
%
% \DescribeMacro{\ReportTotals} When the \texttt{stats} option is
%    included in the \ds{}-program it keeps a record of the number of
%    files and lines that are processed.  Also the number of comments
%    removed and passed as well as the number of code lines that were
%    passed to the output are accounted. The macro |\ReportTotals|
%    shows a summary of this information.\\当\ds{}程序中包含\texttt{stats}选项时，它会记录处理的文件数量和行数。还会记录移除的注释数量和传递的注释数量，以及传递到输出的代码行数。|\ReportTotals|宏显示了这些信息的摘要。
%
% \subsection{Batchfile commands\\批处理命令}
%
%    The commands described in this section are available to build a
%    batch file for \TeX.\\本节介绍的命令可用于构建 \TeX 的批处理文件。

%
% \DescribeMacro{\input}
% All \ds{} batch files should start with the line:\\所有的\ds{}批处理文件都应该以以下行开头：\\|\input docstrip|
%
% Do not use the  \LaTeX\ syntax |\input{docstrip}| as batch files may
% be used with plain~\TeX\ or ini\TeX.
% You may find that old batch files always have a line
% |\def\batchfile{|\meta{filename}|}|
% just before the input.
% Such usage is still supported but is now discouraged, as it causes
% \TeX\ to re-input the same file, using up one of its limited number
% of input streams.\\不要使用 \LaTeX\ 语法 |\input{docstrip}|，因为批处理文件可能与 plain~\TeX\ 或 ini\TeX 一起使用。 你可能会发现旧的批处理文件总是在输入之前有一行 |\def\batchfile{|\meta{filename}|}|。 虽然仍支持此用法，但现在已不鼓励使用，因为它会导致 \TeX\ 重新输入相同的文件，使用其中一条有限数量的输入流。
%
% \DescribeMacro{\endbatchfile}
% All batch files should end with this command. Any lines after this
% in the file are ignored. In old files that start
% |\def\batchfile{|\ldots\ this command is optional, but is a good
% idea anyway. If this command is omitted from a batchfile then
% normally \TeX\ will go to its interactive |*| prompt, so you may
% stop \ds{} by typing |\endbatchfile| to this prompt.\\所有批处理文件都应该以此命令结束。文件中此命令之后的任何行都将被忽略。在旧文件中，如果以 |\def\batchfile{|\ldots\ 开始，此命令是可选的，但无论如何都是一个好主意。如果批处理文件中省略了此命令，那么通常 \TeX\ 将进入交互式 |*| 提示符状态，因此您可以通过向该提示符键入 |\endbatchfile| 停止 \ds{}。
%
% \DescribeMacro{\generate}
% \DescribeMacro{\file}
% \DescribeMacro{\from}
%    The main reason for constructing a \ds{} command file is to
%    describe what files should be generated, from what sources and
%    what optional (`guarded') pieces of code should be included. The
%    macro |\generate| is used to give \TeX\ this information. Its
%    syntax is:\\构建 \ds{} 命令文件的主要原因是描述应该从哪些源文件生成哪些文件，以及应该包含哪些可选的（“受保护的”）代码片段。宏 |\generate| 用于向 \TeX\ 提供这些信息。它的语法是：\\
%    \begin{quote}
%    |\generate{|[|\file{|\meta{output}|}{|[|\from{|^^A
%                    \meta{input}|}{|\meta{optionlist}|}|]*|}|]*|}|
%    \end{quote}
%    The \meta{output} and \meta{input} are normal file specifications
%    as are appropriate for your computer system. The
%    \meta{optionlist} is a comma separated list of `options' that
%    specify which optional code fragments in \meta{input} should be
%    included in \meta{output}. Argument to |\generate| may contain
%    some local declarations (e.g., the |\use...| commands described
%    below) that will apply to all |\file|s after them. Argument to
%    |\generate| is executed inside a group, so all local declarations
%    are undone when |\generate| concludes.\\\meta{输出}和\meta{输入}是适合于计算机系统的普通文件规范。 \meta{optionlist}是一个用逗号分隔的“选项”列表，用于指定应在\meta{输出}中包含\meta{输入}中的哪些可选代码片段。|\generate|的参数可能包含一些本地声明（例如，下面描述的|\use...|命令），这些声明将应用于它们之后的所有|\file|。|\generate|的参数在一个组内执行，因此当|\generate|结束时，所有本地声明都将被撤消。


%
%    It is possible to specify multiple input files, each with its own
%    \meta{optionlist}. This is indicated by the notation [\ldots]*.
%    Moreover there can be many |\file| specifications in one
%    |\generate| clause. This means that all these \meta{output} files
%    should be generated while reading each of \meta{input} files
%    once. Input files are read in order of first appearance in this
%    clause. E.g.\\可以指定多个输入文件，每个文件都有自己的\meta{optionlist}。这可以通过符号[\ldots]*来表示。此外，一个|\generate|子句中可以有多个|\file|规定。这意味着在读取每个\meta{input}文件一次时，应该生成所有这些\meta{output}文件。输入文件按照它们在这个子句中第一次出现的顺序进行读取。例如：
%\begin{verbatim}
%    \generate{\file{p1.sty}{\from{s1.dtx}{foo,bar}}
%              \file{p2.sty}{\from{s2.dtx}{baz}
%                            \from{s3.dtx}{baz}}
%              \file{p3.sty}{\from{s1.dtx}{zip}
%                            \from{s2.dtx}{zip}}
%             }
%\end{verbatim}
%    will cause \ds{} to read files \texttt{s1.dtx}, \texttt{s2.dtx},
%    \texttt{s3.dtx} (in that order) and produce files
%    \texttt{p1.sty}, \texttt{p2.sty}, \texttt{p3.sty}.\\这将导致 \ds{} 读取文件 \texttt{s1.dtx}、\texttt{s2.dtx}、\texttt{s3.dtx}（按照这个顺序），并生成文件 \texttt{p1.sty}、\texttt{p2.sty}、\texttt{p3.sty}。

%
%    The restriction to at most 16 output streams open in a while
%     does not mean that you can produce at most 16 files with one
%    |\generate|. In the example above only 2 streams are needed,
%    since while \texttt{s1.dtx} is processed only \texttt{p1.sty} and
%    \texttt{p3.sty} are being generated; while reading
%    \texttt{s2.dtx} only \texttt{p2.sty} and \texttt{p3.sty}; and
%    while reading \texttt{s3.dtx} file \texttt{p2.sty} . However
%    example below needs 3 streams:\\在同时打开的输出流最多只能有16个的限制，并不意味着你只能用一次|\generate|生成最多16个文件。在上面的例子中，只需要2个流，因为处理\texttt{s1.dtx}时只生成了\texttt{p1.sty}和\texttt{p3.sty}，读取\texttt{s2.dtx}时只生成\texttt{p2.sty}和\texttt{p3.sty}，读取\texttt{s3.dtx}文件时只生成\texttt{p2.sty}。然而下面的例子需要3个流：

%\begin{verbatim}
%    \generate{\file{p1.sty}{\from{s1.dtx}{foo,bar}}
%              \file{p2.sty}{\from{s2.dtx}{baz}
%                            \from{s3.dtx}{baz}}
%              \file{p3.sty}{\from{s1.dtx}{zip}
%                            \from{s3.dtx}{zip}}
%             }
%\end{verbatim}
%    Although while reading \texttt{s2.dtx} file \texttt{p3.sty} is
%    not written it must remain open since some parts of
%    \texttt{s3.dtx} will go to it later.\\虽然在阅读 \texttt{s2.dtx} 文件时没有写入 \texttt{p3.sty}，但它必须保持打开状态，因为稍后会将 \texttt{s3.dtx} 的某些部分写入其中。
%
%    Sometimes it is not possible to create a file by reading  all
%    sources once. Consider the following example:\\有时候，通过一次性读取所有源文件来创建一个文件是不可能的。考虑如下例子：
%\begin{verbatim}
%    \generate{\file{p1.sty}{\from{s1.dtx}{head}
%                            \from{s2.dtx}{foo}
%                            \from{s1.dtx}{tail}}
%              \file{s1.drv}{\from{s1.dtx}{driver}}
%             }
%\end{verbatim}
%    To generate \texttt{p1.sty} file \texttt{s1.dtx} must be read
%    twice: first time with option \texttt{head}, then file
%    \texttt{s2.dtx} is read and then \texttt{s1.dtx} again this time
%    with option \texttt{tail}.  \ds{} handles this case correctly: if
%    inside one |\file| declaration there are multiple |\from|es with
%    the same input file this file \emph{is} read multiple times.\\为了生成 \texttt{p1.sty} 文件，必须读取 \texttt{s1.dtx} 两次：第一次使用选项 \texttt{head}，然后读取文件 \texttt{s2.dtx}，然后再次使用选项 \texttt{tail} 读取 \texttt{s1.dtx}。 \ds{} 正确处理这种情况：如果在一个 |\file| 声明中有多个相同输入文件的 |\from|，那么该文件将被读取多次。

%
%    If the order of |\from|s specified in one of your |\file|
%    specifications does not match the order of input files
%    established by previous |\file|s, \ds{} will raise an error and
%    abort. Then you may either read one of next sections or give up
%    and put that file in separate |\generate| (but then sources will
%    be read again just for that file).\\如果您在一个|\file|规范中指定的|\from|的顺序与之前的|\file|规范确定的输入文件的顺序不匹配，\ds{}将引发错误并中止操作。然后，您可以阅读下一节中的内容，或者放弃，将该文件放入单独的|\generate|中（但是这样源文件将再次读取，仅为该文件）。

%
%    \paragraph{For impatient.} Try following algorithm: Find
%    file that is generated from largest number of sources, start
%    writing |\generate| clause with this file and its sources in
%    proper order. Take other files that are to be generated and add
%    them checking if they don't contradict order of sources for the
%    first one. If this doesn't work read next sections.\\{\bf 对于不耐烦的人。} 尝试以下算法：找到生成源文件最多的文件，按照正确的顺序在其与源文件中写入|\generate|条款。接下来将要生成的其他文件添加进去，并检查它们是否与第一个文件的源文件顺序相矛盾。如果这样做不起作用，请阅读下一节。
%
%    \paragraph{For mathematicians.} Relation ``file $A$ must  be
%    read before file $B$'' is a partial order on the set of all your
%    source files.  Each |\from| clause adds a chain to this order.
%    What you have to do is to perform a topological sort i.e. to
%    extend partial order to linear one.  When you have done it just
%    list your source files in |\generate| in such a way that order of
%    their first appearance in the clause matches linear order. If
%    this cannot be achieved read next paragraph. (Maybe future
%    versions of \ds{} will perform this sort automatically, so all
%    these troubles will disappear.)\\{\bf 对于数学家。}关系“文件$A$必须在文件$B$之前读取”是您所有源文件集合上的偏序关系。每个$|\from|$子句都会添加一个链到此顺序中。您需要做的是执行拓扑排序，即将偏序扩展为线性序。当您完成后，只需按照其在子句中首次出现的顺序，在$|\generate|$中列出您的源文件。如果无法实现此操作，请阅读下一段。（也许未来的\ds{}版本将自动执行此排序，因此所有这些麻烦都将消失。）
%
%    \paragraph{For that who must know that all.} There  is  a
%    diverse case when it's not possible to achieve proper order of
%    reading source files. Suppose you have to generate two files,
%    first from \texttt{s1.dtx} and \texttt{s3.dtx} (in that order)
%    and second from \texttt{s2.dtx} and \texttt{s3.dtx}.  Whatever
%    way you specify this the files will be read in either as
%    \texttt{s1 s3 s2} or \texttt{s2 s3 s1}. The key to solution is
%    magical macro |\needed| that marks a file as needed to be input
%    but not directing any output from it to current |\file|. In our
%    example proper specification is:\\{\bf 对于那些必须知道这一切的人。}当无法达到正确的源文件读取顺序时，存在多种情况。假设您必须生成两个文件，第一个文件来自 \texttt{s1.dtx} 和 \texttt{s3.dtx}（按照这个顺序），第二个文件来自 \texttt{s2.dtx} 和 \texttt{s3.dtx}。无论您以什么方式指定，文件将被读入为 \texttt{s1 s3 s2} 或 \texttt{s2 s3 s1}。解决的关键是神奇的宏 |\needed|，它将一个文件标记为需要输入，但不将任何输出从它传递给当前的 |\file|。在我们的示例中，正确的规范是：
%\begin{verbatim}
%    \generate{\file{p1.sty}{\from{s1.dtx}{foo}
%                            \needed{s2.dtx}
%                            \from{s3.dtx}{bar}}
%              \file{p2.sty}{\from{s2.dtx}{zip}
%                            \from{s3.dtx}{zap}}
%             }
%\end{verbatim}
%
%
%  \DescribeMacro{\askforoverwritetrue}
%  \DescribeMacro{\askforoverwritefalse}
%    These macros specify what should happen if a file that is to be
%    generated already exists. If |\askforoverwritetrue| is active
%    (the default) the user is asked whether the file should be
%    overwritten. If however |\askforoverwritefalse| was issued
%    existing files will be overwritten silently.  These switches are
%    local and can be issued in any place in the file even inside
%    |\generate| clause (between |\file|s however).\\这些宏会指定在生成文件时，如果文件已经存在应该发生什么。如果 |\askforoverwritetrue| 是激活状态（默认情况下），则会询问用户是否应该覆盖该文件。但是，如果发出了 |\askforoverwritefalse|，则现有文件将被静默地覆盖。这些开关是局部的，可以在文件中的任何位置发出，甚至在 |\generate| 子句内部（但是必须在 |\file| 之间）。


%
%  \DescribeMacro{\askonceonly}
%  You might not want to set |\askforoverwritefalse| in a batch file
%  as that says that it us always all right to overwrite other people's
%  files. However for large installations, such as the base \LaTeX\
%  distribution,  being asked individually about hundreds of files
%  is not very helpful either. A batchfile may therefore specify
%  |\askonceonly|. This means that after the first time the batchfile
%  asks the user a question, the user is given an option of to change
%  the behaviour so that `yes' will be automatically assumed for all
%  future questions. This applies to any use of the \ds{} command
%  |\Ask| including, but not restricted to, the file overwrite
%  questions controlled by |\askforoverwritetrue|.\\在批处理文件中，您可能不想设置|\askforoverwritefalse|，因为这意味着总是可以覆盖其他人的文件。然而，对于大型安装，例如基础的\LaTeX\ 发行版，单独询问数百个文件并不是非常有帮助的。因此，批处理文件可以指定|\askonceonly|。这意味着在批处理文件第一次询问用户问题后，用户会有一个选项来更改行为，以便将“是”自动假定为所有未来的问题的答案。这适用于任何使用\ds{}命令|\Ask|的情况，包括但不限于由|\askforoverwritetrue|控制的文件覆盖问题。
%
% \DescribeMacro{\preamble}
% \DescribeMacro{\endpreamble}
% \DescribeMacro{\postamble}
% \DescribeMacro{\endpostamble}
%    It is possible to add a number of lines to the output of the
%    \ds{} program. The information you want to add to the start of
%    the output file should be listed between the |\preamble| and
%    |\endpreamble| commands; the lines you want to add to the end of
%    the output file should be listed between the |\postamble| and
%    |\endpostamble| commands. Everything that \ds{} finds for both
%    the pre- and postamble it writes to the output file, but preceded
%    with value of |\MetaPrefix| (default is two \%-characters). If
%    you include a |^^J| character in one of these lines, everything
%    that follows it on the same line is written to a new line in the
%    output file.  This `feature' can be used to add a |\typeout| or
%    |\message| to the stripped file.\\可以向\ds{}程序的输出添加多行内容。想要添加到输出文件开头的信息应该列在|\preamble|和|\endpreamble|命令之间；想要添加到输出文件末尾的行应该列在|\postamble|和|\endpostamble|命令之间。\ds{}找到的所有前导和后导内容都写入输出文件，但前面带有|\MetaPrefix|的值（默认为两个%字符）。如果在这些行中包含一个|^^J|字符，那么在同一行后面的所有内容都将写入输出文件的新行中。这个“特性”可以用来向剥离后的文件添加|\typeout|或|\message|。


%
% \DescribeMacro{\declarepreamble}
% \DescribeMacro{\declarepostamble}
% \DescribeMacro{\usepreamble}
% \DescribeMacro{\usepostamble}
% \DescribeMacro{\nopreamble}
% \DescribeMacro{\nopostamble}
%    Sometimes it is desirable to have different preambles for different
%    files  of  a  larger  package  (e.g.,  because  some  of them are
%    customisable  configuration  files and they should be marked as
%    such). In such a case one can say |\declarepreamble\somename|,
%    then type in his/her preamble, end it with |\endpreamble|,
%    and  later  on  |\usepreamble\somename|  to  switch   to   this
%    preamble.
%    If no preamble  should be used you can deploy the |\nopreamble|
%    command. This command is equivalent to saying  |\usepreamble\empty|.
%    The  same  mechanism works for postambles, |\use...|
%    declarations are local and can appear inside |\generate|.\\有时候，在一个大型的软件包中，希望每个文件都有不同的导言部分（例如，一些文件是可定制的配置文件，需要加以标记）。这种情况下，可以使用 |\declarepreamble\somename| 命令来指定一个名称，然后输入导言部分并以 |\endpreamble| 结束。之后，可以使用命令 |\usepreamble\somename| 来切换到这个导言部分。\\如果不需要导言部分，可以使用命令 |\nopreamble|。这个命令相当于执行 |\usepreamble\empty|。\\同样的机制也适用于后导言部分，|\use...| 声明是局部的，可以出现在 |\generate| 命令内部。

%
%    Commands   |\preamble|   and   |\postamble| define and  activate
%    pre(post)ambles named |\defaultpreamble| and |\defaultpostamble|.\\命令|\preamble|和|\postamble|定义并激活名为|\defaultpreamble|和|\defaultpostamble|的前（后）导。
%
% \DescribeMacro{\batchinput}
%    The batch file commands can be put into several batch files which
%    are then executed from a master batch file. This is, for example,
%    useful if a distribution consists of several distinct parts. You
%    can then write individual batch files for every part and in
%    addition a master file that simply calls the batch files for the
%    parts.  For this, call the individual batch files from the master
%    file with the command |\batchinput{|\meta{file}|}|. Don't use
%    |\input| for this purpose, this command
%    should be used only for calling the \ds{} program as explained
%    above and is ignored when used for any other purpose.\\批处理文件命令可以放在几个批处理文件中，然后从主批处理文件中执行它们。例如，如果一个分发包含几个不同的部分，可以为每个部分编写单独的批处理文件，并额外编写一个主文件，它只是调用这些部分的批处理文件。为此，使用命令|\batchinput{|\meta{file}|}|从主文件中调用单独的批处理文件。不要为此目的使用|\input|命令，该命令仅用于调用上面解释的\ds{}程序，并且在用于其他目的时被忽略。
%
% \DescribeMacro{\ifToplevel}
%    When batch files are nested you may want to suppress certain
%    commands in the lower-level batch files such as terminal
%    messages. For this purpose you can use the |\ifToplevel| command
%    which executes its argument only if the current batch file is the
%    outermost one. Make sure that you put the opening brace of the
%    argument into the same line as the command itself, otherwise the
%    \ds{} program will get confused.\\当批处理文件嵌套时，您可能想要禁止在较低级别的批处理文件中执行某些命令，例如终端消息。为此，您可以使用|\ifToplevel|命令，仅在当前批处理文件是最外层文件时执行其参数。确保将参数的左括号放在与命令本身相同的行中，否则\ds{}程序将会混淆。
%
% \DescribeMacro{\showprogress}
% \DescribeMacro{\keepsilent}
%    When the option \texttt{stats} is included in \ds{} it can
%    write message to the terminal as each line of the input file(s) is
%    processed. This message consists of a single character, indicating
%    kind of that particular line. We use the
%    following characters:\\当在 \ds{} 中包含选项 \texttt{stats} 时，它会在处理每个输入文件的每一行时向终端输出消息。该消息由一个字符组成，表示该特定行的类型。我们使用以下字符：
%    \begin{itemize}
% \item[\texttt{\%}] Whenever an input line is a comment
%        \texttt{\%}-character is written to the terminal.\\每当输入行是注释时，\texttt{\%} 字符会被写入终端。
% \item[\texttt{.}] Whenever a code line is encountered
%        a \texttt{.}-character is written on the terminal.\\每当代码行被遇到时，\texttt{.} 字符会被写入终端。
% \item[\texttt{/}] When a number of empty lines appear in a row in the
%        input file, at most one of them is retained. The \ds{}
%        program signals the removal of an empty line with the
%        \texttt{/}-character.\\当输入文件中出现一系列空行时，最多只保留其中的一行。\ds{} 程序会用 \texttt{/} 字符来表示空行已被移除。 
% \item[\texttt{<}] When a `guard line' is found in the input and it
%        starts a block of optionally included code, this is signalled
%        on the terminal by showing the \texttt{<}-character, together
%        with the boolean expression of the guard.\\当在输入中找到一个“守卫行”并且它开始了一个可选包含代码块时，这将通过显示 \texttt{<} 字符和守卫的布尔表达式来在终端上发出信号。 
% \item[\texttt{>}] The end of a conditionally included block of code is
%        indicated by showing the \texttt{>}-character.\\条件包含的代码块的结束通过显示 \texttt{>} 字符来表示。
%    \end{itemize}


%    This feature is turned on by default when the option
%    \texttt{stats} is included, otherwise it is turned off. The
%    feature can be toggled with the commands |\showprogress| and
%    |\keepsilent|.\\当选项\texttt{stats}被包含时，默认情况下会启用此功能，否则会禁用。该功能可以通过命令|\showprogress|和|\keepsilent|切换。

%
%
%  \subsubsection{Supporting old interface\\支持旧接口}
%
% \DescribeMacro{\generateFile}
%    Here is the old syntax for specifying  what  files  are  to  be
%    generated. It allows specification of just one output file.\\这里是指定要生成哪些文件的旧语法。它只允许指定一个输出文件。
%    \begin{quote}
%    |\generateFile{|\meta{output}|}{|\meta{ask}|}{|[|\from{|^^A
%                    \meta{input}|}{|\meta{optionlist}|}|]*|}|
%    \end{quote}
%    The meaning of \meta{output}, \meta{input} and
%    \meta{optionslist} is just as for |\generate|.  With
%    \meta{ask} you can instruct \TeX\ to either silently overwrite a
%    previously existing file (|f|) or to issue a warning and ask you
%    if it should overwrite the existing file (|t|) (it overrides the
%    |\askforoverwrite| setting).\\\meta{output}、\meta{input}和\meta{optionslist}的含义与|\generate|命令相同。使用\meta{ask}参数，您可以指示\TeX\ 要么静默地覆盖一个已经存在的文件（|f|），要么发出警告并询问您是否应该覆盖现有的文件（|t|）（它会覆盖|\askforoverwrite|设置）。


%
% \DescribeMacro{\include}
% \DescribeMacro{\processFile}
%    The earlier version of the \ds{} program supported a
%    different kind of command to tell \TeX\ what to do. This command
%    is less powerful than |\generateFile|; it can be used when
%    \meta{output} is created from one \meta{input}. The syntax is:\\早期版本的\ds{}程序支持一种不同类型的命令来告诉\TeX{}该做什么。这个命令比|\generateFile|更弱，它可以用于从一个\meta{input}创建\meta{output}。语法如下：
%    \begin{quote}
%    |\include{|\meta{optionlist}|}|
%
%    |\processFile{|\meta{name}|}{|\meta{inext}^^A
%                              |}{|\meta{outext}^^A
%                              |}{|\meta{ask}|}|
%    \end{quote}
%    This command is based on environments where filenames are
%    constructed of two parts, the name and the extension, separated
%    with a dot. The syntax of this command assumes that the
%    \meta{input} and \meta{output} share the same name and only
%    differ in their extension. This command is retained to be
%    backwards compatible with the older version of \ds{}, but its use
%    is not encouraged.\\该命令基于文件名由两个部分构成的环境，即名称和扩展名，用点号分隔。该命令的语法假定\meta{input}和\meta{output}具有相同的名称，只在扩展名上有所不同。该命令被保留以与\ds{}的旧版本向后兼容，但不建议使用。
