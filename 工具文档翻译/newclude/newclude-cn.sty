%^^A* legal notices
% \iffalse
%
%   This program is part of the Frankenstein bundle for LaTeX.  
%
%   Copyright 1995-2001 Matt Swift <swift@alum.mit.edu>.
%
%   This file contains both the code and documentation for the
%   newclude LaTeX package.  It will work ONLY if it is placed in a
%   proper directory.  Files called README, INSTALL, newclude.tex
%   and newclude.ins should have also been distributed to you
%   with this file.  See them for more information on how to typeset
%   the documentation with LaTeX and how to generate a version of this
%   file that will work faster than this one.
%
%   This program is free software; you may redistribute it and/or
%   modify it under the conditions of the LaTeX Project Public
%   License, either version 1.2 or (at your option) any later version.
%   The latest version of this license is in
%   http://www.latex-project.org/lppl.txt, and version 1.2 or later is
%   part of all distributions of LaTeX version 1999/12/01 or later.
%
%   This program is distributed in the hope that it will be useful,
%   but without any warranty; without even the implied warranty of
%   merchantability or fitness for a particular purpose.  See the
%   LaTeX Project Public License for more details.
%
% \fi  
%
%^^A* checks
%
%^^A NOTE:  The character table, with two %'s, will get written to all files.
%% \CharacterTable
%%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%%   Digits        \0\1\2\3\4\5\6\7\8\9
%%   Exclamation   \!     Double quote  \"     Hash (number) \#
%%   Dollar        \$     Percent       \%     Ampersand     \&
%%   Acute accent  \'     Left paren    \(     Right paren   \)
%%   Asterisk      \*     Plus          \+     Comma         \,
%%   Minus         \-     Point         \.     Solidus       \/
%%   Colon         \:     Semicolon     \;     Less than     \<
%%   Equals        \=     Greater than  \>     Question mark \?
%%   Commercial at \@     Left bracket  \[     Backslash     \\
%%   Right bracket \]     Circumflex    \^     Underscore    \_
%%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%%   Right brace   \}     Tilde         \~}
%
% \CheckSum{208}
% 
% \begin{abstract}
%   \noindent\package{Newclude} is a backwards-compatible reimplementation of the
%   \LaTeX{} system for including files.  The princpal new features are: (1)
%   the restriction that \cs\clearpage{}s must surround an included file is
%   removed, (2) the restriction that \cs\include{}s cannot be nested is
%   removed, and (3) the provision of hooks executed before and after the
%   contents of an included file.  Newclude accomplishes the first two by using
%   a single \ext{aux} file instead of many.\\\package{Newclude}是一个向后兼容的重新实现\LaTeX{}文件包含系统的工具。它的主要新特性包括：（1）不需要在被包含的文件前后使用\cs\clearpage{}命令，（2）可以嵌套使用\cs\include{}命令，（3）提供在文件包含前后执行的钩子。通过使用单个\ext{aux}文件，Newclude实现了前两个特性。
%
%   \noindent Still in development, but already useful in many situations, are new
%   commands that include partial contents of independent \LaTeX{} files, which
%   can also be processed on their own (that is, files that contain
%   \cs\documentclass, |\begin{document}|, etc.).  \package{Newclude} absorbs
%   and supersedes the former package \package{includex}.\\仍在开发中，但已经在许多情况下非常有用的是新命令，它们包括独立的\LaTeX{}文件的部分内容，这些文件也可以单独处理（即，包含\cs\documentclass，|\begin{document}|等的文件）。 \package{Newclude}吸收并取代了以前的\package{includex}包。

% \end{abstract}
% \clearpage
% \tableofcontents
%
% \part{Discussion\\讨论}
%
%   \section{Introduction\\介绍}
%
% Let us call a file that might be included into another document with a
% command in the \cs\include family a \term{part}.  When a part is actually
% included during a particular processing run, let us call it an \term{included
% part}, and when it is not included, let us call it an \term{unincluded part}.
% Notice that an unincluded part is \emph{not} the same as a file that was
% never a candidate for inclusion with a command in the \cs\include family.\\我们称可能通过在\cs\include 家族中使用的命令包含到另一个文档中的文件为\term{部分}。当一个部分在特定的处理运行中实际被包含时，我们称其为\term{已包含部分}，而当它未被包含时，我们称其为\term{未包含部分}。请注意，未包含的部分\emph{并不}等同于从未成为\cs\include 家族中的命令包含候选文件的文件。

%
% The \package{newclude} package adds these features to the standard LaTeX{}
% inclusion system:\\\package{newclude} 宏包为标准的 LaTeX{} 包含系统添加了以下功能：
% \begin{enumerate}
%   \item\label{item:hooks} Hooks \cs\AtBeginInclude and \cs\AtEndInclude are provided.\\提供了钩子命令 \cs\AtBeginInclude 和 \cs\AtEndInclude。 
%   \item\label{item:hooks:opt} Optional arguments to \cs\include and friends
%         override current values of \cs\AtBeginInclude and \cs\AtEndInclude.\\\cs\include 和其它相关命令的可选参数可以覆盖当前 \cs\AtBeginInclude 和 \cs\AtEndInclude 的值。 
%   \item \cname{include*} is like \cs\include but with arbitrary commands
%         rather than \cs\clearpage{}s surrounding the part.\\类似于 \cs\include，但是其包含的部分不是由 \cs\clearpage{} 命令围绕而成的，而是由任意命令组成的。
%   \item \cs\include and friends can be nested.\\\cs\include 和其它相关命令可以嵌套使用。
%   \item \cs\includeall cancels the effect of \cs\includeonly.\\\cs\includeall 命令可以取消 \cs\includeonly 命令的作用。 
%   \item \cs\IfAllowed\meta{filename} is a new conditional that branches,
%         depending on what has been declared in an \cs\includeonly.\\\cs\IfAllowed\meta{filename} 是一个新的条件语句，其执行分支取决于在 \cs\includeonly 命令中声明的内容。
%   \item Commands \cs\includedoc etc.\ include a part that can be processed
%         independently.  These features are in development.\\ 命令 \cs\includedoc 等可以包含可以独立处理的部分。这些功能正在开发中。
% \end{enumerate}
    


%
% \package{Newclude} accepts three mutually-exclusive package options, with
% \option{tag} the default when no package option is given.\\\package{Newclude} 接受三个互斥的包选项，当没有给出包选项时，\option{tag} 是默认选项。

%
% Loading \package{newclude} with the \option{simple} option provides only
% features \ref{item:hooks} and~\ref{item:hooks:opt}.  If you don't use either
% of these new features, the standard \LaTeX{} and \package{newclude} inclusion
% systems will behave identically except in some unusual and benign odd cases
% relating the the parsing of the new optional arguments to \cs\include, which
% are discussed below in that command's documentation.\\使用\option{simple}选项加载\package{newclude}只提供功能\ref{item:hooks}和\ref{item:hooks:opt}。如果您不使用这些新功能中的任何一个，标准的\LaTeX{}和\package{newclude}包含系统将表现相同，除了某些与\cs\include 的新可选参数解析相关的不寻常和良性的奇怪情况，这些情况在该命令的文档中进行了讨论。

% 
% The options \option{tag} and \option{allocate} each implement all the above
% features with a different method.  Each method introduces different
% discrepancies from standard \LaTeX{} which are discussed below in sections
% \ref{opt:tag} and~\ref{opt:allocate}.  If I discover how to make one method
% never inferior to the other, I will remove the other option from the package.\\选项\option{tag}和\option{allocate}各自使用不同的方法实现了上述所有功能。每种方法都引入了与标准\LaTeX{}不同的差异，下面在第\ref{opt:tag}节和第\ref{opt:allocate}节中进行了讨论。如果我发现如何使一种方法永远不劣于另一种方法，我将从包中删除另一个选项。

%
%   \section{Usage\\使用方法}
%
% \DescribeMacro\include
% \DescribeMacro\AtBeginInclude
% \DescribeMacro\AtEndInclude
%   \cs\include\oarg{prehook}\marg{filename}\oarg{posthook} behaves like
%   standard \LaTeX{}'s \cs\include except that it can be nested and the
%   contents of the two hook arguments, when they are given, are inserted at
%   the beginning and end of the part whenever it is included, overriding the
%   current values of \cs\AtBeginInclude and \cs\AtEndInclude.\\\cs\include\oarg{prehook}\marg{filename}\oarg{posthook} 的用法类似于标准的 \LaTeX{} 命令 \cs\include，但它支持嵌套，并且当给出两个钩子参数时，它们的内容会在每次包含时插入到部分的开头和结尾，覆盖当前的 \cs\AtBeginInclude 和 \cs\AtEndInclude 的值。
%
%   \caveat{Right square braces (|]|s) in the optional arguments must be
%   surrounded by curly braces to avoid confusing the argument parser.}

%\caveat{可选参数中的右方括号（|]|们）必须用花括号括起来，以避免混淆参数解析器。}

%
%   \caveat{A left square brace (|[|) that immediately follows an
%   \cs\include command's mandatory \meta{filename} argument (after optional
%   whitespace) will be considered to delimit the beginning of the
%   \meta{posthook} argument.  If you want an actual left brace character in
%   this position, you must precede it with something that will terminate
%   \TeX's search for an optional argument, such as \cs\relax, |{}|, or a
%   paragraph division (explicit or implicit).}

%\caveat{如果在\cs\include 命令的必需参数\meta{filename}（可带可选的空格）之后紧跟着一个左方括号（|[|），那么它将被视为\meta{posthook}参数的起始位置。如果您想在该位置放置实际的左括号字符，您必须在其前面加上一些东西来终止\TeX 对可选参数的搜索，例如\cs\relax、|{}|或段落分隔符（显式或隐式）。}

%
%   The commands \cs\AtBeginInclude\meta{tokens} and
%   \cs\AtEndInclude\meta{tokens} are analagous to standard \LaTeX{}'s commands
%   \cs\AtBeginDocument\meta{tokens} and \cs\AtEndDocument\meta{tokens}.\\命令\cs\AtBeginInclude\meta{tokens}和\cs\AtEndInclude\meta{tokens}类似于标准的\LaTeX{}命令\cs\AtBeginDocument\meta{tokens}和\cs\AtEndDocument\meta{tokens}。


%
%   FIX: multiple instances concatenate?\\修复：多个实例连接？
%
%   FIX give name to what's held by atbegininclude so that an override can mention it\\FIX将在atbegininclude中保存的内容命名，以便覆盖可以提及它。

%   
%   When the optional argument \meta{prehook} is given to \cs\include, its
%   contents will be used instead of whatever has been specified with
%   \cs\AtBeginInclude, for that one inclusion.  Likewise, \meta{posthook} will
%   be used in place of whatever has been specified with \cs\AtEndInclude for
%   that one inclusion.  \\当给\cs\include 添加可选参数\meta{prehook}时，其内容将替代用\cs\AtBeginInclude 指定的内容，仅用于该次包含。同样地，\meta{posthook}将替代用\cs\AtEndInclude 指定的内容，仅用于该次包含。


%
%   For example, putting the \cs\chapter declaration in the \meta{prehook}
%   argument allows the chapter name, and, optionally, a corresponding \LaTeX{}
%   label, to be kept in the including file, rather than the included file:\\举个例子，将\cs\chapter 声明放在\meta{prehook}参数中，可以让章节名称以及可选的相应\LaTeX{}标签保留在包含文件中，而不是被包含的文件中：
% \begin{codeexample}
% \include [\chapter{Whales}
%           \label{ch:whales}]
%          {big-cetecea}
% \end{codeexample}
%
%   The \meta{posthook} argument can be used, for example, to delimit or undo
%   declarations made in the \meta{prehook} or the included file: FIX: better
%   example, since these coudl simple appear before/after the \cs\include
%   without ill effect.\\\meta{posthook} 参数可以用于限定或撤销在 \meta{prehook} 或包含文件中的声明。例如，可以在 \cs\include 前后简单地添加这些声明，而不会产生不良影响。FIX: 更好的例子。

% \begin{codeexample}
% \include [\begingroup\larger] % this part in larger type
%          {manifesto}
%          [\endgroup]
% \end{codeexample}
%
% \DescribeMacro{\include*}
% \DescribeMacro\IncludeSurround
% \DescribeMacro\DefaultIncludeSurround
%   \cname{include*}\oarg{prehook}\marg{filename}\oarg{posthook} is like
%   \cs\include but omits the usual \cs\clearpage{}s that surround an included
%   part, replacing them with \cs\IncludeSurround, which defaults to
%   \cs\DefaultIncludeSurround.  The contents of \cs\IncludeSurround are
%   inserted before the \meta{prehook} or whatever has been specified with
%   \cs\AtBeginInclude, and after the \meta{posthook} or whatever has been
%   specified with \cs\AtEndInclude.\\\cname{include*}\oarg{prehook}\marg{filename}\oarg{posthook} 和 \cs\include 类似，但省略了通常包含的 \cs\clearpage{}，它们被替换为 \cs\IncludeSurround，默认为 \cs\DefaultIncludeSurround。 \cs\IncludeSurround 的内容被插入到 \meta{prehook} 或使用 \cs\AtBeginInclude 指定的任何内容之前，以及 \meta{posthook} 或使用 \cs\AtEndInclude 指定的任何内容之后。


% 
%   \caveat{A space gets inserted after an \cname{include*} unless it is
%   suppressed by a |%| immediately following.  Combined with trailing spaces 
%   in the included file, this may lead to unwanted spaces.  For this reason,
%   \cs\DefaultIncludeSurround is initialized to \cname{par}.  When the user
%   must explicitly change \cs\IncludeSurround to achieve totally smooth flow
%   from main file to included file, they are more likely to consult this
%   documentation if they spot a problem.  Package and class writers should
%   take this difficulty into account when changing \cs\DefaultIncludeSurround.}

% 在\cname{include*}之后会插入一个空格，除非紧接着有一个|\％|来抑制它。加上被包含文件中的尾随空格，这可能会导致不必要的空格。因此，\cs\DefaultIncludeSurround 被初始化为\cname{par}。当用户必须显式更改\cs\IncludeSurround 以实现从主文件到包含文件的完全平滑流时，如果他们发现问题，他们更有可能咨询此文档。包和类的编写者在更改\cs\DefaultIncludeSurround 时应考虑到这一困难。

%
% \DescribeMacro\includeonly
%   The \cs\includeonly command is reimplemented, but its usage and behavior is
%   the same as the standard \LaTeX{} version.\\这个命令\cs\includeonly 被重新实现了，但是它的用法和行为与标准的\LaTeX{}版本相同。
%
% \DescribeMacro\includeall
%   The \cs\includeall command cancels the effect of any \cs\includeonly
%   command presently in effect.  \\\cs\includeall 命令取消任何当前生效的 \cs\includeonly 命令的影响。
% 
%   If you write an \cs\includeonly so that each file appears on its own line,
%   it is particularly easy to add and remove files to include by commenting
%   out their lines, but it becomes laborious to comment out the entire
%   \cs\includeonly command.  It's easy, however, to uncomment a single
%   \cs\includeall command when you want to process the entire document.  (Or
%   \cs\includeall could be inserted from the command line that invokes
%   \LaTeX{}, and so on.)\\如果你使用\cs\includeonly 命令，每个文件单独一行，添加或删除需要包含的文件时，注释掉它们的行非常容易，但注释掉整个\cs\includeonly 命令就变得很麻烦了。然而，当你想要处理整个文档时，取消注释单个\cs\includeall 命令非常容易。(或者可以在调用\LaTeX{}命令行时插入\cs\includeall 命令，等等。)

% 
%   \section{Experimental features\\实验特性}
%
% \DescribeMacro\includeenv
%   \cs\includeenv\oarg{prehook}\marg{filename}\marg{environment name}%
%                 \marg{instance}\oarg{posthook}
%   \cs\includeenv*\oarg{prehook}\marg{filename}\marg{environment name}%
%                 \marg{instance}\oarg{posthook}
%
%   \cs\includeenv includes the contents of a single \LaTeX{} environment that
%   appears in \meta{filename}.  The environment is specified by giving its
%   name (\meta{environment}) and an instance of that environment in the file
%   (\meta{instance}).  Presently, \meta{instance} is ignored, so that it will
%   always be the contents of the first occurrence in \meta{filename} of a
%   \LaTeX{} environment with the name \meta{environment} that will be
%   included.  In the future, the \meta{instance} argument may be used to
%   specify the $n$th instance of the environment within the file, or further
%   specify the environment to be extracted in some other way.\\\cs\includeenv 命令用于将出现在 \meta{filename} 中的单个 \LaTeX{} 环境的内容包含进来。该环境由其名称（\meta{environment}）和文件中该环境的一个实例（\meta{instance}）来指定。目前，\meta{instance} 参数被忽略，因此它将始终是第一个出现在 \meta{filename} 中的名称为 \meta{environment} 的 \LaTeX{} 环境的内容。未来，\meta{instance} 参数可以用于指定文件中环境的第 $n$ 个实例，或以其他方式进一步指定要提取的环境。

%   
% FIX: right now they're required; skip text up to documentclass OR the target, 
% then branch?\\修复：目前它们是必需的；跳过文档类或目标之前的文本，然后分支？

%
% Good preamble syntactic sugar:\\良好的前导语法糖：\\ |\let\TheMarkupDeclarations\begin|
%
% \todo{You can insert a \cs\usepackage into the main aux file and have it
% loaded properly.  If we discover a \cs\usepackage that is not a formatting
% package, one strategy is to insert a corresponding \cs\usepackage into the
% (main) aux file and then bail after the preamble.}

% 您可以在主要的辅助文件中插入一个\cs\usepackage 并正确加载它。如果我们发现一个不是格式化包的\cs\usepackage，那么一种策略是在（主要的）辅助文件中插入相应的\cs\usepackage，然后在导言部分后退出。

%
% \todo{You can't skip verbatim text via macro argument processing and sugar.
% this means that a major reimplementation of skipping using verbatim methods
% will have to be done.}

%你不能通过宏参数处理和语法糖跳过逐字文本。 这意味着必须使用逐字方法进行重大的跳过重新实现。

%
%   The included file is permitted (but not required) to have its own
%   \cs\documentclass command and \code{\begin{document}}\lips
%   \cs{\end{document}} pair.  \cs\includeenv extracts the specified
%   environment by processing the preamble if one exists, skipping text up
%   until the beginning of the specified environment, processing the contents
%   of the environment, and skipping the rest of the included part.\\所包含的文件可以（但不是必须）拥有自己的\cs\documentclass 命令和\code{\begin{document}}\lips\cs{\end{document}}对。 \cs\includeenv 通过处理前导文本（如果存在），跳过指定环境的开头之前的文本，处理环境的内容，然后跳过所包含部分的其余部分，提取指定的环境。

%  
%   Notice that while a \code{\begin{document}}\lips\code{\end{document}} pair
%   may not technically delimit a \LaTeX{} environment, you may nevertheless
%   (because it looks exactly like an environment) set \meta{environment} to
%   |document| to extract the contents of the \env{document} ``environment'' of
%   \meta{filename}.\\请注意，虽然\code{\begin{document}}\lips\code{\end{document}}对可能不严格限定一个\LaTeX{}环境，但由于它看起来与环境完全一样，因此您仍然可以将\meta{environment}设置为|document|，以提取\meta{filename}的\env{document}``环境''的内容。

%
%   Consider the following issues when you are tempted to use this
%   command.  Maybe the \cs\usepackage you are about to disregard is necessary
%   to processing the part's contents.  Maybe it conflicts with a package
%   already loaded at top level.  Maybe both!  The same holds of course for the
%   defining commands like \cs\newcommand that one expects to find in a
%   package.\\当你有使用这个命令的冲动时，请考虑以下问题。也许你打算忽略的 \cs\usepackage 对处理部分内容是必要的。也许它与已在顶层加载的包冲突。也许两者都是！当然，对于定义命令的命令，如 \cs\newcommand，人们期望在包中找到它们，也是同样的情况。

%  
%   A deep problem with the design of a \LaTeX{} source file exists with
%   respect to the function of the preamble.  The preamble contains
%   declarations that determine how the document below will be formatted.
%   Unfortunately, there is no way to make the distinction between:\\\LaTeX{} 源文件设计中存在一个与导言部分功能相关的深层问题。导言部分包含决定下面文档格式的声明。不幸的是，无法区分以下两种情况：
%   \begin{enumerate}
%     \item 
%      declarations that signal that certain markup will appear in the document
%      that are either not defined in the \LaTeX{} kernel or are used with a
%      different syntax\\声明表明某些标记将出现在文档中，这些标记在\LaTeX{}内核中未定义，或者使用不同的语法。
%     \item declarations that describe how a certain instance
%      of the document should be formatted\\声明描述文档的某个实例应该如何格式化。
%   \end{enumerate}
 
%   Examples in the first category are \code{\usepackage{url}} and \code{FIX
%   example}, and examples in the second are \code{\usepackage{times}} and
%   \code{FIX}.  When you want to include the document or a part of it in
%   another document, it is absolutely necessary to make this distinction so
%   that declarations in category (1) can be processed and declarations in
%   category (2) can be ignored.  ^^A FIX: \cat{} is a compsci command?
%\\第一类示例包括\code{\usepackage{url}}和\code{FIX example}，第二类示例包括\code{\usepackage{times}}和\code{FIX}。当您想要将文档或其中的一部分包含在另一个文档中时，有必要进行区分，以便可以处理类别（1）中的声明并忽略类别（2）中的声明。^^A FIX：\ cat {}是计算机科学命令吗？

%
%   Adopting a convention on the use of the preamble can overcome this design
%   problem, but it will not fix the problem for legacy files whose preambles
%   do not obey the convention.  Legacy files that contain category (1)
%   declarations in their preambles must either be altered or specifically
%   accommodated with additional commands.\\采用有关前言使用的公约可以克服这个设计问题，但对于那些前言不遵守公约的遗留文件，它并不能解决问题。在前言中包含类别（1）声明的遗留文件必须进行修改或使用额外的命令进行特殊适配。


%
%   The convention I suggest is to |\usepackage{preamble}|.  \cs\beginmarkup
%   \cs\endmarkup. FIX.  Can we arrange to load \\我建议的惯例是使用 |\usepackage{preamble}|，\cs\beginmarkup \cs\endmarkup FIX。我们能否安排加载？

%
%   When \cs\includeenv encounters a \cs\usepackage command in the included
%   part, it looks at the packages in the argument of \cs\usepackage and issues
%   a warning if the package is not already loaded and does not appear on a
%   list of packages known whose use falls entirely within category (2).  (See
%   the \cs\DeclareFormattingPackage command below.)\\当 \cs\includeenv 在被包含的部分中遇到 \cs\usepackage 命令时，它会查看 \cs\usepackage 命令中的参数中的包，如果该包尚未加载并且不在已知的完全属于类别(2) 的包列表中，则会发出警告。（请参见下面的 \cs\DeclareFormattingPackage 命令。）

%
%   The \cs\documentclass command is of course also a category (1) declaration.
%   Presently, if \cs\includeenv detects that the arguments to an included
%   \cs\documentclass command differ from the arguments of the
%   \cs\documentclass command of the including document, it will issue a
%   warning, and continue.  In the future, I hope to make this behavior smarter
%   by having \cs\includeenv take specific actions for specific combinations of
%   arguments.  For example, if the included document's class implies the use
%   of markup not defined in the parent's class, an appropriate action would be
%   to define the missing markup commands.  A document of class \class{report}
%   and a document of class \class{article}, on the other hand, do not (I don't
%   think) declare different markup, so that there should be no warning in this
%   case.\\当然，\cs\documentclass 命令也是一个类别（1）声明。目前，如果 \cs\includeenv 检测到被包含文档中的 \cs\documentclass 命令的参数与包含文档中的 \cs\documentclass 命令的参数不同，它将发出警告并继续执行。将来，我希望通过使 \cs\includeenv 针对特定的参数组合采取特定的操作来使此行为更加智能化。例如，如果被包含文档的类别暗示使用了父类别中未定义的标记，合适的操作是定义缺失的标记命令。另一方面，类别为 \class{report} 和类别为 \class{article} 的文档不（我认为）声明不同的标记，因此在这种情况下不应发出警告。
%
% \DescribeMacro{\includeenv*}
%   \cname{includeenv*} is analogous to \cname{include*}, that is, it surrounds
%   the included part with \cs\IncludeSurround rather than \cs\clearpage.\\\cname{includeenv*}类似于\cname{include*}，即它使用\cs\IncludeSurround 环绕包含的部分，而不是\cs\clearpage。

%
% \DescribeMacro\includedoc
% \DescribeMacro{\includedoc*}
%   \cs\includedoc\oarg{prehook}\marg{file name}\oarg{posthook} is shorthand
%   for(是一种简写形式，等同于)
%   \cs\includeenv\oarg{prehook}\marg{filename}\marg{|document|}\marg{}\oarg{posthook}.
%
%   \cname{includedoc*} is analogous(类似) to \cname{includeenv*}.
%
%   \section{Options\\选项}
%
%     \subsection{Simple\\简单选项}\label{opt:simple}
%
% If the \option{simple} option is given, the only new feature provided is the
% hooks (features \ref{item:hooks} and~\ref{item:hooks:opt} above).  As
% with standard \LaTeX{}, \cs\clearpage{}s surround an \cs\include and nesting
% \cs\include{}s gives an error.  \package{Newclude} will only behave
% differently than standard \LaTeX{}  command scans for
% possible optional arguments will make a different.\\如果给定了\option{simple}选项，则提供的唯一新功能是钩子（参见上文中的特性\ref{item:hooks}和\ref{item:hooks:opt}）。与标准的\LaTeX{}一样，\cs\clearpage{}将包围\cs\include，嵌套的\cs\include{}会导致错误。与标准的\LaTeX{}不同的是，\package{Newclude}在扫描可能的可选参数时会有所不同。


%

%
%     \subsection{Tag\\标签}\label{opt:tag}
% The \option{tag} option causes \LaTeX{} to use just one \ext{aux} file.  
% This option, which is the default, works well.  I am aware of the following
% two differences from the kernel's including system:\\\option{tag}选项会让\LaTeX{}只使用一个\ext{aux}文件。这个选项是默认的，并且效果很好。我意识到与内核的包含系统有以下两个不同之处：
%
% \begin{enumerate}
%   \item 
%    If the \LaTeX{} process is stopped during the processing of a part, all
%    information normally stored in an \ext{aux} file from that point in the
%    document forward is lost.  In the kernel's system, processing the document
%    twice more would recover any \ext{aux} information previously generated for
%    parts.\\果在处理文档的某个部分时停止了 \LaTeX{} 进程，则从该点开始在 \ext{aux} 文件中通常存储的所有信息都将丢失。在内核系统中，再次处理文档两次会恢复以前生成的所有部分的 \ext{aux} 信息
%   
%    If \LaTeX{} is always invoked in \cs\nonstopmode (e.g., by \auctex), then
%    this difference is only going to occur when there are catastrophic errors
%    that cause even \cs\nonstopmode to terminate processing.。\\如果 \LaTeX{} 总是在 \cs\nonstopmode 下调用（例如通过 \auctex），那么只有在出现灾难性错误导致即使 \cs\nonstopmode 也无法继续处理时，才会出现这种差异。
%   
%  \item Other packages and classes that redefine kernel commands that write to
%    \cname{@auxout} will cause problems.\\其他重新定义内核命令并写入 \cname{@auxout} 的包和类会导致问题。
% \end{enumerate}
%
% The first difference must be accepted.  The second difference can be removed
% on a case by case basis, by specifically coding compatibility with such
% packages and classes.  I intend to do this.  Here is a list of such packages
% and classes known to me:\\第一个差异必须被接受。第二个差异可以根据情况逐个解决，通过特别编写与这些包和类的兼容性代码。我打算这样做。以下是我所知道的这些包和类的列表：

%
% \begin{tabular}{l}
%   \meta{none so far}
% \end{tabular}
% If you discover any more for this list, please write me!\\如果您发现了更多的内容，请写信给我！

%
% It's also very easy to revise the other package to be compatible with
% \package{newclude} as it is now.  See section~\ref{adapt} below, which
% includes a list of relevant kernel commands.\\现在，将其他软件包修改为与\package{newclude}兼容也非常容易。请参见下面的第~\ref{adapt}节，其中包括相关内核命令的列表。

%
%     \subsection{Allocate\\分配}\label{opt:allocate}
%
% The second way (the \option{allocate} option) represents my first attempt at
% a solution, and until I am sure it has no advantages over \option{tag} under
% any circumstances, it will continue to be an option.\\第二种方法（\option{allocate}选项）是我第一次尝试的解决方案，直到我确定它在任何情况下都没有优势，它将继续作为一个选项。

%
% The \option{allocate} option causes \LaTeX{} to dynamically allocate \TeX{}
% output streams to each part as they are needed.  Streams are allocated when
% processing of the part begins, and are reclaimed after the ejection of the
% last page to which the part has contributed.  Like the old system, a separate
% \ext{aux} file is created for each part.  The limitation of this
% implementation is that \TeX{} only possesses 16 output streams.  Each of the
% commands \cs\tableofcontents, \cs\listoffigures, \cs\listoftables,
% \cs\makeglossary, and \cs\makeindex causes \LaTeX{} to use one output stream.
% The remainder (minus any streams required by packages and classes) are
% available for the including system.  If $n$ streams are available, the level
% of nesting possible is $n - 1$ minus the maximum number of parts that occur
% on the same page.  For example, if 10 streams are available and the parts
% never appear on the same page (the old behavior required by the
% \cs\clearpage{}s), then 8 levels of nesting are possible (which is 8, not 7
% more than with the old system).  The maximum number of parts that may
% contribute the to same page is calculated with the same equation.  Note:
% \TeX's page-breaking algorithm looks ahead until it has more than enough
% material to fill one page.  You must count all the new \ext{aux} files that
% are opened during a look-ahead as contributing to the page in question, even
% if some of the later ones do not actually contribute to the page after the
% break is chosen.\\\option{allocate}选项会使\LaTeX{}在需要时为每个部分动态分配\TeX{}输出流。处理部分时分配流，并在该部分最后一页被弹出后回收。与旧系统一样，每个部分都会创建单独的\ext{aux}文件。此实现的限制是\TeX{}仅拥有16个输出流。每个命令\cs\tableofcontents、\cs\listoffigures、\cs\listoftables、\cs\makeglossary 和\cs\makeindex 都会使用一个输出流。剩余的流（减去包和类所需的流）可用于包含系统。如果有$n$个流可用，则可能的嵌套级别为$n-1$，减去出现在同一页上的最大部分数量。例如，如果有10个可用流并且部分从不出现在同一页上（旧行为需要\cs\clearpage{}），则可能有8个嵌套级别（比旧系统多8个，而不是7个）。可以使用相同的方程式计算可能贡献到同一页的最大部分数量。注意：\TeX{}的分页算法会向前查找，直到有足够的材料填充一页。必须将所有新打开的\ext{aux}文件都计算为对所讨论的页面的贡献，即使一些后来的文件在选择分页后实际上不会对页面产生贡献。

%
% The \option{allocate} solution is itself implemented in two ways.  The system
% either reserves a fixed number of output streams from the start, or will
% dynamically claim and free them as needed.  The dynamic solution is the
% default.  I do not see much use for the static solution at present.  If the
% dynamic system claims streams that are later required, then it is simply a
% question of whether \package{newclude} or the other feature is going to
% signal an error about having no more streams to allocate.\\\option{allocate} 解决方案本身有两种实现方式。系统要么从一开始就保留一定数量的输出流，要么在需要时动态地申请和释放它们。动态解决方案是默认的。目前我不认为静态解决方案有太多用处。如果动态系统申请了后续需要的流，则只是一个问题，即 \package{newclude} 或其他功能是否会发出关于无法再分配流的错误信号。


%
%   \section{Programmers' interface\\程序员接口}
% 
% \DescribeMacro\IfAllowed
%   \cs\IfAllowed\marg{part name}\marg{true}\marg{false} executes \meta{true}
%   if \meta{part-name} is on the list of files to be included and \meta{false}
%   otherwise.  If there is no list, executes \meta{true}.\\\cs\IfAllowed\marg{部件名称}\marg{真值}\marg{假值}，如果\meta{part-name}在待包含文件列表中，则执行\meta{true}，否则执行\meta{false}。如果没有列表，则执行\meta{true}。
%
% \DescribeMacro\IncludeName
%   \cs\IncludeName expands to the name of the part currently being processed.
%   In the toplevel source file, it will expand to \cs\jobname.\\\cs\IncludeName 展开为当前正在处理的部分的名称。 在顶层源文件中，它将展开为 \cs\jobname。
%
% \DescribeMacro\ParentName
%   \cs\ParentName expands to the name of the part that includes the part
%   currently being processed.  In the toplevel source file, expanding
%   \cs\ParentName will generate a warning and expand to \cs\jobname (which is
%   also what \cs\IncludeName expands to).\\\cs\ParentName 展开为包含当前正在处理的部分的名称。在顶层源文件中，展开\cs\ParentName 将生成一个警告并展开为\cs\jobname（\cs\IncludeName 也是如此）。
%
% FIX: root source file?  toplevel?  master? principle source?  glossary!\\修复：根源文件？顶层文件？主文件？原则性文件？词汇表！
%
% \DescribeMacro\DeclareFormattingPackage
%   \cs\DeclareFormattingPackage\marg{package name} declares \meta{package
%   name} to be a package that only makes formatting declarations, that is, the
%   effect of using it falls entirely within category (2).  If a formatting
%   package occurs in a \cs\usepackage declaration in the preamble of a part
%   included by \cs\includeenv, no warning will be given.  An example of a
%   formatting package is the \package{times} package.  No facility is provided
%   to distinguish the case when a package is used with or without certain
%   package options, so do not declare a package as a formatting package unless
%   it is so regardless of the options it is passed.\\\cs\DeclareFormattingPackage\marg{包名}声明\meta{包名}为仅用于格式声明的包，即使用它的效果完全限于类别（2）。如果格式包出现在由\cs\includeenv包含的部分的导言区的\cs\usepackage声明中，不会发出警告。格式包的一个例子是\package{times}包。没有提供区分使用或不使用某些包选项的情况的工具，因此，除非无论传递哪些选项都是如此，否则不要将包声明为格式包。
%
%   If you send me the names of formatting packages, I will include them in the
%   next release of \package{newclude}.  Meanwhile, you may declare them in
%   \file{newclude.cfg}.  Do the same for your local formatting packages if you
%   wish.  It does no harm to declare a package as a formatting package more
%   than once.\\如果您给我发送格式化包的名称，我将在\package{newclude}的下一个版本中包括它们。与此同时，您可以在\file{newclude.cfg}中声明它们。如果您愿意，也可以为您本地的格式化包执行相同的操作。将一个包声明为格式化包多次不会造成任何损害。

%
% \DescribeMacro\ifSkipPreamble
% \DescribeMacro\SkipPreambletrue
% \DescribeMacro\SkipPreamblefalse
%   
% \DescribeMacro\Disable
% \DescribeMacro\DisableAll
%   \cs\Disable\marg{tokens} provides a way to ignore additional commands when
%   using \cs\includeenv and friends.  If you want to cause the macro \cs\foo
%   which takes no arguments to be entirely ignored in parts, issue the command
%   \code{\Disable{\let\foo\relax}} any time before including the parts you
%   want to affect.  If \cs\foo takes one mandatory argument, write
%   \code{\let\foo\Gobble} instead.  If \cs\foo takes one optional and one
%   mandatory, write \code{\let\foo\GobbleOM}.  And so on.  For other examples,
%   see the gobbling commands in the \package{moredefs} package (which
%   \package{newclude} requires), or write your own.\\\cs\Disable\marg{tokens} 提供了一种在使用 \cs\includeenv 和相关命令时忽略其他命令的方法。如果你想让不带参数的宏 \cs\foo 在某些部分完全被忽略，可以在包含你想要影响的部分之前随时发出命令 \code{\Disable{\let\foo\relax}}。如果 \cs\foo 接受一个必选参数，则应写作 \code{\let\foo\Gobble}。如果 \cs\foo 接受一个可选参数和一个必选参数，则应写作 \code{\let\foo\GobbleOM}。等等。对于其他示例，请参见 \package{moredefs} 包中的吞噬命令（\package{newclude} 要求），或编写自己的命令。


%
%   The arguments to \cs\Disable are accumulated and executed by the command
%   \cs\DisableAll, which is executed inside a group that contains a part when
%   it is included.\\\cs\Disable 的参数被累计并由命令\cs\DisableAll 执行，在包含它时执行一个包含部分的组中。


%
%   There is no way to undo the effect of issuing a \cs\Disable command.\\没有办法撤销发出\cs\Disable 命令的影响。

%
%   \section{How to play nicely with \package{newclude}\\如何与\package{newclude}友好地玩耍}\label{adapt}
%
% To adapt a package or class for use with the \option{tag} option of\\为了使用\option{tag}选项，需要适应一个包或类。
% \package{newclude}:
% \begin{enumerate}
% \item replace |\immediate\write\@auxout| with \cs{\@writeaux}
% \item replace |\protected@write\@auxout| with \cs{\protected@writeaux}
% \item add
% \begin{codeexample}
% \providecommand\@writeaux {%
%   \immediate\write\@auxout
% }
% \providecommand\protected@writeaux {%
%   \protected@write\@auxout
% }
% \end{codeexample}
% \end{enumerate}
%
% \StopEventually{}
%
% \part{Implementation}
%
% \section{Version control}
%
%  \begin{macro}{\fileinfo}
%  \begin{macro}{\DoXUsepackagE}
%  \begin{macro}{\HaveECitationS}
%  \begin{macro}{\fileversion}
%  \begin{macro}{\filedate}
%  \begin{macro}{\docdate}
%  \begin{macro}{\PPOptArg}
% These definitions must be the first ones in the file. \\ 这些定义必须是文件中的第一个。

%    \begin{macrocode}
\def\fileinfo{A new system for including files (Frankenstein's backbone)}
\def\DoXPackageS {}
\def\fileversion{v2}
\def\filedate{1999/11/02}
\def\docdate{1999/11/02}
\edef\PPOptArg {%
  \filedate\space \fileversion\space \fileinfo
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
% If we're loading this file from a \cs\ProcessDTXFile command (see the
% \package{compsci} package), then \cs\JusTLoaDInformatioN will be defined;
% othewise we assume it is not (that's why the FunkY NamE).\\如果我们正在从\cs\ProcessDTXFile 命令（请参见\package{compsci}包）加载此文件，则\cs\JusTLoaDInformatioN 将被定义；否则我们假设它不是（这就是为什么有个" FunkY NamE"）。

% 
% If we're loading from \cs\ProcessDTXFile, we want to load the packages listed
% in \cs\DoXPackageS (needed to typeset the documentation for this file) and
% then bail out.  Otherwise, we're using this file in a normal way as a
% package, so do nothing.  \cs\DoXPackageS, if there are any, are declared in
% the \ext{dtx} file, and, if you're reading the typeset documentation of this
% package, would appear just above.  (It's OK to call \cs\usepackage with an
% empty argument or \cs\relax, by the way.)\\如果我们从\cs\ProcessDTXFile 加载，我们希望加载\cs\DoXPackageS 中列出的软件包（需要为此文件排版文档），然后退出。否则，我们将以正常方式将此文件用作软件包，因此不执行任何操作。\cs\DoXPackageS（如果有的话）在\ext{dtx}文件中声明，如果您正在阅读此软件包的排版文档，将出现在其上方。（顺便说一句，使用空参数或\cs\relax调用\cs\usepackage 是可以的。）
%    \begin{macrocode}
\makeatletter% A special comment to help create bst files.  Don't change!
\@ifundefined{JusTLoaDInformatioN} {%
  }{% ELSE (we know the compsci package is already loaded, too)
  \UndefineCS\JusTLoaDInformatioN
  \SaveDoXVarS
  \eExpand\csname DoXPackageS\endcsname\In {%use \csname in case it's undefined
    \usepackage{#1}%
  }%
  \RestoreDoXVarS
  \makeatother
  \endinput
}% A special comment to help create bst files.  Don't change!
%    \end{macrocode}
%
% Now we check for \LaTeX2e and declare the LaTeX package.\\现在我们检查是否为\LaTeX2e并声明LaTeX包。
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{newclude}[\PPOptArg]
%    \end{macrocode}^^A special comment to help create bst files.  Don't change!
%
% ^^A NOTE: We have to compensate for the above backslashes, which are not
% ^^A       actually in the .dtx file the author works on, by adding to the
% ^^A       CheckSum.
%%
% \AddToCheckSum{17}^^A `dtx-update-checksum' automatically handles this.
% \AddToCheckSum{7}^^A The half a macrocode env. at the top is missed, however...
% \AddToCheckSum{10}^^A ... and so are the 5 \defs from the .dtx file 
%                   ^^A     that precede it.
% \IfCitations {%
%   \AddToCheckSum{2}^^A When \initelyHavECitationS is defined in
% }                  ^^A the .dtx file, we need 2 more in the CheckSum.
%
%
%   \section{Review of the kernel's inclusion system\\内核包含系统的回顾}
%
% One \ext{aux} file is written to disk for the \term{principle source} and one
% for each of the included \term{parts}.  The reason to have a separate ones
% for the parts is so that information from the last time the part was included
% is retained in subsequent runs even when the part is excluded by
% \cs\includeonly.  Suppose a part is processed once, and on a subsequent run
% its name is removed from the \cs\includeonly list.  This run will still read
% in the part's \ext{aux} file, since the \ext{aux} file of any part that was
% \cs\included during the last run is always read.  But the information therein
% is not going to be regenerated in this run, since the part will not be
% processed.  The main \ext{aux} file is created anew with each run, so this
% information would be lost if it resided there.\\对于\term{主源文件}，会写入一个\ext{aux}文件到磁盘中，对于每个被包含的\term{部分}，也会写入一个\ext{aux}文件。之所以要为每个部分分别写入，是为了保留上次包含该部分时的信息，即使该部分在\cs\includeonly 中被排除。假设一个部分被处理一次，在下一次运行中，它的名称被从\cs\includeonly 列表中移除。即使这次运行不处理该部分，它的\ext{aux}文件仍然会被读取，因为上次运行时被\cs\include 的任何部分的\ext{aux}文件都会被读取。但是，在这次运行中，该部分的信息不会被重新生成，因为该部分不会被处理。主\ext{aux}文件在每次运行时都会重新创建，因此如果该信息驻留在主\ext{aux}文件中，它就会丢失。

%
% To handle writing these multiple \ext{aux} files, the kernel uses two of
% \TeX's output streams.  When a routine writes to an auxiliary file, it writes
% to \cname{@auxout}, which is \cs\let to either \cname{@mainaux}, the
% \ext{aux} file for the principle source, or \cname{@partaux} the \ext{aux}
% file for all the parts each in turn.\\为了处理多个 \ext{aux} 文件的写入，内核使用了 \TeX 的两个输出流。当一个例程向辅助文件写入时，它会写入到 \cname{@auxout}，它是一个 \cs，其值要么是 \cname{@mainaux}，即主源文件的 \ext{aux} 文件，要么是 \cname{@partaux}，即所有部分的 \ext{aux} 文件。

%
% When encountering an \cs\include command, but before deciding whether or not
% to actually load the part, the kernel writes a command to \cname{@mainaux}
% that will load the part's \ext{aux} file.  The main \ext{aux}
% file is loaded by \cs\document, so that \emph{all} \ext{aux} files are read
% in every time the principle source is processed.\\遇到\cs\include 命令时，在决定是否实际加载该部分之前，内核会向\cname{@mainaux}写入一个命令，以加载该部分的\ext{aux}文件。主\ext{aux}文件由\cs\document 加载，因此在处理主源文件时，每次都会读取\emph{所有}的\ext{aux}文件。


%
% If a part is actually loaded, a \term{checkpoint} is written to the part's
% \ext{aux} file consisting of a snapshot of the counters (a record of the
% values of all \LaTeX{} counters).  On the next run, if the part is not
% actually loaded, the information in its \ext{aux} file has nevertheless
% already been processed by \cs\document.  Processing the checkpoint causes a
% macro to be defined that when invoked restores the counter state.  When
% \cs\include does not actually load a part it calls this checkpoint macro
% instead to alter the present counter state.\\如果一个部分实际上被加载了，那么会在这个部分的 \ext{aux} 文件中写入一个\term{检查点}，其中包含了计数器的快照（即所有 \LaTeX{} 计数器的值的记录）。在下一次运行时，如果这个部分实际上没有被加载，那么它的 \ext{aux} 文件中的信息已经被 \cs\document 处理过了。处理检查点会定义一个宏，当调用它时会恢复计数器状态。当 \cs\include 实际上没有加载一个部分时，它会调用这个检查点宏来改变当前计数器状态。
%
% This system has pitfalls as well as benefits.  It is useful to keep the
% bibliography, citations, cross references, and page numbers up to date in
% certain situations, but the results can be confusing sometimes, because
% checkpoints are not documented. (Perhaps this is remedied in the 2d edition
% of the \LaTeX{} manual.)  How, besides reading the code, or finding out the
% hard way, is anyone supposed to guess that rearranging two ``deactivated''
% \cs\include statements in a principle source will bring havoc on the page
% numbers?\\这个系统有优点也有缺点。在某些情况下，保持参考文献、引用、交叉引用和页码的最新状态非常有用，但有时结果可能令人困惑，因为检查点没有记录。（也许在第二版的\LaTeX{}手册中会有解决方法。）除了阅读代码或通过艰难的方式找出，有谁能猜到在主要源文件中重新排列两个“停用”的\cs\include语句会对页码造成破坏呢？

%
%   \section{Discussion of \package{newclude}'s inclusion system\\\package{newclude}包中的包含系统讨论}
%
% The simple removal of the \cs\clearpage{}s that surround an included part
% would cause a problem involving the delayed action of \cs\write commands.
% Suppose a part ending with a \cs\write command ends halfway down a page, and
% another \cs\write occurs in the principle source immediately (or soon) after
% the inclusion.  The first must be written to \cname{@partaux} and the second
% to \cname{@mainaux}.  If we close \cname{@partaux} while the first \cs\write
% is still pending, that is, before the current page has been shipped out, then
% the \cs\write will be destined for a closed stream and therefore go to the
% log file and terminal.  The \cs\clearpage{}s solve this by flushing all
% pending \cs\writes.  Then we can close \cname{@partaux} immediately and
% reopen \cname{@mainaux}.\\简单地删除包含部分周围的\cs\clearpage{}会导致延迟执行\cs\write 命令的问题。假设一个以\cs\write 命令结束的部分在页面中间结束，而另一个\cs\write 出现在主要源代码中立即（或很快）之后的包含中。第一个必须写入\cname{@partaux}，而第二个必须写入\cname{@mainaux}。如果我们在第一个\cs\write 仍然挂起（即在当前页面已经被输出之前）时关闭\cname{@partaux}，那么\cs\write 将会被写入到一个关闭的流中，因此将会转到日志文件和终端。\cs\clearpage{}通过刷新所有挂起的\cs\writes 解决了这个问题。然后我们可以立即关闭\cname{@partaux}并重新打开\cname{@mainaux}。

%
% Successful removal of the \cs\clearpage{}s can be accomplished either by
% having the entire document use just one auxiliary file, or by allocating
% additional output streams so that it becomes possible to avoid closing
% \cname{@partaux} until after the current page is shipped out when all the
% \cs\write{}'s to it have been completed.\\成功删除\cs\clearpage{}可以通过两种方式实现，一是整个文档只使用一个辅助文件，二是分配额外的输出流，以便在所有对\cname{@partaux}的\cs\write{}完成后，延迟关闭它直到当前页面已被输出。

%
%   \section{Package initialization\\包初始化}
%
%    \begin{macrocode}
\RequirePackage{moredefs}
%    \end{macrocode}
%
%    \begin{macrocode}
\InitCS\sc@t@a
\DeclareOption{simple} {%
  \input{simple.sto}
  \let\sc@t@a\endinput
}
%^^A\DeclareOption{group} {%
%^^A  \AtEndOfPackage {\input{group.sto}}
%^^A}
\DeclareOption{tag} {%
  \AtEndOfPackage {\input{tag.sto}}
}
\DeclareOption{allocate} {%
  \AtEndOfPackage {\input{allocate.sto}}
}
\DeclareBooleanOptions{dynamic}{static}
\ExecuteOptions{tag}
\ProcessOptions
%    \end{macrocode}
% If the \option{simple} option has been given, end right here.
%    \begin{macrocode}
\sc@t@a
%    \end{macrocode}
% 
%   \section{Simple}
%
% The above option processing causes the file \file{simple.sto} to be loaded
% when the \option{simple} is given.  After it is loaded, processing stops.
% When the \option{simple} option is not given, \package{newclude} package code
% continues in section~\ref{sec:common}.\\上述选项处理会在给出 \option{simple} 选项时加载文件 \file{simple.sto}。加载完毕后，处理过程停止。当没有给出 \option{simple} 选项时，\package{newclude} 包的代码会在第~\ref{sec:common} 节继续执行。

%
% \input{simple.sto}
%
%   \section{Common\\常见}\label{sec:common}
%
% The code in this section is common to the \option{tag} and \option{allocate}
% options.\\本节中的代码适用于\option{tag}和\option{allocate}选项。

%
% \begin{macro}{\nc@t@a}
% \begin{macro}{\nc@t@b}
% \begin{macro}{\nc@t@c}
% \begin{macro}{\nc@toks@a}
%     Scratch variables.
%    \begin{macrocode}
\ReserveCS\nc@t@a
\ReserveCS\nc@t@b
\ReserveCS\nc@t@c
\newtokens\nc@toks@a
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\IncludeSurround}
% \begin{macro}{\DefaultIncludeSurround}
%   \mbox{}
%    \begin{macrocode}
\newcommand\DefaultIncludeSurround {%
  \par
}
\newlet\IncludeSurround\DefaultIncludeSurround
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\c@IncludeDepth}
%   With nested \cs\include{}s, we need some way for the various ones to
%   distinguish themselves, so we keep track of the nested depth with the
%   |IncludeDepth| counter.\\对于嵌套的\cs\include{}，我们需要一些方式来区分它们，因此我们使用|IncludeDepth|计数器来跟踪嵌套深度。
%    \begin{macrocode}
\newcounter{IncludeDepth} % starts at 0
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\IfAllowed}
% \begin{macro}{\includeonly}
% \begin{macro}{\includeall}
%  I think it's more efficient to define a macro for each included part on the
%  list than it is to search through the list possibly twice for each one.
%  Other opinions on making this whole thing more efficient?\\我认为，为列表中的每个包含部分定义一个宏比为每个部分可能搜索两次列表更有效。对于使整个过程更有效的其他意见呢？


%  
%  We are using the usual \LaTeX{} trick of undefined control sequences
%  comparing equally with \cs\relax.  Empty control sequences are \emph{not}
%  the same.  Should be followed by \meta{true clause} then \meta{false
%  clause}.\\我们使用通常的\LaTeX{}技巧，未定义的控制序列与\cs\relax 相等。空控制序列\emph{不相同}。应该跟随\meta{true clause}，然后是\meta{false clause}。

%    \begin{macrocode}
\newcommand\IfAllowed [1] {%
  \@firstoftwo
}
\newcommand\includeall {%
  \let\includeonly\Gobble
}
\defcommand\includeonly [1] {%
  \@partswtrue
%  \DTypeout{INCLUDEONLY}%
  \edef\@partlist {\zap@space#1 \@empty}%
  \@for\nc@t@a:=\@partlist \do {%
    \InitName*{nc@part@\nc@t@a}%
  }%
  \defcommand\IfAllowed [1] {% args: part-name
    \@ifundefined{nc@part@##1} {%
%        \DTypeout{##1 NOTALLOWED}%
        \let\nc@t@c\@secondoftwo
      }{% ELSE
%      \DTypeout{##1 ALLOWED}%
      \let\nc@t@c\@firstoftwo
    }%
    \nc@t@c
  }%
%  \DTypeout{ENDINCLUDEONLY}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\include}
% \begin{macro}{\include*}
%   This is the principle user command.  The scratch variable \cname{nc@t@b}
%   contains what really surrounds the included file.\\这是主要用户命令。临时变量\cname{nc@t@b} 包含了实际包含文件周围的内容。
%    \begin{macrocode}
\def\include {%
  \@ifstar {%
      \let\nc@t@b\IncludeSurround
      \nc@include
    }{% ELSE
    \let\nc@t@b\clearpage
    \nc@include
  }%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%   \section{Experimental common\\实验共同点}
%
% \begin{macro}{\Disable}
% \begin{macro}{\DisableAll}
% This allows the disabling hacks.
%    \begin{macrocode}
\ReserveCS\DisableAll
\newcommand\Disable [1] {%
  \g@addto@macro\DisableAll{#1}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% We start with considering how to quit inputting a file.  The idea is to make
% the \code{\end{document}} command of the part call \cs\endinput.  But there
% is a hitch that characters on the line after the \code{\end{document}} get
% inserted when you don't want them to.  To beat that limitation, we have to do
% some work.\\我们首先考虑如何停止输入文件。想法是让部分的\code{\end{document}}命令调用\cs\endinput。但是，有一个问题是当你不希望它们出现时，\code{\end{document}}之后一行的字符会被插入。为了克服这个限制，我们需要做一些工作。

%
% \begin{macro}{\nc@radical@shutdown}
% We will add a bunch of commands to this macro, with the idea of \cs\catcode{}ing
% everything and its brother to a comment.   This would be a brute force
% method! \\ 我们将向这个宏添加一堆命令，旨在将所有东西及其相关的内容都设置为注释的\cs\catcode{}。这将是一种蛮力的方法！
%    \begin{macrocode}
\ReserveCS\nc@radical@shutdown
%    \end{macrocode}
% First log a message that we're about to do some crazy things. In case
% something goes wrong, this might help.\\首先，记录一条消息，说明我们即将做一些疯狂的事情。如果出现问题，这可能会有所帮助。

%    \begin{macrocode}
\addto@macro\nc@radical@shutdown {%
  \MonsterInfo{newclude}
    {\protect\nc@radical@shutdown\space beginning}}
%    \end{macrocode}
% Now we start adding \cs\catcode commands.  These first two should be
% redundant; but just in case someone changed things\lips.\\现在我们开始添加\cs\catcode 命令。这前两个命令可能是多余的；但以防万一有人改变了事情\lips。

%    \begin{macrocode}
\addto@macro\nc@radical@shutdown{\catcode`\%=14}    % 14 = comment
\addto@macro\nc@radical@shutdown{\catcode`\^=7}     % 7 = superscript
%    \end{macrocode}
% \begin{macro}{\nc@disable@char}
% Next, we define a command we weill use in a loop in a moment.\\接下来，我们定义一个命令，稍后将在循环中使用。

%    \begin{macrocode}
\newcommand\nc@disable@char[1] {%
  \addto@macro\nc@radical@shutdown
    {\catcode`#1=14}}  % 14 = comment
%    \end{macrocode}
% The following list contains every keyboard char except these three, which are
% treated specially: |%#|.  
% The first is already a comment, and we handle the second in a moment.  Each
% character in the following list is \cs\catcode{}d to a comment:\\以下列表包含除了这三个特殊处理的键盘字符之外的所有字符：|%#|。 第一个已经是注释，我们马上处理第二个。在下面的列表中，每个字符都被\cs\catcode{}d 为注释。

%    \begin{macrocode}
\@tfor\sc@t@a:=abcdefghijklmnopqrstuvwxyz%
                ABCDEFGHIJKLMNOPQRSTUVWXYZ%
                ~!@$&*()_+-=[]|/?.,<>%
                1234567890%
                `'";:%
                \^\\\{\}\ % this is really the chars "^\{}" and space
    \do {\expandafter\nc@disable@char\sc@t@a}
%    \end{macrocode}
% We add |#| separately, because it's tricky or impossible to put it into the
% list we just used.\\我们单独添加 |#|，因为将其放入刚刚使用的列表中很棘手或不可能。

%    \begin{macrocode}
\nc@disable@char\#
%    \end{macrocode}
% \end{macro}
% We end the macro with \cs\endinput.  This has to come after all the previous,
% otherwise, \TeX{} goes ahead and reads to the end of the line immediately,
% with regular catcodes.  This is a good theory, I'm not sure it's necessary.\\我们用\cs\endinput 结束宏。这必须在所有先前的内容之后，否则，\TeX{}会立即读取到行尾，使用常规的类别码。这是一个好理论，但我不确定它是否必要。

%    \begin{macrocode}
\addto@macro\nc@radical@shutdown{\endinput}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\nc@radical@shutdown@aftergroup}
% We need to use \cname{nc@radical@shutdown} this way.\\我们需要这样使用 \cname{nc@radical@shutdown}。

%    \begin{macrocode}
\newcommand\nc@radical@shutdown@aftergroup {%
  \aftergroup\nc@radical@shutdown
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\includedoc}
% \begin{macro}{\includedoc*}
%   \mbox{}
%    \begin{macrocode}
\newcommand\includedoc {%
  \md@check@star
  \Expand \sc@star@nothing\In {%
    \IncludeEnv##1{document}{}%
  }%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\includedocskip}
% \begin{macro}{\includedocskip*}
%   \mbox{}
%    \begin{macrocode}
\newcommand\includedocskip {%
  \md@check@star
  \Expand \sc@star@nothing\In {%
    \IncludeEnvSkip##1{document}{}%
  }%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\IncludeEnv}
% \begin{macro}{\nc@includeenv}
% \begin{macro}{\nc@@includeenv}
%   \mbox{}
%    \begin{macrocode}
\newcommand\IncludeEnv [2] {% args: environment instance
  \md@check@star
  \@ifnextchar [ {%           ^^A for Emacs: ]
      \nc@includeenv{#1}{#2}%
    }{% ELSE
    \nc@includeenv{#1}{#2}[]%
  }%
}
\NewName{nc@includeenv} {#1#2[#3]} {% args: environment instance [prehook]
  \@ifnextchar [ {%      ^^A for Emacs: ]
      \nc@@includeenv {#1}{#2}{#3}%
    }{% ELSE
    \nc@@includeenv {#1}{#2}{#3}[]%
  }%
}
\NewName{nc@@includeenv} {#1#2#3[#4]} {% args: environment instance prehook [posthook]
  \begingroup
    \DisableAll
    \let\documentclass\GobbleOM  
    \let\usepackage\GobbleOM
    \expandafter\def\csname end#1\endcsname {%
      \makeatletter
      % POSTHOOK
      \nc@radical@shutdown@aftergroup
    }%
    \expandafter\def\csname #1\endcsname {} % PREHOOK
  \endgroup
  \par
  \Expand \sc@star@nothing\In {%
    \include##1{#2}%
  }%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
%    \begin{macrocode}
\NewName {nc@@includeenvskip} {#1#2#3[#4]} {% args: environment instance prehook [posthook]
  \begingroup
    \DisableAll
    \expandafter\def\csname end#1\endcsname {%
      \makeatletter
      % POSTHOOK
      \nc@radical@shutdown@aftergroup
    }%
    \expandafter\def\csname #1\endcsname {} % PREHOOK
    \long\def\documentclass ##1\begin{document}{%
      \begingroup
      \def\@currenvir{document}%      
    }
  \endgroup
  \par
  #1%
}
%    \end{macrocode}
%
%   \section{Tag\\标签}
%
% The code in this section is processed when the \option{tag} package option is
% given (or, because the \option{tag} option is the default, when no package
% options are given.)\\当给出\option{tag}包选项时（或者因为\option{tag}选项是默认选项，当没有给出任何包选项时），本节中的代码将被处理。
%
% \input{tag.sto}
%
%   \section{Allocate\\分配}
%
% The code in this section is processed when the \option{allocate} package
% option is given.\\当给出\option{allocate}软件包选项时，本节中的代码将被处理。

%
% \input{allocate.sto}
%
%   \section{Benign packages\\良性软件包}
%
% \begin{macro}{\DeclareFormattingPackage}
% \begin{macro}{\nc@formatting@packages}
%   \mbox{}
%    \begin{macrocode}
\newcommand\DeclareFormattingPackage [1] {%
  \addto@macro\nc@formatting@packages{,#1}%
}
\newcommand\nc@formatting@packages {times,helvetic}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \Finale
