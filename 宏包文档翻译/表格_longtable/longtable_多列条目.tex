
\section{Multicolumn entries\hfill 多列条目}

\columnratio{0.55}
\begin{paracol}{2}

The "\multicolumn" command may be used in \env{longtable} in exactly
the same way as for \env{tabular}. So you may want to skip this
section, which is rather technical, however coping with "\multicolumn"
is one of the main problems for an environment such as
\env{longtable}. The main effect that a user will see is that
certain combinations of "\multicolumn" entries will result in a
document needing more runs of \LaTeX\ before the various `chunks' of
a table align.
\switchcolumn
在\env{longtable}中，"\multicolumn"命令可以与\env{tabular}完全相同的方式使用。因此，您可能希望跳过这一节，因为处理 "\multicolumn" 是 \env{longtable} 等环境的主要问题之一。用户将看到的主要效果是，某些 "\multicolumn" 条目的组合将导致文档需要多次运行\LaTeX，以使表格的各个"块"对齐。

\switchcolumn[0]*
The examples in this section are set with "LTchunksize" set to the
minimum value of one, to demonstrate the effects when "\multicolumn"
entries occur in different chunks.
\switchcolumn
本节中的示例设置"LTchunksize"为最小值1，以演示在不同块中出现"\multicolumn"条目时的效果。

\end{paracol}

\begin{table}[!htp]
\begin{center}
\LTchunksize=1
 \makeatletter

 \global\let\LT@save@row\relax
 \let\LT@warn\@gobble
 \let\LT@final@warn\relax

 \newcommand\ltexample[1]{
 \stepcounter{LT@tables}
 \expandafter\let\csname LT@\romannumeral\c@LT@tables\endcsname
                  \LT@save@row
 \addtocounter{LT@tables}{-1}
 \begin{longtable}{|c|c|c|}
 \caption{A difficult {\cs{multicolumn}} combination:
                               pass #1\label{pass#1}}\\
   \hline
   1&2&3\\
   \multicolumn{3}{|c|}{wide multicolumn spanning 1--3}\\
   \multicolumn{2}{|c|}{multicolumn 1--2}&3\\
   wide 1&2&3\\
   \hline
\end{longtable}
}

\ltexample{1}

\ltexample{2}

\ltexample{3}

\ltexample{4}

\end{center}
\end{table}

\columnratio{0.55}
\begin{paracol}{2}

Consider Table~\ref{pass1}.
In the second chunk, \env{longtable}  sees the wide
multicolumn entry.  At this point it thinks that the first two
columns are very narrow. All
the width of the multicolumn entry is assumed to be in the
third column. (This is a `feature' of \TeX's primitive "\halign"
command.) \env{longtable} then passes the information that there
is a wide third column to the later chunks, with the result that the
first pass over the table is too wide.
\switchcolumn 考虑表格~\ref{pass1}。在第二个块中，\env{longtable}看到宽的跨列条目。此时，它认为前两列非常窄。所有跨列条目的宽度都被假定在第三列中。（这是\TeX 原始的"\halign"命令的一个"特性"）。然后，\env{longtable}将存在宽第三列的信息传递给后续块，导致对表格的第一次遍历过宽。

\switchcolumn[0]*
If the `saved row' from this first pass was re-inserted into the
table on the next pass, the table would line up in two passes, but
would be much two wide.
\switchcolumn 如果在下一次遍历中将这个"保存的行"重新插入到表格中，表格将在两次遍历中排列，但宽度会变得更宽。

\switchcolumn[0]*
\DescribeMacro{\kill}%
The solution to this problem used in Versions 1~and~2, was to use a
"\kill" line. If a line is "\kill"ed, by using "\kill" rather than
"\\" at the end of the line, it is used in calculating
column widths, but removed from the final table. Thus entering
"\kill"ed copies of the last two rows before the wide multicolumn
entry would  mean that "\halign" `saw' the wide entries in the first
two columns, and so would not widen the third column by so much to
make room for the multicolumn entry.
\switchcolumn
在版本1和2中用于解决这个问题的方法是使用"\kill"行。如果一行使用"\kill"而不是"\\"结束，那么它将在计算列宽时使用，但在最终表格中将被删除。因此，在宽的多列输入之前输入"\kill"的最后两行的副本意味着"\halign"看到了前两列中的宽输入，因此不会将第三列扩展得太多以为多列输入腾出空间。

\switchcolumn[0]*
In Version~3, a new solution was introduced. If the saved row in
the ".aux" file was not being used, \env{longtable} used a special
`draft' form of "\multicolumn", this modified the definition, so the
spanning entry was never considered to be wider than the columns it
spanned. So after the first pass, the ".aux" file stored the
widest normal entry for each column, no column was widened due to
"\span"ned columns. By default \env{longtable} ignored the ".aux"
file, and so each run of \LaTeX\ was considered a first pass. Once the
"\setlongtables" declaration was given, the saved row in the ".aux"
file, and the proper definition of "\multicolumn" were used. If any
"\multicolumn" entry caused one of the columns to be widened, this
information could not be passed back to earlier chunks, and so the
table would not correctly line up until the third pass. This algorithm
always converged in three passes as described above, but in examples
such as the ones in Tables \ref{pass1}--\ref{pass4}, the final
widths were not optimal as the width of column~2, which is
determined by a "\multicolumn" entry was not known when the final
width for column~3 was fixed, due to the fact that \emph{both}
"\multicolumn" commands were switched from `draft' mode to `normal'
mode at the same time.
\switchcolumn 在版本3中，引入了一种新的解决方案。如果".aux"文件中保存的行没有被使用，\env{longtable}会使用特殊的"草稿"形式的"\multicolumn"，这会修改定义，使得跨越的条目永远不会被认为比其跨越的列更宽。因此，在第一遍扫描后，".aux"文件存储了每列最宽的普通条目，没有任何一列由于跨越的列而被加宽。默认情况下，\env{longtable}忽略".aux"文件，因此每次运行\LaTeX 都被视为第一遍扫描。一旦给出了"\setlongtables"声明，就会使用".aux"文件中保存的行和正确的"\multicolumn"定义。如果任何一个"\multicolumn"条目导致其中一列加宽，这个信息不能传递回早期的块，因此在第三遍扫描之前，表格不会正确地对齐。如上所述，这个算法总是在三遍扫描中收敛，但在表\ref{pass1}--\ref{pass4}中的示例中，最终宽度不是最优的，因为第2列的宽度是由"\multicolumn"条目确定的，当第3列的最终宽度被固定时，由于\emph{两个}"\multicolumn"命令同时从"草稿"模式切换到"正常"模式，第2列的宽度是未知的。

\switchcolumn[0]*
Version~4 alleviates the problem considerably.
The first pass of the table will
indeed have the third column much too wide. However, on the next pass
\env{longtable} will notice the error and reduce the column width
accordingly. If this has to propagate to chunks before the
"\multicolumn" one, an additional pass will, of course, be
needed. It is possible to construct tables where this rippling up of
the correct widths takes several passes to `converge' and produce a
table with all chunks aligned. However in
order to need many passes one needs to construct a table with
many overlapping "\multicolumn" entries, all being wider than the
natural widths of the columns they span, and all occurring in
different chunks. In the typical case the algorithm will converge
after three or four passes, and, the benefits of not needing to edit
the document before the final run to add "\setlongtables", and the
better choice of final column widths in the case of multiple
"\multicolumn" entries  will hopefully more than pay for the extra
passes that may possibly be needed.
\switchcolumn
版本4大大缓解了这个问题。表的第一遍传递确实会使第三列太宽。然而，在下一次传递中，\env{longtable}将注意到这个错误并相应地缩小列宽。如果这必须传播到"\multicolumn"之前的块中，当然需要额外的传递。可以构建表格，其中正确宽度的这种波动需要几次传递才能"收敛"，并且产生所有块对齐的表格。但是，为了需要多次传递，需要构建一个表格，其中包含许多重叠的"\multicolumn"条目，所有这些条目都比它们跨越的列的自然宽度更宽，并且所有这些条目都出现在不同的块中。在典型情况下，算法将在三到四次传递后收敛，并且不需要在最终运行之前编辑文档以添加"\setlongtables"的好处，以及在多个"\multicolumn"条目的情况下更好的选择最终列宽将有望超过可能需要的额外传递的好处。

\switchcolumn[0]*
So Table~\ref{pass1} converges after 4~passes, as seen in
Table~\ref{pass4}.
\switchcolumn  因此，在第4次迭代之后，表\ref{pass1} 收敛，如表\ref{pass4} 所示。

\switchcolumn[0]*
You can still speed the convergence by introducing judicious "\kill"
lines, if you happen to have constellations like the above.
\switchcolumn 如果您恰好具有像上面那样的星座，您仍然可以通过引入明智的"\kill"行来加速收敛。

\switchcolumn[0]*
If you object even to \LaTeX-ing a file twice, you should
make the first line of
every \env{longtable} a "\kill" line that contains the widest entry
to be used in each column. All chunks will then line up on the first
pass.
\switchcolumn
如果你甚至反对将文件\LaTeX 编译两次，那么你应该在每个\env{longtable}的第一行添加一个包含每列中要使用的最宽条目的"\kill"行。所有的块都会在第一遍排列好。

\end{paracol}