% \iffalse meta-comment
%
%% File: xparse.dtx
%
% Copyright (C) 1999 Frank Mittelbach, Chris Rowley, David Carlisle
%           (C) 2004-2008 Frank Mittelbach, The LaTeX Project
%           (C) 2009-2022 The LaTeX Project
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    https://www.latex-project.org/lppl.txt
%
% This file is part of the "l3packages bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    https://github.com/latex3/latex3
%
% for those people who are interested.
%
%<*driver|package>
% The version of expl3 required is tested as early as possible, as
% some really old versions do not define \ProvidesExplPackage.
\RequirePackage{expl3}[2018-04-12]
%<package>\@ifpackagelater{expl3}{2018-04-12}
%<package>  {}
%<package>  {%
%<package>    \PackageError{xparse}{Support package l3kernel too old}
%<package>      {%
%<package>        Please install an up to date version of l3kernel\MessageBreak
%<package>        using your TeX package manager or from CTAN.\MessageBreak
%<package>        \MessageBreak
%<package>        Loading xparse will abort!%
%<package>      }%
%<package>    \endinput
%<package>  }
%</driver|package>
%<*driver>
\documentclass[full]{l3doc}

\usepackage[heading=true
,scheme=chinese%中文方案
,fontset=none%不使用默认的字体设置
,space=auto%自动调整中英文间距
]{ctex}
\setCJKmainfont{方正书宋_GBK}%方正书宋_GBK.TTF  设置文本的中文有衬线字体为“方正书宋_GBK”
\setCJKsansfont{方正黑体简体}%方正黑体_GBK.TTF  设置文本的中文无衬线字体为“方正黑体简体”
\setCJKmonofont{方正书宋简体}%方正仿宋_GBK.TTF  设置文本的中文等宽字体为“方正书宋简体”

\usepackage{parskip}
\parindent=0pt

\makeatletter
\providecommand*\input@path{}
\newcommand*\addinputpath[1]{\expandafter\def\expandafter\input@path\expandafter{\input@path#1}}
\makeatother

\addinputpath{%
{/Users/virhuiai/hlProjects/Latex-Typesetting-Hub/宏包文档翻译/xparse/}%
}



\usepackage{amstext}
\begin{document}
  \DocInput{xparse-cn.dtx}
\end{document}
%</driver>
% \fi
%
% \providecommand\acro[1]{\textsc{\MakeLowercase{#1}}}
% \newenvironment{arg-description}{%
%   \begin{itemize}\def\makelabel##1{\hss\llap{\bfseries##1}}}{\end{itemize}}
%
% \title{^^A
%   The \textsf{xparse} package\\ Document command parser^^A
% }
%
% \author{^^A
%  The \LaTeX{} Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% \and {\tt virhuiai@qq.com} 翻译
% }
%
% \date{Released 2022-01-12}
%
% \maketitle
%
% \begin{documentation}
%
% The \pkg{xparse} package provides a high-level interface for
% producing document-level commands. In that way, it is intended as
% a replacement for the \LaTeXe{} \cs{newcommand} macro. However,
% \pkg{xparse} works so that the interface to a function (optional
% arguments, stars and mandatory arguments, for example) is separate
% from the internal implementation. \pkg{xparse} provides a normalised
% input for the internal form of a function, independent of the
% document-level argument arrangement.\\\pkg{xparse}包提供了一个高级接口，用于生成文档级命令。因此，它旨在取代\LaTeXe{}的 \cs{newcommand} 宏。然而，\pkg{xparse}的工作方式是将函数的接口（例如可选参数、星号和必选参数）与内部实现分离开来。\pkg{xparse}提供了一个标准化的输入，用于函数的内部形式，独立于文档级参数的安排。

%
% At present, the functions in \pkg{xparse} which are regarded as
% \enquote{stable} are:\\目前，\pkg{xparse} 中的被认为是“稳定”的函数有：
% \begin{itemize}
%   \item \cs{NewDocumentCommand}\\
%     \cs{RenewDocumentCommand}\\
%     \cs{ProvideDocumentCommand}\\
%     \cs{DeclareDocumentCommand}
%   \item \cs{NewDocumentEnvironment}\\
%     \cs{RenewDocumentEnvironment}\\
%     \cs{ProvideDocumentEnvironment}\\
%     \cs{DeclareDocumentEnvironment}
%   \item \cs{NewExpandableDocumentCommand}\\
%     \cs{RenewExpandableDocumentCommand}\\
%     \cs{ProvideExpandableDocumentCommand}\\
%     \cs{DeclareExpandableDocumentCommand}
%   \item \cs{IfNoValue(TF)}
%   \item \cs{IfValue(TF)}
%   \item \cs{IfBoolean(TF)}
% \end{itemize}
% with the other functions currently regarded as \enquote{experimental}. Please
% try all of the commands provided here, but be aware that the
% experimental ones may change or disappear.\\其他功能目前被视为“实验性”。请尝试这里提供的所有命令，但请注意实验性的命令可能会更改或消失。
%
% \section{Specifying arguments\\指定参数}
%
% Before introducing the functions used to create document commands,
% the method for specifying arguments with \pkg{xparse} will be
% illustrated. In order to allow each argument to be defined
% independently, \pkg{xparse} does not simply need to know the
% number of arguments for a function, but also the nature of each
% one. This is done by constructing an \emph{argument specification},
% which defines the number of arguments, the type of each argument
% and any additional information needed for \pkg{xparse} to read the
% user input and properly pass it through to internal functions.\\在介绍用于创建文档命令的函数之前，我们将演示使用\pkg{xparse}指定参数的方法。为了允许每个参数都独立定义，\pkg{xparse}不仅需要知道函数的参数数量，还需要知道每个参数的性质。这是通过构建一个\emph{参数规范}来实现的，它定义了参数的数量，每个参数的类型以及\pkg{xparse}读取用户输入并正确传递到内部函数所需的任何其他信息。
%
% The basic form of the argument specifier is a list of letters, where
% each letter defines a type of argument. As will be described below,
% some of the types need additional information, such as default values.
% The argument types can be divided into two, those which define
% arguments that are mandatory (potentially raising an error if not
% found) and those which define optional arguments. The mandatory types
% are:\\参数说明符的基本形式是一个字母列表，其中每个字母定义一个参数类型。如下所述，一些类型需要额外的信息，例如默认值。参数类型可以分为两类，一类定义必需的参数（如果未找到可能引发错误），另一类定义可选参数。必需的类型包括：
% \begin{itemize}[font=\ttfamily]
%   \item[m] A standard mandatory argument, which can either be a single
%     token alone or multiple tokens surrounded by curly braces |{}|.
%     Regardless of the input, the argument will be passed to the
%     internal code without the outer braces. This is the \pkg{xparse}
%     type specifier for a normal \TeX{} argument.\\标准的必须参数，可以是单个标记或被大括号 |{}| 包围的多个标记。无论输入是什么，参数都将被传递给内部代码，但外部大括号将被去除。这是 \pkg{xparse} 的一种类型指示符，用于普通的 \TeX{} 参数。
%   \item[r] Given as \texttt{r}\meta{token1}\meta{token2}, this denotes a
%     \enquote{required} delimited argument, where the delimiters are
%     \meta{token1} and \meta{token2}. If the opening delimiter
%     \meta{token1} is missing, the default marker |-NoValue-| will be
%     inserted after a suitable error.\\ 给定为 \texttt{r}\meta{token1}\meta{token2}，表示一个“必需”的定界参数，其中定界符是 \meta{token1} 和 \meta{token2}。如果缺少开头的定界符 \meta{token1}，则会在适当的错误后插入默认标记 |-NoValue-|。
%   \item[R] Given as \texttt{R}\meta{token1}\meta{token2}\marg{default},
%     this is a \enquote{required} delimited argument as for~\texttt{r},
%     but it has a user-definable recovery \meta{default} instead of
%     |-NoValue-|.\\给定为 \texttt{R}\meta{token1}\meta{token2}\marg{default}，这是一个“必需”的定界参数，就像 \texttt{r} 一样，但它有一个可由用户定义的恢复 \meta{default}，而不是 |-NoValue-|。 
%   \item[v] Reads an argument \enquote{verbatim}, between the following
%     character and its next occurrence, in a way similar to the argument
%     of the \LaTeXe{} command \cs{verb}. Thus a \texttt{v}-type argument
%     is read between two identical characters, which cannot be any of |%|, |\|,
%     |#|, |{|, |}| or \verb*| |.
%     The verbatim argument can also be enclosed between braces, |{| and |}|.
%     A command with a verbatim
%     argument will produce an error when it appears within an argument of
%     another function.\\ 以“原样输出”的方式读取参数，介于以下字符和其下一次出现之间，类似于 \LaTeXe{} 命令 \cs{verb} 的参数。因此，\texttt{v} 类型的参数在两个相同的字符之间读取，这些字符不能是 |%|、||、|#|、|{|、|}| 或 \verb*| |。原样输出的参数也可以被大括号 |{| 和 |}| 包围。带有原样输出参数的命令将在另一个函数的参数中出现时产生错误。
%   \item[b] Only suitable in the argument specification of an
%     environment, it denotes the body of the environment, between
%     |\begin|\marg{environment} and |\end|\marg{environment}.  See
%     Section~\ref{sec:body} for details.\\仅适用于环境的参数规范，表示环境的主体部分，介于 |\begin|\marg{environment} 和 |\end|\marg{environment} 之间。有关详细信息，请参阅第~\ref{sec:body} 节。
% \end{itemize}
% The types which define optional arguments are:\\定义可选参数的类型有：
% \begin{itemize}[font=\ttfamily]
%   \item[o] A standard \LaTeX{} optional argument, surrounded with square
%     brackets, which will supply
%     the special |-NoValue-| marker if not given (as described later).\\一个标准的 \LaTeX{} 可选参数，用方括号括起来，如果没有给出值，将提供特殊的 |-NoValue-| 标记（稍后会描述）。 
%   \item[d] Given as \texttt{d}\meta{token1}\meta{token2}, an optional
%     argument which is delimited by \meta{token1} and \meta{token2}.
%     As with \texttt{o}, if no
%     value is given the special marker |-NoValue-| is returned.\\给定为 \texttt{d}\meta{token1}\meta{token2}，一个可选参数，由 \meta{token1} 和 \meta{token2} 分隔。与 \texttt{o} 类型一样，如果没有给出值，则返回特殊标记 |-NoValue-|。 
%   \item[O] Given as \texttt{O}\marg{default}, is like \texttt{o}, but
%     returns \meta{default} if no value is given.\\给定为 \texttt{O}\marg{default}，与 \texttt{o} 类似，但如果没有给出值，则返回 \meta{default}。 
%   \item[D] Given as \texttt{D}\meta{token1}\meta{token2}\marg{default},
%     it is as for \texttt{d}, but returns \meta{default} if no value is given.
%     Internally, the \texttt{o}, \texttt{d} and \texttt{O} types are
%     short-cuts to an appropriated-constructed \texttt{D} type argument.\\给定为 \texttt{D}\meta{token1}\meta{token2}\marg{default}，与 \texttt{d} 类型一样，但如果没有给出值，则返回 \meta{default}。在内部，\texttt{o}、\texttt{d} 和 \texttt{O} 类型是一个适当构造的 \texttt{D} 类型参数的快捷方式。 
%   \item[s] An optional star, which will result in a value
%     \cs{BooleanTrue} if a star is present and \cs{BooleanFalse}
%     otherwise (as described later).\\一个可选的星号，如果存在，则结果为 \cs{BooleanTrue}，否则为 \cs{BooleanFalse}（稍后会描述）。 
%   \item[t] An optional \meta{token}, which will result in a value
%     \cs{BooleanTrue} if \meta{token} is present and \cs{BooleanFalse}
%     otherwise. Given as \texttt{t}\meta{token}.\\一个可选的 \meta{token}，如果 \meta{token} 存在，则结果为 \cs{BooleanTrue}，否则为 \cs{BooleanFalse}。给定为 \texttt{t}\meta{token}。 
%   \item[e] Given as \texttt{e}\marg{tokens}, a set of optional
%     \emph{embellishments}, each of which requires a \emph{value}.
%     If an embellishment is not present, |-NoValue-| is returned.  Each
%     embellishment gives one argument, ordered as for the list of
%     \meta{tokens} in the argument specification.  All \meta{tokens}
%     must be distinct.  \emph{This is an experimental type}.\\给定为 \texttt{e}\marg{tokens}，一组可选的\emph{装饰}，每个装饰都需要一个\emph{值}。如果装饰不存在，则返回 |-NoValue-|。每个装饰都给出一个参数，按参数规范中 \meta{tokens} 列表的顺序排列。所有的 \meta{tokens} 必须是不同的。\emph{这是一种实验性类型}。 
%   \item[E] As for \texttt{e} but returns one or more \meta{defaults}
%     if values are not given: \texttt{E}\marg{tokens}\marg{defaults}. See
%     Section~\ref{sec:embellishment} for more details.\\与 \texttt{e} 类似，但如果没有给出值，则返回一个或多个 \meta{defaults}：\texttt{E}\marg{tokens}\marg{defaults}。有关更多详细信息，请参见第~\ref{sec:embellishment} 节。
% \end{itemize}
%
% Using these specifiers, it is possible to create complex input syntax
% very easily. For example, given the argument definition
% `|s o o m O{default}|', the input `|*[Foo]{Bar}|' would be parsed as:\\使用这些标识符，可以非常容易地创建复杂的输入语法。例如，给定参数定义 |s o o m O{default}|，输入 |*[Foo]{Bar}| 将被解析为：
% \begin{itemize}[nolistsep]
%   \item |#1| = |\BooleanTrue|
%   \item |#2| = |Foo|
%   \item |#3| = |-NoValue-|
%   \item |#4| = |Bar|
%   \item |#5| = |default|
% \end{itemize}
% whereas `|[One][Two]{}[Three]|' would be parsed as:\\而 `|[One][Two]{}[Three]|' 将被解析为：
% \begin{itemize}[nolistsep]
%   \item |#1| = |\BooleanFalse|
%   \item |#2| = |One|
%   \item |#3| = |Two|
%   \item |#4| = ||
%   \item |#5| = |Three|
% \end{itemize}
%
% Delimited argument types (\texttt{d}, \texttt{o} and \texttt{r}) are
% defined such that they require matched pairs of delimiters when collecting
% an argument. For example\\定义了分隔的参数类型（\texttt{d}、\texttt{o}和\texttt{r}），它们要求在收集参数时需要匹配的分隔符对。例如：
% \begin{verbatim}
%   \NewDocumentCommand{\foo}{o}{#1}
%   \foo[[content]] % #1 = "[content]"
%   \foo[[]         % Error: missing closing "]"
% \end{verbatim}
% Also note that |{| and |}| cannot be used as delimiters as they are used
% by \TeX{} as grouping tokens. Implicit begin- or end-group tokens (\emph{e.g.},
% |\bgroup| and |\egroup|) are not allowed for delimited argument tipes.
% Arguments to be grabbed inside these tokens
% must be created as either \texttt{m}- or \texttt{g}-type arguments.\\还要注意的是，|{| 和 |}| 不能用作分隔符，因为它们被 \TeX{} 用作分组标记。隐式的起始或结束分组标记（例如，|\bgroup| 和 |\egroup|）不能用于分隔参数类型。要在这些标记内获取的参数必须创建为 \texttt{m}- 或 \texttt{g}-类型参数。
%
% Within delimited arguments, non-balanced or otherwise awkward tokens may
% be included by protecting the entire argument with a brace pair\\在指定的参数范围内，可以通过用花括号保护整个参数来包含非平衡或其他不方便的标记。
% \begin{verbatim}
%   \NewDocumentCommand{\foobar}{o}{#1}
%   \foobar[{[}]         % Allowed as the "[" is 'hidden'
% \end{verbatim}
% These braces will be stripped only if they surround the \emph{entire} content
% of the optional argument\\只有当这些大括号包围整个可选参数的内容时，它们才会被移除。
% \begin{verbatim}
%   \NewDocumentCommand{\foobaz}{o}{#1}
%   \foobaz[{abc}]         % => "abc"
%   \foobaz[ {abc}]         % => " {abc}"
% \end{verbatim}
%
% Two more characters have a special meaning when creating an argument
% specifier. First, \texttt{+} is used to make an argument long (to
% accept paragraph tokens). In contrast to \LaTeXe's \cs{newcommand},
% this applies on an argument-by-argument basis. So modifying the
% example to `|s o o +m O{default}|' means that the mandatory argument
% is now \cs{long}, whereas the optional arguments are not.\\在创建参数说明符时，另外两个字符具有特殊含义。首先，\texttt{+} 用于使参数变长（接受段落标记）。与 \LaTeXe 的 \cs{newcommand} 相比，这是基于逐个参数应用的。因此，将示例修改为“|s o o +m O{default}|”意味着强制性参数现在是 \cs{long}，而可选参数不是。
%
% Secondly, the character \texttt{>} is used to declare so-called
% \enquote{argument processors}, which can be used to modify the contents of an
% argument before it is passed to the macro definition. The use of
% argument processors is a somewhat advanced topic, (or at least a less
% commonly used feature) and is covered in Section~\ref{sec:processors}.\\其次，字符\texttt{>}用于声明所谓的“参数处理器”，它可以用于在将参数传递给宏定义之前修改参数的内容。使用参数处理器是一个相对高级的主题（或者至少是一个不太常用的特性），这个主题在第~\ref{sec:processors}节中有所涉及。
%
% When an optional argument is followed by a mandatory argument with the
% same delimiter, \pkg{xparse} issues a warning because the optional
% argument could not be omitted by the user, thus becoming in effect
% mandatory.  This can apply to \texttt{o}, \texttt{d}, \texttt{O},
% \texttt{D}, \texttt{s}, \texttt{t}, \texttt{e}, and \texttt{E} type
% arguments followed by \texttt{r} or \texttt{R}-type required
% arguments, but also to \texttt{g} or \texttt{G} type arguments
% followed by \texttt{m} type arguments.\\当一个可选参数后面紧跟着一个带有相同分隔符的必选参数时，\pkg{xparse}会发出警告，因为用户不能省略可选参数，实际上变成了必选参数。这适用于\texttt{o}，\texttt{d}，\texttt{O}，\texttt{D}，\texttt{s}，\texttt{t}，\texttt{e}和\texttt{E}类型的参数，后面跟着\texttt{r}或\texttt{R}类型的必选参数，也适用于\texttt{g}或\texttt{G}类型的参数后面跟着\texttt{m}类型的参数。
%
% As \pkg{xparse} is also used to describe interfaces that have appeared
% in the wider \LaTeXe{} eco-system, it also defines additional argument
% types, described in Section~\ref{sec:backwards}: the mandatory types
% \texttt{l} and \texttt{u} and the optional brace group types
% \texttt{g} and \texttt{G}.  Their use is not recommended because it is
% simpler for a user if all packages use a similar syntax.  For the same
% reason, delimited arguments \texttt{r}, \texttt{R}, \texttt{d} and
% \texttt{D} should normally use delimiters that are naturally paired,
% such as |[| and |]| or |(| and |)|, or that are identical, such as |"|
% and~|"|.  A very common syntax is to have one optional argument
% \texttt{o} treated as a key--value list (using for instance
% \pkg{l3keys}) followed by some mandatory arguments~\texttt{m} (or
% \texttt{+m}).\\由于 \pkg{xparse} 也用于描述出现在更广泛的 \LaTeXe{} 生态系统中的接口，它还定义了附加的参数类型，如第\ref{sec:backwards} 节所述：必需类型 \texttt{l} 和 \texttt{u}，以及可选的大括号组类型 \texttt{g} 和 \texttt{G}。这些类型的使用并不建议，因为如果所有的包都使用类似的语法，对用户来说会更简单。出于同样的原因，定界参数 \texttt{r}、\texttt{R}、\texttt{d} 和 \texttt{D} 通常应该使用天然成对的定界符，例如 |[| 和 |]| 或 |(| 和 |)|，或者使用相同的定界符，例如 |"| 和|"|。一个非常常见的语法是有一个可选的参数 \texttt{o}，被视为键值列表（例如使用 \pkg{l3keys}），后面跟着一些必需参数~\texttt{m}（或 \texttt{+m}）。
%
% \subsection{Spacing and optional arguments\\间距和可选参数}
%
% \TeX{} will find the first argument after a function name irrespective
% of any intervening spaces. This is true for both mandatory and
% optional arguments. So |\foo[arg]| and \verb*|\foo   [arg]| are
% equivalent. Spaces are also ignored when collecting arguments up
% to the last mandatory argument to be collected (as it must exist).
% So after\\\TeX{}会在函数名称后找到第一个参数，无论有没有空格。这适用于必需参数和可选参数。因此，|\foo[arg]| 和 \verb*|\foo [arg]| 是等效的。当收集参数时，空格也被忽略，直到收集到最后一个必需参数（因为它必须存在）。因此，在收集到最后一个必需参数之后，以下内容：
% \begin{verbatim}
%   \NewDocumentCommand \foo { m o m } { ... }
% \end{verbatim}
% the user input |\foo{arg1}[arg2]{arg3}| and
% \verb*|\foo{arg1}  [arg2]   {arg3}| will both be parsed in the same
% way.\\用户输入的 |\foo{arg1}[arg2]{arg3}| 和 \verb*|\foo{arg1} [arg2] {arg3}| 将以相同的方式解析。
% 
% The behavior of optional arguments \emph{after} any mandatory arguments is
% selectable. The standard settings will allow spaces here, and thus
% with\\在任何必选参数之后的可选参数的行为是可选择的。标准设置允许在此处使用空格，因此：
% \begin{verbatim}
%   \NewDocumentCommand \foobar { m o } { ... }
% \end{verbatim}
% both |\foobar{arg1}[arg2]| and \verb*|\foobar{arg1} [arg2]| will find an
% optional argument. This can be changed by giving the modified |!| in
% the argument specification:\\|\foobar{arg1}[arg2]| 和 \verb*|\foobar{arg1} [arg2]| 均会寻找可选参数。可以通过在参数规范中添加修改后的 |!| 来改变这种情况：
% \begin{verbatim}
%   \NewDocumentCommand \foobar { m !o } { ... }
% \end{verbatim}
% where \verb*|\foobar{arg1} [arg2]| will not find an optional argument.\\\verb*|\foobar{arg1} [arg2]| 不会找到可选参数。
%
% There is one subtlety here due to the difference in handling by \TeX{}
% of \enquote{control symbols}, where the command name is made up of a single
% character, such as \enquote{\cmd{\\}}. Spaces are not ignored by \TeX{}
% here, and thus it is possible to require an optional argument directly
% follow such a command. The most common example is the use of \cmd{\\} in
% \pkg{amsmath} environments. In \pkg{xparse} terms it has signature\\这里有一个微妙之处，因为\TeX{}处理“控制符号”（即命令名称由单个字符组成，如\enquote{\cmd{\\}}）的方式不同。在这里，\TeX{}不会忽略空格，因此可能需要直接在此类命令后面跟随一个可选参数。最常见的例子是在\pkg{amsmath}环境中使用\cmd{\\}。在\pkg{xparse}术语中，它的签名为：
% \begin{verbatim}
%   \DeclareDocumentCommand \\ { !s !o } { ... }
% \end{verbatim}
%
% \subsection{Required delimited arguments\\必需的定界参数}
%
% The contrast between a delimited (\texttt{D}-type) and \enquote{required
% delimited} (\texttt{R}-type) argument is that an error will be raised if
% the latter is missing. Thus for example\\定界型（\texttt{D} 类型）和“必需的定界”（\texttt{R} 类型）参数之间的区别在于，如果缺少后者，将会引发错误。例如：
% \begin{verbatim}
%   \NewDocumentCommand {\foobaz} {r()m} {}
%   \foobaz{oops}
% \end{verbatim}
% will lead to an error message being issued. The marker |-NoValue-|
% (\texttt{r}-type) or user-specified default (for \texttt{R}-type) will be
% inserted to allow error recovery.\\将导致发出错误消息。标记 |-NoValue-|（\texttt{r}-类型）或用户指定的默认值（对于\texttt{R}-类型）将被插入以允许错误恢复。
%
% \subsection{Verbatim arguments\\抄录参数}
%
% Arguments of type~\texttt{v} are read in verbatim mode, which will
% result in the grabbed argument consisting of tokens of category codes
% $12$~(\enquote{other}) and $13$~(\enquote{active}), except spaces,
% which are given category code $10$~(\enquote{space}). The argument is
% delimited in a similar manner to the \LaTeXe{} \cs{verb} function, or
% by (correctly nested) pairs of braces.\\类型为\texttt{v}的参数以抄录模式读取，因此所得到的参数由类别码为$12$（“其它”）和$13$（“活动”）的记号组成，除空格外，空格则被赋予类别码为$10$（“空格”）。该参数的定界方式与\LaTeXe{}的\cs{verb}函数或正确嵌套的一对大括号类似。
%
% Functions containing verbatim arguments cannot appear in the arguments
% of other functions. The \texttt{v}~argument specifier includes code to check
% this, and will raise an error if the grabbed argument has already been
% tokenized by \TeX{} in an irreversible way.\\包含抄录（verbatim）参数的函数不能出现在其他函数的参数中。 \texttt {v}参数说明符包括用于检查这一点的代码，并且如果抓取的参数已经被\TeX{}不可逆地分解为记号，则会引发错误。
%
% By default, an argument of type~\texttt{v} must be at most one line.
% Prefixing with \texttt{+} allows line breaks within the argument.\\默认情况下，类型为\texttt{v}的参数最多只能有一行。在参数前加上\texttt{+}可以允许在参数内换行。
%
% Users should note that support for verbatim arguments is somewhat
% experimental. Feedback is therefore very welcome on the \texttt{LaTeX-L}
% mailing list.\\用户应该注意，对于逐字逐句的参数支持还处于实验阶段。因此，对于\texttt{LaTeX-L}邮件列表上的反馈非常欢迎。
%
% \subsection{Default values of arguments\\参数的默认值}
% \label{sec:defaultvaluesofarguments}
%
% Uppercase argument types (\texttt{O}, \texttt{D}, \ldots{}) allow to
% specify a default value to be used when the argument is missing; their
% lower-case counterparts use the special marker |-NoValue-|.  The
% default value can be expressed in terms of the value of any other
% arguments by using |#1|, |#2|, and so on.\\大写的参数类型（\texttt{O}，\texttt{D}，等等）允许在参数缺失时指定默认值；它们的小写版本使用特殊标记 |-NoValue-|。默认值可以使用 |#1|、|#2| 等来表示任何其他参数的值。
% \begin{verbatim}
%   \NewDocumentCommand {\conjugate} { m O{#1ed} O{#2} } {(#1,#2,#3)}
%   \conjugate {walk}            % => (walk,walked,walked)
%   \conjugate {find} [found]    % => (find,found,found)
%   \conjugate {do} [did] [done] % => (do,did,done)
% \end{verbatim}
% The default values may refer to arguments that appear later in the
% argument specification.  For instance a command could accept two
% optional arguments, equal by default:\\默认值可能指后面出现在参数规范中的参数。例如，一个命令可以接受两个可选参数，默认情况下相等：
% \begin{verbatim}
%   \NewDocumentCommand {\margins} { O{#3} m O{#1} m } {(#1,#2,#3,#4)}
%   \margins {a} {b}              % => {(-NoValue-,a,-NoValue-,b)}
%   \margins [1cm] {a} {b}        % => {(1cm,a,1cm,b)}
%   \margins {a} [1cm] {b}        % => {(1cm,a,1cm,b)}
%   \margins [1cm] {a} [2cm] {b}  % => {(1cm,a,2cm,b)}
% \end{verbatim}
%
% Users should note that support for default arguments referring to
% other arguments is somewhat experimental. Feedback is therefore very
% welcome on the \texttt{LaTeX-L} mailing list.\\用户应注意，默认参数引用其他参数的支持有些实验性质。因此，非常欢迎在\texttt{LaTeX-L}邮件列表上提供反馈意见。 
%
% \subsection{Default values for \enquote{embellishments}\\关于“装饰”的默认值}
% \label{sec:embellishment}
%
% The \texttt{E}-type argument allows one default value per test token.
% This is achieved by giving a list of defaults for each entry in the
% list, for example:\\\texttt{E}类型参数允许每个测试令牌设置一个默认值。这可以通过为列表中的每个条目提供默认值列表来实现，例如：
% \begin{verbatim}
%   E{^_}{{UP}{DOWN}}
% \end{verbatim}
% If the list of default values is \emph{shorter} than the list of test tokens,
% the special |-NoValue-| marker will be returned (as for the \texttt{e}-type
% argument). Thus for example\\如果默认值列表比测试标记列表\emph{更短}，则将返回特殊的|-NoValue-|标记（就像\texttt{e}-类型参数一样）。例如：
% \begin{verbatim}
%   E{^_}{{UP}}
% \end{verbatim}
% has default \texttt{UP} for the |^| test character, but will return the
% |-NoValue-| marker as a default for |_|. This allows mixing of explicit
% defaults with testing for missing values.\\对于测试字符 |^|，默认为 \texttt{UP}，但对于 |_|，默认将返回 |-NoValue-| 标记。这使得可以将显式默认值与测试缺失值混合使用。
%
% \subsection{Body of an environment\\环境的主体}
% \label{sec:body}
%
% While environments |\begin|\marg{environment} \dots{}
%   |\end|\marg{environment} are typically used in cases where the code
% implementing the \meta{environment} does not need to access the
% contents of the environment (its \enquote{body}), it is sometimes
% useful to have the body as a standard argument.\\尽管在实现\meta{环境}时通常不需要访问环境的内容（即其\enquote{主体}），但在某些情况下，将主体作为标准参数是有用的。环境|\begin|\marg{environment} \dots{} |\end|\marg{environment}通常用于这种情况。
%
% This is achieved in \pkg{xparse} by ending the argument specification
% with~\texttt{b}. The approach taken in \pkg{xparse} is
% different from the earlier packages \pkg{environ} or \pkg{newenviron}:
% the body of the environment is provided to the code part as a usual
% argument |#1|, |#2| etc.\@, rather than stored in a macro such as
% \cs[no-index]{BODY}.\\在\pkg{xparse}中，通过在参数规范的末尾添加~\texttt{b}，实现了这一点。 \pkg{xparse}采取的方法不同于早期的包\pkg{environ}或\pkg{newenviron}：环境的主体作为常规参数|＃1|，|＃2|等提供给代码部分，而不是存储在诸如\cs[no-index]{BODY}之类的宏中。
%
% For instance\\例如
% \begin{verbatim}
%   \NewDocumentEnvironment { twice }
%     { O{\ttfamily} +b }
%     {#2#1#2} {}
%   \begin{twice}[\itshape]
%     Hello world!
%   \end{twice}
% \end{verbatim}
% typesets \enquote{Hello world!{\itshape Hello world!}}.
%
% The prefix |+| is used to allow multiple paragraphs in the
% environment's body.  Argument processors can also be applied to
% \texttt{b}~arguments.\\前缀|+|用于在环境主体中允许多个段落。也可以将参数处理器应用于\texttt{b}参数。
%
% By default, spaces are trimmed at both ends of the body: in the
% example there would otherwise be spaces coming from the ends the lines
% after |[\itshape]| and |world!|.  Putting the prefix |!| before
% \texttt{b} suppresses space-trimming.\\默认情况下，正文两端的空格会被删除：例如，在 |[\itshape]| 和 |world!| 之后的行末会有空格。在 \texttt{b} 前加上前缀 |!| 可以抑制空格修剪。
%
% When \texttt{b} is used in the argument specification,
% the last argument of \cs{NewDocumentEnvironment}, which consists of
% an \meta{end code} to insert at |\end|\marg{environment}, is
% redundant since one can simply put that code at the end of the
% \meta{start code}.  Nevertheless this (empty) \meta{end code} must be
% provided.\\当在参数规范中使用\texttt{b}时，\cs{NewDocumentEnvironment} 的最后一个参数，包括在|\end|\marg{environment}处插入的\meta{end code}是多余的，因为可以直接将该代码放在\meta{start code}的末尾。然而，必须提供这个(空的)\meta{end code}。
%
% Environments that use this feature can be nested.\\使用此功能的环境可以嵌套。
%
% Users should note that this feature is somewhat experimental. Feedback
% is therefore very welcome on the \texttt{LaTeX-L} mailing list.\\用户应注意，此功能有些实验性质。因此，在 \texttt{LaTeX-L} 邮件列表上非常欢迎反馈。
%
% \subsection{Starred environments\\带星号的环境}
%
% Many packages define environments with and without \texttt{*} in their
% name, for instance \texttt{tabular} and \texttt{tabular*}.  At
% present, \pkg{xparse} does not provide specific tools to define these:
% one should simply define the two environment separately, for instance\\许多包在其名称中定义了带有和不带有 \texttt{} 的环境，例如 \texttt{tabular} 和 \texttt{tabular*}。目前，\pkg{xparse} 没有提供定义这些环境的特定工具：应该分别定义这两个环境，例如

% \begin{verbatim}
% \NewDocumentEnvironment { tabular } { o +m } {...} {...}
% \NewDocumentEnvironment { tabular* } { m o +m } {...} {...}
% \end{verbatim}
% Of course the implementation of these two environments, denoted
% \enquote{\texttt{...}} in this example, can rely on the same internal
% commands.\\当然，在这个例子中标记为“\texttt{...}”的这两个环境的实现可以依赖于相同的内部命令。
%
% Note that this situation is different from the \texttt{s} argument
% type: if the signature of an environment starts with~\texttt{s} then
% the star is searched for after the argument of \cs{begin}.  For
% instance, the following typesets \texttt{star}.\\请注意，这种情况与 \texttt{s} 参数类型不同：如果一个环境的签名以 \texttt{s} 开头，则星号会在 \cs{begin} 的参数之后搜索。例如，以下代码将排版出 \texttt{star}。
% \begin{verbatim}
% \NewDocumentEnvironment { envstar } { s }
%   {\IfBooleanTF {#1} {star} {no star}} {}
% \begin{envstar}*
% \end{envstar}
% \end{verbatim}
%
% \subsection{Backwards Compatibility\\向后兼容性}
% \label{sec:backwards}
%
% One role of \pkg{xparse} is to describe existing \LaTeX{} interfaces,
% including some that are rather unusual in \LaTeX{} (as opposed to
% formats such as plain \TeX{}) such as delimited arguments.  As such,
% the package defines some argument specifiers that should largely be
% avoided nowadays as using them in packages leads to inconsistent user
% interfaces.  The simplest syntax is often best, with argument
% specifications such as |mmmm| or |ommmm|, namely an optional argument
% followed by some standard mandatory ones.  The optional argument can
% be made to support key--value syntax using tools from \pkg{l3keys}.\\\pkg{xparse} 的一个作用是描述现有的 \LaTeX{} 接口，包括一些在 \LaTeX{} 中非常不寻常的接口（与 plain \TeX{} 等格式不同），例如定界参数。因此，该包定义了一些应该尽量避免在包中使用的参数说明符，因为使用它们会导致不一致的用户界面。最简单的语法通常是最好的，使用参数说明符例如 |mmmm| 或 |ommmm|，即一个可选参数后面跟一些标准的必选参数。可选参数可以使用 \pkg{l3keys} 中的工具支持键值语法。
%
% The argument types that are not recommended any longer are:\\不再推荐使用的参数类型包括：
% \begin{itemize}[font=\ttfamily]
%   \item[l] A mandatory argument which reads everything up to the first
%     begin-group token: in standard \LaTeX{} this is a left brace.\\必选参数，读取直到遇到第一个组开始标记的所有内容：在标准 \LaTeX{} 中，这是左大括号。 
%   \item[u] Reads a mandatory argument \enquote{until} \meta{tokens} are encountered,
%     where the desired \meta{tokens} are given as an argument to the
%     specifier: \texttt{u}\marg{tokens}.\\读取必选参数，直到遇到 \meta{tokens} 为止，所需的 \meta{tokens} 作为参数传递给该说明符：\texttt{u}\marg{tokens}。 
%   \item[g] An optional argument given inside a pair of \TeX{} group
%     tokens (in standard \LaTeX{}, |{| \ldots |}|), which returns
%     |-NoValue-| if not present.\\可选参数，给定在一对 \TeX{} 组标记内（在标准 \LaTeX{} 中为 |{| \ldots |}|），如果不存在则返回 |-NoValue-|。
%   \item[G] As for \texttt{g} but returns \meta{default} if no value
%     is given: \texttt{G}\marg{default}.\texttt{G}\marg{default}。 \\与 \texttt{g} 相同，但如果没有给定值，则返回 \meta{default}：
% \end{itemize}
%
% \subsection{Details about argument delimiters\\关于参数分界符的详细信息}
%
% In normal (non-expandable) commands, the delimited types look for the
% initial delimiter by peeking ahead (using \pkg{expl3}'s |\peek_...|
% functions) looking for the delimiter token.  The token has to have the
% same meaning and \enquote{shape} of the token defined as delimiter.
% There are three possible cases of delimiters: character tokens, control
% sequence tokens, and active character tokens.  For all practical purposes
% of this description, active character tokens will behave exactly as
% control sequence tokens.\\在普通（不可展开的）命令中，分界符类型通过向前查看（使用\pkg{expl3}的|\peek_...|函数）寻找初始分界符，查找分界符令牌。该令牌必须具有与定义为分界符的令牌相同的含义和“形状”。分界符有三种可能的情况：字符令牌、控制序列令牌和活动字符令牌。在本描述的实际目的上，活动字符令牌将完全像控制序列令牌一样行事。
%
% \subsubsection{Character tokens\\字符记号}
%
% A character token is characterised by its character code, and its meaning
% is the category code~(|\catcode|).  When a command is defined, the meaning
% of the character token is fixed into the definition of the command and
% cannot change.  A command will correctly see an argument delimiter if
% the open delimiter has the same character and category codes as at the
% time of the definition.  For example in:\\字符记号由其字符代码和类别码(|\catcode|)来确定其含义。当定义一个命令时， 字符记号的含义将被固定在命令的定义中，不能改变。如果开放式分隔符与定义时 相同的字符和类别码匹配，那么命令将正确地看到一个参数分隔符。例如：
% \begin{verbatim}
%   \NewDocumentCommand { \foobar } { D<>{default} } {(#1)}
%   \foobar <hello> \par
%   \char_set_catcode_letter:N <
%   \foobar <hello>
% \end{verbatim}
% the output would be:
% \begin{verbatim}
%   (hello)
%   (default)<hello>
% \end{verbatim}
% as the open-delimter |<| changed in meaning between the two calls to
% |\foobar|, so the second one doesn't see the |<| as a valid delimiter.
% Commands assume that if a valid open-delimiter was found, a matching
% close-delimiter will also be there.  If it is not (either by being
% omitted or by changing in meaning), a low-level \TeX{} error is raised
% and the command call is aborted.\\由于两个对 |\foobar| 的调用之间打开分隔符 |<| 的含义改变了，因此第二个调用不会将 |<| 视为有效的分隔符。命令假定如果找到了有效的开分隔符，相应的闭分隔符也将存在。如果没有（因为被省略或含义改变了），就会引发低级 \TeX{} 错误并中止命令调用。
%
% \subsubsection{Control sequence tokens\\控制序列标记}
%
% A control sequence (or control character) token is characterised by is
% its name, and its meaning is its definition.
% A token cannot have two different meanings at the same time.
% When a control sequence is defined as delimiter in a command,
% it will be detected as delimiter whenever the control sequence name
% is found in the document regardless of its current definition.
% For example in:\\控制序列（或控制字符）标记以其名称为特征，其含义为其定义。一个标记不能同时具有两个不同的含义。当控制序列被定义为命令中的分隔符时，无论当前定义如何，只要在文档中找到了控制序列名称，它就会被检测为分隔符。例如，在：
% \begin{verbatim}
%   \cs_set:Npn \x { abc }
%   \NewDocumentCommand { \foobar } { D\x\y{default} } {(#1)}
%   \foobar \x hello\y \par
%   \cs_set:Npn \x { def }
%   \foobar \x hello\y
% \end{verbatim}
% the output would be:\\中，输出将是：
% \begin{verbatim}
%   (hello)
%   (hello)
% \end{verbatim}
% with both calls to the command seeing the delimiter |\x|.\\两次调用命令都看到了分隔符 |\x|。
%
% \section{Declaring commands and environments\\声明命令和环境}
%
% With the concept of an argument specifier defined, it is now
% possible to describe the methods available for creating both
% functions and environments using \pkg{xparse}.\\有了参数规范的概念，现在可以描述使用 \pkg{xparse} 创建函数和环境的方法。
%
% The interface-building commands are the preferred method for
% creating document-level functions in \LaTeX3. All of the functions
% generated in this way are naturally robust (using the \eTeX{}
% \cs{protected} mechanism).\\在 \LaTeX3 中，界面构建命令是创建文档级函数的首选方法。所有以这种方式生成的函数都是天然的健壮（使用 \eTeX{} 的 \cs{protected} 机制）。
%
% \begin{function}
%   {
%     \NewDocumentCommand     ,
%     \RenewDocumentCommand   ,
%     \ProvideDocumentCommand ,
%     \DeclareDocumentCommand
%   }
%   \begin{syntax}
%     \cs{NewDocumentCommand} \meta{function} \Arg{arg spec} \Arg{code}
%   \end{syntax}
%   This family of commands are used to create a document-level
%   \meta{function}. The argument specification for the function is
%   given by \meta{arg spec}, and the function expands to the
%   \meta{code} with |#1|, |#2|, etc.\ replaced by the arguments found
%   by \pkg{xparse}.\\这一系列命令用于创建文档级 \meta{function}。函数的参数规范由 \meta{arg spec} 给出，函数展开为 \pkg{xparse} 找到的参数替换 |#1|、|#2| 等等的 \meta{code}。
% \end{function}
%
%   As an example:\\例如：
%   \begin{verbatim}
%     \NewDocumentCommand \chapter { s o m }
%       {
%         \IfBooleanTF {#1}
%           { \typesetstarchapter {#3} }
%           { \typesetnormalchapter {#2} {#3} }
%       }
%   \end{verbatim}
%   would be a way to define a \cs{chapter} command which would
%   essentially behave like the current \LaTeXe{} command (except that it
%   would accept an optional argument even when a \texttt{*} was parsed).
%   The \cs{typesetnormalchapter} could test its first argument for being
%   |-NoValue-| to see if an optional argument was present.\\这是一种定义 \cs{chapter} 命令的方式，它基本上表现得像当前的 \LaTeXe{} 命令（除了即使解析了 \texttt{*}，它也会接受可选参数）。\cs{typesetnormalchapter} 可以测试其第一个参数是否为 |-NoValue-|，以查看可选参数是否存在。
%
%   The difference between the \cs{New\ldots} \cs{Renew\ldots},
%   \cs{Provide\ldots} and \cs{Declare\ldots} versions is the behaviour
%   if \meta{function} is already defined.\\\cs{New\ldots}、\cs{Renew\ldots}、\cs{Provide\ldots} 和 \cs{Declare\ldots} 版本之间的区别是如果已经定义了 \meta{function}，它们的行为不同。
%   \begin{itemize}
%    \item \cs{NewDocumentCommand} will issue an error if \meta{function}
%      has already been defined.\\如果已经定义了 \meta{function}，\cs{NewDocumentCommand} 将发出错误。 
%    \item \cs{RenewDocumentCommand} will issue an error if \meta{function}
%      has not previously been defined.\\如果之前未定义 \meta{function}，\cs{RenewDocumentCommand} 将发出错误。
%    \item \cs{ProvideDocumentCommand} creates a new definition for
%      \meta{function} only if one has not already been given.\\仅当没有给出定义时，\cs{ProvideDocumentCommand} 才创建一个新的 \meta{function} 定义。 
%     \item \cs{DeclareDocumentCommand} will always create the new
%       definition, irrespective of any existing \meta{function} with the
%       same name.  This should be used sparingly.\\\cs{DeclareDocumentCommand} 总是创建新的定义，而不管同名的现有 \meta{function}。这应该谨慎使用。
%   \end{itemize}
%
%   \begin{texnote}
%      Unlike \LaTeXe{}'s \cs{newcommand} and relatives, the
%      \cs{NewDocumentCommand} family of functions do not prevent creation of
%      functions with names starting \cs{end\ldots}.\\与 \LaTeXe{} 的 \cs{newcommand} 等不同，\cs{NewDocumentCommand} 函数族不会阻止创建以 \cs{end\ldots} 开头的函数。
%   \end{texnote}
%
% \begin{function}
%   {
%     \NewDocumentEnvironment     ,
%     \RenewDocumentEnvironment   ,
%     \ProvideDocumentEnvironment ,
%     \DeclareDocumentEnvironment
%   }
%   \begin{syntax}
%     \cs{NewDocumentEnvironment} \Arg{environment} \Arg{arg spec}
%     ~~\Arg{start code} \Arg{end code}
%   \end{syntax}
%   These commands work in the same way as \cs{NewDocumentCommand},
%   etc.\@, but create environments (\cs{begin}\Arg{environment} \ldots{}
%   \cs{end}\Arg{environment}). Both the \meta{start code} and
%   \meta{end code}
%   may access the arguments as defined by \meta{arg spec}.
%   The arguments will be given following \cs{begin}\Arg{environment}.\\这些命令与 \cs{NewDocumentCommand} 等的工作方式相同，但创建环境（\cs{begin}\Arg{environment} \ldots{} \cs{end}\Arg{environment}）。\meta{start code} 和 \meta{end code} 都可以访问按 \meta{arg spec} 定义的参数。这些参数将在 \cs{begin}\Arg{environment} 之后给出。
% \end{function}
%
% \section{Other \pkg{xparse} commands\\\pkg{xparse} 的其他命令}
%
% \subsection{Testing special values\\测试特殊值}
%
% Optional arguments created using \pkg{xparse} make use of dedicated
% variables to return information about the nature of the argument
% received.\\使用 \pkg{xparse} 创建的可选参数使用专用变量返回有关接收到的参数的信息。
%
% \begin{function}[EXP]{\IfNoValueT, \IfNoValueF, \IfNoValueTF}
%   \begin{syntax}
%     \cs{IfNoValueTF} \Arg{argument} \Arg{true code} \Arg{false code}
%     \cs{IfNoValueT} \Arg{argument} \Arg{true code}
%     \cs{IfNoValueF} \Arg{argument} \Arg{false code}
%   \end{syntax}
%   The \cs{IfNoValue(TF)} tests are used to check if \meta{argument} (|#1|,
%   |#2|, \emph{etc.}) is the special |-NoValue-| marker For example
%   \begin{verbatim}
%     \NewDocumentCommand \foo { o m }
%       {
%         \IfNoValueTF {#1}
%           { \DoSomethingJustWithMandatoryArgument {#2} }
%           {  \DoSomethingWithBothArguments {#1} {#2}   }
%       }
%   \end{verbatim}
%   will use a different internal function if the optional argument
%   is given than if it is not present.
%
%   Note that three tests are available, depending on which outcome
%   branches are required: \cs{IfNoValueTF}, \cs{IfNoValueT} and
%   \cs{IfNoValueF}.
%
%   As the \cs{IfNoValue(TF)} tests are expandable, it is possible to
%   test these values later, for example at the point of typesetting or
%   in an expansion context.
%
%   It is important to note that |-NoValue-| is constructed such that it
%   will \emph{not} match the simple text input |-NoValue-|, \emph{i.e.}
%   that
%   \begin{verbatim}
%     \IfNoValueTF{-NoValue-}
%   \end{verbatim}
%   will be logically \texttt{false}.
%
%   When two optional arguments follow each other (a syntax we typically
%   discourage), it can make sense to allow users of the command to
%   specify only the second argument by providing an empty first
%   argument.  Rather than testing separately for emptyness and for
%   |-NoValue-| it is then best to use the argument type~|O| with an
%   empty default value, and simply test for emptyness using the
%   \pkg{expl3} conditional \cs{tl_if_blank:nTF} or its \pkg{etoolbox}
%   analogue \tn{ifblank}.
% \end{function}
%
% \begin{function}[EXP]{\IfValueT, \IfValueF, \IfValueTF}
%   \begin{syntax}
%     \cs{IfValueTF} \Arg{argument} \Arg{true code} \Arg{false code}
%    \end{syntax}
%   The reverse form of the \cs{IfNoValue(TF)} tests are also available
%   as \cs{IfValue(TF)}. The context will determine which logical
%   form makes the most sense for a given code scenario.
% \end{function}
%
% \begin{variable}{\BooleanFalse, \BooleanTrue}
%   The \texttt{true} and \texttt{false} flags set when searching for
%   an optional character (using \texttt{s} or \texttt{t\meta{char}}) have
%   names which are accessible outside of code blocks.
% \end{variable}
%
% \begin{function}[EXP]{\IfBooleanT, \IfBooleanF, \IfBooleanTF}
%   \begin{syntax}
%     \cs{IfBooleanTF} \Arg{argument} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Used to test if \meta{argument} (|#1|, |#2|, \emph{etc.}) is
%   \cs{BooleanTrue} or \cs{BooleanFalse}. For example
%   \begin{verbatim}
%     \NewDocumentCommand \foo { s m }
%       {
%         \IfBooleanTF {#1}
%           { \DoSomethingWithStar {#2} }
%           { \DoSomethingWithoutStar {#2} }
%       }
%   \end{verbatim}
%   checks for a star as the first argument, then chooses the action to
%   take based on this information.
% \end{function}
%
% \subsection{Argument processors}
% \label{sec:processors}
%
% \pkg{xparse} introduces the idea of an argument processor, which is
% applied to an argument \emph{after} it has been grabbed by the
% underlying system but before it is passed to \meta{code}. An argument
% processor can therefore be used to regularise input at an early stage,
% allowing the internal functions to be completely independent of input
% form. Processors are applied to user input and to default values for
% optional arguments, but \emph{not} to the special |-NoValue-| marker.
%
% Each argument processor is specified by the syntax
% \texttt{>}\marg{processor} in the argument specification. Processors
% are applied from right to left, so that
% \begin{verbatim}
%   >{\ProcessorB} >{\ProcessorA} m
% \end{verbatim}
% would apply \cs{ProcessorA}
% followed by \cs{ProcessorB} to the tokens grabbed by the \texttt{m}
% argument.
%
% It might sometimes be useful to use the value of another argument as
% one of the arguments of a processor.  For example, using the
% \cs{SplitList} processor defined below,
% \begin{verbatim}
%   \NewDocumentCommand \foo { O{,} >{\SplitList{#1}} m } { \foobar{#2} }
%   \foo{a,b;c,d}
% \end{verbatim}
% results in |\foobar| receiving the argument |{a}{b;c}{d}| because
% \cs{SplitList} receives as its two arguments the optional one (whose
% value here is the default, a comma) and the mandatory one.  To
% summarize, first the arguments are searched for in the input, then any
% default argument is determined as explained in
% Section~\ref{sec:defaultvaluesofarguments}, then these default
% arguments are passed to any processor.  When referring to arguments
% (through |#1|, |#2| and so on) in a processor, the arguments used are
% always those before applying any processor.
%
% \begin{variable}{\ProcessedArgument}
%   \pkg{xparse} defines a very small set of processor functions. In the
%   main, it is anticipated that code writers will want to create their
%   own processors. These need to accept one argument, which is the
%   tokens as grabbed (or as returned by a previous processor function).
%   Processor functions should return the processed argument as the
%   variable \cs{ProcessedArgument}.
% \end{variable}
%
% \begin{function}{\ReverseBoolean}
%   \begin{syntax}
%     \cs{ReverseBoolean}
%   \end{syntax}
%   This processor reverses the logic of \cs{BooleanTrue} and
%   \cs{BooleanFalse}, so that the example from earlier would become
%   \begin{verbatim}
%     \NewDocumentCommand \foo { > { \ReverseBoolean } s m }
%       {
%         \IfBooleanTF #1
%           { \DoSomethingWithoutStar {#2} }
%           { \DoSomethingWithStar {#2} }
%       }
%   \end{verbatim}
% \end{function}
%
% \begin{function}[updated = 2012-02-12]{\SplitArgument}
%   \begin{syntax}
%     \cs{SplitArgument} \Arg{number} \Arg{token(s)}
%   \end{syntax}
%   This processor splits the argument given at each occurrence of the
%   \meta{tokens} up to a maximum of \meta{number} tokens (thus
%   dividing the input into $\text{\meta{number}} + 1$ parts).
%   An error is given if too many \meta{tokens} are present in the
%   input. The processed input is placed inside
%   $\text{\meta{number}} + 1$ sets of braces for further use.
%   If there are fewer than \Arg{number} of \Arg{tokens} in the argument
%   then |-NoValue-| markers are added at the end of the processed
%   argument.
%   \begin{verbatim}
%     \NewDocumentCommand \foo
%       { > { \SplitArgument { 2 } { ; } } m }
%       { \InternalFunctionOfThreeArguments #1 }
%   \end{verbatim}
%   If only a single character \meta{token} is used for the split, any
%   category code $13$ (active) character matching the \meta{token} will
%   be replaced before the split takes place.
%   Spaces are trimmed at each end of each item parsed.
% \end{function}
%
% \begin{function}{\SplitList}
%   \begin{syntax}
%     \cs{SplitList} \Arg{token(s)}
%   \end{syntax}
%   This processor splits the argument given at each occurrence of the
%   \meta{token(s)} where the number of items is not fixed. Each item is
%   then wrapped in braces within |#1|. The result is that the
%   processed argument can be further processed using a mapping function.
%   \begin{verbatim}
%     \NewDocumentCommand \foo
%       { > { \SplitList { ; } } m }
%       { \MappingFunction #1 }
%   \end{verbatim}
%   If only a single character \meta{token} is used for the split, any
%   category code $13$ (active) character matching the \meta{token} will
%   be replaced before the split takes place.
%   Spaces are trimmed at each end of each item parsed.
% \end{function}
%
% \begin{function}[EXP]{\ProcessList}
%   \begin{syntax}
%     \cs{ProcessList} \Arg{list} \Arg{function}
%   \end{syntax}
%   To support \cs{SplitList}, the function \cs{ProcessList} is available
%   to apply a \meta{function} to every entry in a \meta{list}. The
%   \meta{function} should absorb one argument: the list entry. For example
%   \begin{verbatim}
%     \NewDocumentCommand \foo
%       { > { \SplitList { ; } } m }
%       { \ProcessList {#1} { \SomeDocumentFunction } }
%   \end{verbatim}
%
%   \textbf{This function is experimental.}
% \end{function}
%
% \begin{function}{\TrimSpaces}
%   \begin{syntax}
%     \cs{TrimSpaces}
%   \end{syntax}
%   Removes any leading and trailing spaces (tokens with character code~$32$
%   and category code~$10$) for the ends of the argument. Thus for example
%   declaring a function
%   \begin{verbatim}
%     \NewDocumentCommand \foo
%       { > { \TrimSpaces } m }
%       { \showtokens {#1} }
%   \end{verbatim}
%   and using it in a document as
%   \begin{verbatim}
%     \foo{ hello world }
%   \end{verbatim}
%   will show \texttt{hello world} at the terminal, with the space at each
%   end removed. \cs{TrimSpaces} will remove multiple spaces from the ends of
%   the input in cases where these have been included such that the standard
%   \TeX{} conversion of multiple spaces to a single space does not apply.
%
%   \textbf{This function is experimental.}
% \end{function}
%
% \subsection{Fully-expandable document commands}
%
% There are \emph{very rare} occasion when it may be useful to create
% functions using a fully-expandable argument grabber. To support this,
% \pkg{xparse} can create expandable functions as well as the usual
% robust ones. This imposes a number of restrictions on the nature of
% the arguments accepted by a function, and the code it implements.
% This facility should only be used when \emph{absolutely necessary};
% if you do not understand when this might be, \emph{do not use these
% functions}!
%
% \begin{function}
%   {
%     \NewExpandableDocumentCommand     ,
%     \RenewExpandableDocumentCommand   ,
%     \ProvideExpandableDocumentCommand ,
%     \DeclareExpandableDocumentCommand
%   }
%   \begin{syntax}
%     \cs{NewExpandableDocumentCommand}
%     ~~~~\meta{function} \Arg{arg spec} \Arg{code}
%   \end{syntax}
%   This family of commands is used to create a document-level \meta{function},
%   which will grab its arguments in a fully-expandable manner. The
%   argument specification for the function is given by \meta{arg spec},
%   and the function will execute \meta{code}. In  general, \meta{code} will
%   also be fully expandable, although it is possible that this will
%   not be the case (for example, a function for use in a table might
%   expand so that \cs{omit} is the first non-expandable non-space token).
%
%   Parsing arguments expandably imposes a number of restrictions on
%   both the type of arguments that can be read and the error checking
%   available:
%   \begin{itemize}
%     \item The last argument (if any are present) must be one of the
%       mandatory types \texttt{m}, \texttt{r}, \texttt{R}, \texttt{l}
%       or~\texttt{u}.
%     \item All short arguments appear before long arguments.
%     \item The mandatory argument types \texttt{l} and \texttt{u} may
%       not be used after optional arguments.
%     \item The optional argument types \texttt{g}
%       and \texttt{G} are not available.
%     \item The \enquote{verbatim} argument type \texttt{v} is not available.
%     \item Argument processors (using \texttt{>}) are not available.
%     \item It is not possible to differentiate between, for example
%       |\foo[| and |\foo{[}|: in both cases the \texttt{[} will be
%       interpreted as the start of an optional argument. As a
%       result, checking for optional arguments is less robust than
%       in the standard version.
%   \end{itemize}
%   \pkg{xparse} will issue an error if an argument specifier is given
%   which does not conform to the first six requirements. The last
%   item is an issue when the function is used, and so is beyond the
%   scope of \pkg{xparse} itself.
% \end{function}
%
% \subsection{Access to the argument specification}
%
% The argument specifications for document commands and environments are
% available for examination and use.
%
% \begin{function}{\GetDocumentCommandArgSpec, \GetDocumentEnvironmentArgSpec}
%   \begin{syntax}
%     \cs{GetDocumentCommandArgSpec} \meta{function}
%     \cs{GetDocumentEnvironmentArgSpec} \Arg{environment}
%   \end{syntax}
%   These functions transfer the current argument specification for the
%   requested \meta{function} or \meta{environment} into the token list
%   variable \cs{ArgumentSpecification}. If the \meta{function} or
%   \meta{environment} has no known argument specification then an error
%   is issued. The assignment to \cs{ArgumentSpecification} is local to
%   the current \TeX{} group.
% \end{function}
%
% \begin{function}
%   {\ShowDocumentCommandArgSpec,  \ShowDocumentEnvironmentArgSpec}
%   \begin{syntax}
%     \cs{ShowDocumentCommandArgSpec} \meta{function}
%     \cs{ShowDocumentEnvironmentArgSpec} \Arg{environment}
%   \end{syntax}
%   These functions show the current argument specification for the
%   requested \meta{function} or \meta{environment} at the terminal. If
%   the \meta{function} or \meta{environment} has no known argument
%   specification then an error is issued.
% \end{function}
%
% \section{Load-time options}
%
% \DescribeOption{log-declarations}
% The package recognises the load-time option \texttt{log-declarations},
% which is a key--value option taking the value \texttt{true} and
% \texttt{false}. By default, the option is set to \texttt{false}, meaning
% that no command or environment declared is logged. By loading
% \pkg{xparse} using
% \begin{verbatim}
%   \usepackage[log-declarations=true]{xparse}
% \end{verbatim}
% each new, declared or renewed command or environment is logged.
%
% \end{documentation}
%

%
% \PrintIndex
