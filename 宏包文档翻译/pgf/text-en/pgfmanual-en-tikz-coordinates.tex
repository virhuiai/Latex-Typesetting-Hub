
% % -----------------------------------------------------------------------------
% % Deprecated:
% % -----------------------------------------------------------------------------
% %
\subsubsection{Intersection Coordinate Systems\\Deprecated\\交点坐标系统}

Often you wish to specify a point that is on the
intersection of two lines or shapes. For this, the following
coordinate system is useful:

通常情况下，你希望指定一个位于两条线或形状的交点上的点。为此，以下坐标系统很有用：

\begin{coordinatesystem}{intersection}
  First, you must specify two objects that should be
  intersected. These ``objects'' can either be lines or the shapes of
  nodes. There are two option to specify the first object:

  首先，你需要指定两个想要相交的对象。这些“对象”可以是线或节点的形状。有两种选项可以指定第一个对象：

  \begin{key}{/tikz/cs/first line={\ttfamily\char`\{}|(|\meta{first
          coordinate}|)--(|\meta{second coordinate}|)|{\ttfamily\char`\}}}
    Specifies that the first object is a line that goes from
    \meta{first coordinate} to meta{second coordinate}.

    指定第一个对象是一条从 \meta{第一个坐标} 到 \meta{第二个坐标} 的线。
  \end{key}
  Note that you have to write |--| between the coordinate, but this
  does not mean that anything is added to the path. This is simply a
  special syntax.

  注意，在坐标之间你必须使用 |--|，但这并不意味着路径中添加了任何内容。这只是一种特殊的语法。
  \begin{key}{/tikz/cs/first node=\meta{node}}
    Specifies that the first object is a previously defined node named
    \meta{node}.

    指定第一个对象是一个之前定义的名为 \meta{节点} 的节点。

  \end{key}

  To specify the second object, you use one of the following keys:

  要指定第二个对象，你可以使用以下键之一：
  \begin{key}{/tikz/cs/second line={\ttfamily\char`\{}|(|\meta{first
          coordinate}|)--(|\meta{second coordinate}|)|{\ttfamily\char`\}}}
    As above.
  \end{key}
  \begin{key}{/tikz/cs/second node=\meta{node}}
    Specifies that the second object is a previously defined node
    named \meta{node}.

    指定第二个对象是一个之前定义的名为 \meta{节点} 的节点。
  \end{key}

  Since it is possible that two objects have multiple intersections,
  you may need to specify which solution you want:

  由于两个对象可能有多个交点，你可能需要指定要使用的解决方案：
  \begin{key}{/tikz/cs/solution=\meta{number} (initially 1)}
    Specifies which solution should be used. Numbering starts with 1.

    指定要使用的解决方案。编号从1开始。

  \end{key}
  The coordinate specified in this way is the \meta{number}th
  intersection of the two objects.  If the objects do not intersect,
  an error may occur.

  以这种方式指定的坐标是两个对象的第 \meta{数字} 个交点。如果对象不相交，可能会出现错误。


\begin{codeexample}[]
\begin{tikzpicture}
  \draw[help lines] (0,0) grid (3,2);
  \draw (0,0) coordinate (A) -- (3,2) coordinate (B)
        (1,2)                -- (3,0);

  \fill[red] (intersection cs:
    first line={(A)--(B)},
    second line={(1,2)--(3,0)}) circle (2pt);
\end{tikzpicture}
\end{codeexample}

  The implicit way of specifying this coordinate system is to write
  \declare{|(intersection |\opt{\meta{number}}| of |\meta{first
      object}%
    | and |\meta{second object}|)|}. Here, \meta{first object} either
  has the form \meta{$p_1$}|--|\meta{$p_2$} or it is just a node
  name. Likewise for \meta{second object}. Note that there are \emph{no}
  parentheses around the $p_i$. Thus, you would write
  |(intersection of A--B and 1,2--3,0)|  for the intersection of the
  line through the coordinates |A| and |B| and the line through the
  points $(1,2)$ and $(3,0)$. You would write
  |(intersection 2 of c_1 and c_2)| for the second
  intersection of the node named |c_1| and the node named
  |c_2|.

  隐式指定此坐标系统的方法是写作 \declare{|(intersection |\opt{\meta{数字}}| of |\meta{第一个对象}%
| and |\meta{第二个对象}|)|}。这里，\meta{第一个对象} 的形式可以是 \meta{$p_1$}|--|\meta{$p_2$}，或者只是一个节点名称。对于 \meta{第二个对象} 也是如此。请注意，$p_i$ 周围\emph{没有}括号。因此，你可以写 |(intersection of A--B and 1,2--3,0)| 表示通过坐标 |A| 和 |B| 的线与点 $(1,2)$ 和 $(3,0)$ 的线的交点。你可以写 |(intersection 2 of c_1 and c_2)| 表示名为 |c_1| 和 |c_2| 的节点的第二个交点。



  \tikzname\ needs an explicit algorithm for computing the
  intersection of two shapes and such an algorithm is available only
  for few shapes. Currently, the following intersection will be
  computed correctly:

  \tikzname 需要明确的算法来计算两个形状的交点，而且目前只有少数形状的交点可以正确计算：

  \begin{itemize}
  \item a line and a line

  一条线和一条线
  \item a |circle| node and a line (in any order)

  一个 |circle| 节点和一条线（顺序可以任意）
  \item a |circle| and a |circle|

  一个 |circle| 和一个 |circle|
  \end{itemize}
\begin{codeexample}[]
\begin{tikzpicture}[scale=.25]
  \coordinate [label=-135:$a$] (a) at ($ (0,0)   + (rand,rand) $);
  \coordinate [label=45:$b$]   (b) at ($ (3,2) + (rand,rand) $);

  \coordinate [label=-135:$u$] (u) at (-1,1);
  \coordinate [label=45:$v$]   (v) at (6,0);

  \draw (a) -- (b)
        (u) -- (v);

  \node (c1) at (a) [draw,circle through=(b)] {};
  \node (c2) at (b) [draw,circle through=(a)] {};

  \coordinate [label=135:$c$] (c) at (intersection 2 of c1 and c2);
  \coordinate [label=-45:$d$] (d) at (intersection of u--v and c2);
  \coordinate [label=135:$e$] (e) at (intersection of u--v and a--b);

  \foreach \p in {a,b,c,d,e,u,v}
    \fill [opacity=.5] (\p) circle (8pt);
\end{tikzpicture}
\end{codeexample}
\end{coordinatesystem}
% -----------------------------------------------------------------------------


\subsubsection{Tangent Coordinate Systems\\}

\begin{coordinatesystem}{tangent}
    This coordinate system, which is available only when the \tikzname\ library
    |calc| is loaded, allows you to compute the point that lies tangent to a
    shape. In detail, consider a \meta{node} and a \meta{point}. Now, draw a
    straight line from the \meta{point} so that it ``touches'' the \meta{node}
    (more formally, so that it is \emph{tangent} to this \meta{node}). The
    point where the line touches the shape is the point referred to by the
    |tangent| coordinate system.

    The following options may be given:
    %
    \begin{key}{/tikz/cs/node=\meta{node}}
        This key specifies the node on whose border the tangent should lie.
    \end{key}
    %
    \begin{key}{/tikz/cs/point=\meta{point}}
        This key specifies the point through which the tangent should go.
    \end{key}
    %
    \begin{key}{/tikz/cs/solution=\meta{number}}
        Specifies which solution should be used if there are more than one.
    \end{key}

    A special algorithm is needed in order to compute the tangent for a given
    shape. Currently, tangents can be computed for nodes whose shape is one of
    the following:
    %
    \begin{itemize}
        \item |coordinate|
        \item |circle|
    \end{itemize}
    %
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw[help lines] (0,0) grid (3,2);

  \coordinate (a) at (3,2);

  \node [circle,draw] (c) at (1,1) [minimum size=40pt] {$c$};

  \draw[red] (a)  -- (tangent cs:node=c,point={(a)},solution=1) --
       (c.center) -- (tangent cs:node=c,point={(a)},solution=2) -- cycle;
\end{tikzpicture}
\end{codeexample}

    There is no implicit syntax for this coordinate system.
\end{coordinatesystem}


\subsubsection{Defining New Coordinate Systems}

While the set of coordinate systems that \tikzname\ can parse via their special
syntax is fixed, it is possible and quite easy to define new explicitly named
coordinate systems. For this, the following commands are used:

\begin{command}{\tikzdeclarecoordinatesystem\marg{name}\marg{code}}
    This command declares a new coordinate system named \meta{name} that can
    later on be used by writing |(|\meta{name}| cs:|\meta{arguments}|)|. When
    \tikzname\ encounters a coordinate specified in this way, the
    \meta{arguments} are passed to \meta{code} as argument |#1|.

    It is now the job of \meta{code} to make sense of the \meta{arguments}. At
    the end of \meta{code}, the two \TeX\ dimensions |\pgf@x| and |\pgf@y|
    should be have the $x$- and $y$-canvas coordinate of the coordinate.

    It is not necessary, but customary, to parse \meta{arguments} using the
    key--value syntax. However, you can also parse it in any way you like.

    In the following example, a coordinate system |cylindrical| is defined.
    %
\begin{codeexample}[]
\makeatletter
\define@key{cylindricalkeys}{angle}{\def\myangle{#1}}
\define@key{cylindricalkeys}{radius}{\def\myradius{#1}}
\define@key{cylindricalkeys}{z}{\def\myz{#1}}
\tikzdeclarecoordinatesystem{cylindrical}%
{%
  \setkeys{cylindricalkeys}{#1}%
  \pgfpointadd{\pgfpointxyz{0}{0}{\myz}}{\pgfpointpolarxy{\myangle}{\myradius}}
}
\begin{tikzpicture}[z=0.2pt]
  \draw [->] (0,0,0) -- (0,0,350);
  \foreach \num in {0,10,...,350}
    \fill (cylindrical cs:angle=\num,radius=1,z=\num) circle (1pt);
\end{tikzpicture}
\end{codeexample}
    %
\end{command}

\begin{command}{\tikzaliascoordinatesystem\marg{new name}\marg{old name}}
    Creates an alias of \meta{old name}.
\end{command}


\subsection{Coordinates at Intersections}
\label{section-intersection-coordinates}

You will wish to compute the intersection of two paths. For the special and
frequent case of two perpendicular lines, a special coordinate system called
|perpendicular| is available. For more general cases, the |intersection|
library can be used.


\subsubsection{Intersections of Perpendicular Lines}

A frequent special case of path intersections is the intersection of a vertical
line going through a point $p$ and a horizontal line going through some other
point $q$. For this situation there is a useful coordinate system.

\begin{coordinatesystem}{perpendicular}
    You can specify the two lines using the following keys:

    \begin{key}{/tikz/cs/horizontal line through={\ttfamily\char`\{}|(|\meta{coordinate}|)|{\ttfamily\char`\}}}
        Specifies that one line is a horizontal line that goes through the
        given coordinate.
    \end{key}
    %
    \begin{key}{/tikz/cs/vertical line through={\ttfamily\char`\{}|(|\meta{coordinate}|)|{\ttfamily\char`\}}}
        Specifies that the other line is vertical and goes through the given
        coordinate.
    \end{key}

    However, in almost all cases you should, instead, use the implicit syntax.
    Here, you write \declare{|(|\meta{p}\verb! |- !\meta{q}|)|} or
    \declare{|(|\meta{q}\verb! -| !\meta{p}|)|}.

    For example, \verb!(2,1 |- 3,4)! and  \verb!(3,4 -| 2,1)! both yield the
    same as \verb!(2,4)! (provided the $xy$-co\-or\-di\-nate system has not
    been modified).

    The most useful application of the syntax is to draw a line up to some
    point on a vertical or horizontal line. Here is an example:
    %
\begin{codeexample}[]
\begin{tikzpicture}
  \path (30:1cm) node(p1) {$p_1$}   (75:1cm) node(p2) {$p_2$};

  \draw (-0.2,0) -- (1.2,0) node(xline)[right] {$q_1$};
  \draw (2,-0.2) -- (2,1.2) node(yline)[above] {$q_2$};

  \draw[->] (p1) -- (p1 |- xline);
  \draw[->] (p2) -- (p2 |- xline);
  \draw[->] (p1) -- (p1 -| yline);
  \draw[->] (p2) -- (p2 -| yline);
\end{tikzpicture}
\end{codeexample}

    Note that in \declare{|(|\meta{c}\verb! |- !\meta{d}|)|} the coordinates
    \meta{c} and \meta{d} are \emph{not} surrounded by parentheses. If they
    need to be complicated expressions (like a computation using the
    |$|-syntax), you must surround them with braces; parentheses will then be   %$
    added around them.

    As an example, let us specify a point that lies horizontally at the middle
    of the line from $A$ to~$B$ and vertically at the middle of the line from
    $C$ to~$D$:
    %
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \node (A) at (0,1)    {A};
  \node (B) at (1,1.5)  {B};
  \node (C) at (2,0)    {C};
  \node (D) at (2.5,-2) {D};

  \draw (A) -- (B) node [midway] {x};
  \draw (C) -- (D) node [midway] {x};

  \node at ({$(A)!.5!(B)$} -| {$(C)!.5!(D)$}) {X};
\end{tikzpicture}
\end{codeexample}
    %
\end{coordinatesystem}


\subsubsection{Intersections of Arbitrary Paths}

\begin{tikzlibrary}{intersections}
    This library enables the calculation of intersections of two arbitrary
    paths. However, due to the low accuracy of \TeX, the paths should not be
    ``too complicated''. In particular, you should not try to intersect paths
    consisting of lots of very small segments such as plots or decorated paths.
\end{tikzlibrary}

To find the intersections of two paths in \tikzname, they must be ``named''. A
``named path'' is, quite simply, a path that has been named using the following
key (note that this is a \emph{different} key from the |name| key, which only
attaches a hyperlink target to a path, but does not store the path in a way the
is useful for the intersection computation):

\begin{keylist}{%
    /tikz/name path=\meta{name},
    /tikz/name path global=\meta{name}%
}
    The effect of this key is that, after the path has been constructed, just
    before it is used, it is associated with \meta{name}. For |name path|, this
    association survives beyond the final semi-colon of the path but not the
    end of the surrounding scope. For |name path global|, the association will
    survive beyond any scope as well. Handle with care.

    Any paths created by nodes on the (main) path are ignored, unless this key
    is explicitly used. If the same \meta{name} is used for the main path and
    the node path(s), then the paths will be added together and then associated
    with \meta{name}.
\end{keylist}

To find the intersection of named paths, the following key is used:

\begin{key}{/tikz/name intersections=\marg{options}}
    This key changes the key path to |/tikz/intersection| and processes
    \meta{options}. These options determine, among other things, which paths to
    use for the intersection. Having processed the options, any intersections
    are then found. A coordinate is created at each intersection, which by
    default, will be named |intersection-1|, |intersection-2|, and so on.
    Optionally, the prefix |intersection| can be changed, and the total number
    of intersections stored in a \TeX-macro.
    %
\begin{codeexample}[preamble={\usetikzlibrary{intersections}}]
\begin{tikzpicture}[every node/.style={opacity=1, black, above left}]
  \draw [help lines] grid (3,2);
  \draw [name path=ellipse] (2,0.5) ellipse (0.75cm and 1cm);
  \draw [name path=rectangle, rotate=10] (0.5,0.5) rectangle +(2,1);
  \fill [red, opacity=0.5, name intersections={of=ellipse and rectangle}]
    (intersection-1) circle (2pt) node {1}
    (intersection-2) circle (2pt) node {2};
\end{tikzpicture}
\end{codeexample}

    The following keys can be used in \meta{options}:

    \begin{key}{/tikz/intersection/of=\meta{name path 1}| and |\meta{name path 2}}
        This key is used to specify the names of the paths to use for the
        intersection.
    \end{key}

    \begin{key}{/tikz/intersection/name=\meta{prefix} (initially intersection)}
        This key specifies the prefix name for the coordinate nodes placed at
        each intersection.
    \end{key}

    \begin{key}{/tikz/intersection/total=\meta{macro}}
        This key means that the total number of intersections found will be
        stored in \meta{macro}.
    \end{key}

\begin{codeexample}[preamble={\usetikzlibrary{intersections}}]
\begin{tikzpicture}
  \clip (-2,-2) rectangle (2,2);
  \draw [name path=curve 1] (-2,-1) .. controls (8,-1) and (-8,1) .. (2,1);
  \draw [name path=curve 2] (-1,-2) .. controls (-1,8) and (1,-8) .. (1,2);

  \fill [name intersections={of=curve 1 and curve 2, name=i, total=\t}]
        [red, opacity=0.5, every node/.style={above left, black, opacity=1}]
        \foreach \s in {1,...,\t}{(i-\s) circle (2pt) node {\footnotesize\s}};
\end{tikzpicture}
\end{codeexample}

    \begin{key}{/tikz/intersection/by=\meta{comma-separated list}}
        This key allows you to specify a list of names for the intersection
        coordinates. The intersection coordinates will still be named
        \meta{prefix}|-|\meta{number}, but additionally the first coordinate
        will also be named by the first element of the \meta{comma-separated
        list}. What happens is that the \meta{comma-separated list} is passed
        to the |\foreach| statement and for \meta{list member} a coordinate is
        created at the already-named intersection.
        %
\begin{codeexample}[preamble={\usetikzlibrary{intersections}}]
\begin{tikzpicture}
  \clip (-2,-2) rectangle (2,2);
  \draw [name path=curve 1] (-2,-1) .. controls (8,-1) and (-8,1) .. (2,1);
  \draw [name path=curve 2] (-1,-2) .. controls (-1,8) and (1,-8) .. (1,2);

  \fill [name intersections={of=curve 1 and curve 2, by={a,b}}]
        (a) circle (2pt)
        (b) circle (2pt);
\end{tikzpicture}
\end{codeexample}

        You can also use the |...| notation of the |\foreach| statement inside
        the \meta{comma-separated list}.

        In case an element of the \meta{comma-separated list} starts with
        options in square brackets, these options are used when the coordinate
        is created. A coordinate name can still, but need not, follow the
        options. This makes it easy to add labels to intersections:
        %
\begin{codeexample}[preamble={\usetikzlibrary{intersections}}]
\begin{tikzpicture}
  \clip (-2,-2) rectangle (2,2);
  \draw [name path=curve 1] (-2,-1) .. controls (8,-1) and (-8,1) .. (2,1);
  \draw [name path=curve 2] (-1,-2) .. controls (-1,8) and (1,-8) .. (1,2);

  \fill [name intersections={
          of=curve 1 and curve 2,
          by={[label=center:a],[label=center:...],[label=center:i]}}];
\end{tikzpicture}
\end{codeexample}
    \end{key}

    \begin{key}{/tikz/intersection/sort by=\meta{path name}}
        By default, the intersections are simply returned in the order that the
        intersection algorithm finds them. Unfortunately, this is not
        necessarily a ``helpful'' ordering. This key can be used to sort the
        intersections along the path specified by \meta{path name}, which
        should be one of the paths mentioned in the |/tikz/intersection/of|
        key.
        %
\begin{codeexample}[preamble={\usetikzlibrary{intersections}}]
\begin{tikzpicture}
\clip (-0.5,-0.75) rectangle (3.25,2.25);
\foreach \pathname/\shift in {line/0cm, curve/2cm}{
  \tikzset{xshift=\shift}
  \draw [->, name path=curve] (1,1.5) .. controls (-1,1) and (2,0.5) .. (0,0);
  \draw [->, name path=line]  (0,-.5) -- (1,2) ;
  \fill [name intersections={of=line and curve,sort by=\pathname, name=i}]
    [red, opacity=0.5, every node/.style={left=.25cm, black, opacity=1}]
    \foreach \s in {1,2,3}{(i-\s) circle (2pt) node {\footnotesize\s}};
}
\end{tikzpicture}
\end{codeexample}
    \end{key}
\end{key}


\subsection{Relative and Incremental Coordinates}

\subsubsection{Specifying Relative Coordinates}

You can prefix coordinates by |++| to make them ``relative''. A coordinate such
as |++(1cm,0pt)| means ``1cm to the right of the previous position, making this
the new current position''. Relative coordinates are often useful in ``local''
contexts:
%
\begin{codeexample}[]
\begin{tikzpicture}
  \draw (0,0)     -- ++(1,0) -- ++(0,1) -- ++(-1,0) -- cycle;
  \draw (2,0)     -- ++(1,0) -- ++(0,1) -- ++(-1,0) -- cycle;
  \draw (1.5,1.5) -- ++(1,0) -- ++(0,1) -- ++(-1,0) -- cycle;
\end{tikzpicture}
\end{codeexample}

Instead of |++| you can also use a single |+|. This also specifies a relative
coordinate, but it does not ``update'' the current point for subsequent usages
of relative coordinates. Thus, you can use this notation to specify numerous
points, all relative to the same ``initial'' point:

\begin{codeexample}[]
\begin{tikzpicture}
  \draw (0,0)     -- +(1,0) -- +(1,1) -- +(0,1) -- cycle;
  \draw (2,0)     -- +(1,0) -- +(1,1) -- +(0,1) -- cycle;
  \draw (1.5,1.5) -- +(1,0) -- +(1,1) -- +(0,1) -- cycle;
\end{tikzpicture}
\end{codeexample}

There is a special situation, where relative coordinates are interpreted
differently. If you use a relative coordinate as a control point of a Bézier
curve, the following rule applies: First, a relative first control point is
taken relative to the beginning of the curve. Second, a relative second control
point is taken relative to the end of the curve. Third, a relative end point of
a curve is taken relative to the start of the curve.

This special behavior makes it easy to specify that a curve should ``leave or
arrive from a certain direction'' at the start or end. In the following
example, the curve ``leaves'' at $30^\circ$ and ``arrives'' at $60^\circ$:
%
\begin{codeexample}[]
\begin{tikzpicture}
  \draw (1,0) .. controls +(30:1cm) and +(60:1cm) .. (3,-1);
  \draw[gray,->] (1,0) -- +(30:1cm);
  \draw[gray,<-] (3,-1) -- +(60:1cm);
\end{tikzpicture}
\end{codeexample}


\subsubsection{Rotational Relative Coordinates}

You may sometimes wish to specify points relative not only to the previous
point, but additionally relative to the tangent entering the previous point.
For this, the following key is useful:

\begin{key}{/tikz/turn}
    This key can be given as an option to a \meta{coordinate} as in the
    following example:
    %
\begin{codeexample}[]
\tikz \draw (0,0) -- (1,1) -- ([turn]-45:1cm) -- ([turn]-30:1cm);
\end{codeexample}
    %
    The effect of this key is to locally shift the coordinate system so that
    the last point reached is at the origin and the coordinate system is
    ``turned'' so that the $x$-axis points in the direction of a tangent
    entering the last point. This means, in effect, that when you use polar
    coordinates of the form \meta{relative angle}|:|\meta{distance} together
    with the |turn| option, you specify a point that lies at \meta{distance}
    from the last point in the direction of the last tangent entering the last
    point, but with a rotation of \meta{relative angle}.

    This key also works with curves \dots
    %
\begin{codeexample}[]
\tikz [delta angle=30, radius=1cm]
  \draw (0,0) arc [start angle=0]  -- ([turn]0:1cm)
              arc [start angle=30] -- ([turn]0:1cm)
              arc [start angle=60] -- ([turn]30:1cm);
\end{codeexample}
\begin{codeexample}[]
\tikz \draw (0,0) to [bend left] (2,1) -- ([turn]0:1cm);
\end{codeexample}
    %
    \dots and with plots \dots
    %
\begin{codeexample}[]
\tikz \draw plot coordinates {(0,0) (1,1) (2,0) (3,0) } -- ([turn]30:1cm);
\end{codeexample}

    Although the above examples use polar coordinates with |turn|, you can also
    use any normal coordinate. For instance, |([turn]1,1)| will append a line
    of length $\sqrt 2$ that is turns by $45^\circ$ relative to the tangent to
    the last point.
    %
\begin{codeexample}[]
\tikz \draw (0.5,0.5) -| (2,1) -- ([turn]1,1)
         .. controls ([turn]0:1cm) .. ([turn]-90:1cm);
\end{codeexample}
    %
\end{key}


\subsubsection{Relative Coordinates and Scopes}
\label{section-scopes-relative}

An interesting question is, how do relative coordinates behave in the presence
of scopes? That is, suppose we use curly braces in a path to make part of it
``local'', how does that affect the current position? On the one hand, the
current position certainly changes since the scope only affects options, not
the path itself. On the other hand, it may be useful to ``temporarily escape''
from the updating of the current point.

Since both interpretations of how the current point and scopes should
``interact'' are useful, there is a (local!) option that allows you to decide
which you need.

\begin{key}{/tikz/current point is local=\opt{\meta{boolean}} (initially false)}
    Normally, the scope path operation has no effect on the current point. That
    is, curly braces on a path have no effect on the current position:
    %
\begin{codeexample}[]
\begin{tikzpicture}
  \draw      (0,0) -- ++(1,0)   -- ++(0,1)   -- ++(-1,0);
  \draw[red] (2,0) -- ++(1,0) { -- ++(0,1) } -- ++(-1,0);
\end{tikzpicture}
\end{codeexample}
    %
    If you set this key to |true|, this behavior changes. In this case, at the
    end of a group created on a path, the last current position reverts to
    whatever value it had at the beginning of the scope. More precisely, when
    \tikzname\ encounters |}| on a path, it checks whether at this particular
    moment the key is set to |true|. If so, the current position reverts to the
    value it had when the matching |{| was read.
    %
\begin{codeexample}[]
\begin{tikzpicture}
  \draw      (0,0) -- ++(1,0)   -- ++(0,1)   -- ++(-1,0);
  \draw[red] (2,0) -- ++(1,0)
     { [current point is local] -- ++(0,1) } -- ++(-1,0);
\end{tikzpicture}
\end{codeexample}
    %
    In the above example, we could also have given the option outside the
    scope, for instance as a parameter to the whole scope.
\end{key}


\subsection{Coordinate Calculations}
\label{tikz-lib-calc}

\begin{tikzlibrary}{calc}
    You need to load this library in order to use the coordinate calculation
    functions described in the present section.
\end{tikzlibrary}

It is possible to do some basic calculations that involve coordinates. In
essence, you can add and subtract coordinates, scale them, compute midpoints,
and do projections. For instance, |($(a) + 1/3*(1cm,0)$)| is the coordinate
that is $1/3 \text{cm}$ to the right of the point |a|:
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);

  \node (a) at (1,1) {A};
  \fill [red] ($(a) + 1/3*(1cm,0)$) circle (2pt);
\end{tikzpicture}
\end{codeexample}


\subsubsection{The General Syntax}

The general syntax is the following:
%
\begin{quote}
    \declare{|(|\opt{|[|\meta{options}|]|}|$|\meta{coordinate computation}|$)|}.
\end{quote}

As you can see, the syntax uses the \TeX\ math symbol |$| to %$
indicate that a ``mathematical computation'' is involved. However, the |$| %$
has no other effect, in particular, no mathematical text is typeset.

The \meta{coordinate computation} has the following structure:
%
\begin{enumerate}
    \item It starts with
        %
        \begin{quote}
            \opt{\meta{factor}|*|}\meta{coordinate}\opt{\meta{modifiers}}
        \end{quote}
    \item This is optionally followed by |+| or |-| and then another
        %
        \begin{quote}
            \opt{\meta{factor}|*|}\meta{coordinate}\opt{\meta{modifiers}}
        \end{quote}
    \item This is once more followed by |+| or |-| and another of the above
        modified coordinate; and so on.
\end{enumerate}

In the following, the syntax of factors and of the different modifiers
is explained in detail.


\subsubsection{The Syntax of Factors}

The \meta{factor}s are optional and detected by checking whether the
\meta{coordinate computation} starts with a |(|. Also, after each $\pm$ a
\meta{factor} is present if, and only if, the |+| or |-| sign is not directly
followed by~|(|.

If a \meta{factor} is present, it is evaluated using the |\pgfmathparse| macro.
This means that you can use pretty complicated computations inside a factor. A
\meta{factor} may even contain opening parentheses, which creates a
complication: How does \tikzname\ know where a \meta{factor} ends and where a
coordinate starts? For instance, if the beginning of a \meta{coordinate
computation} is |2*(3+4|\dots, it is not clear whether |3+4| is part of a
\meta{coordinate} or part of a \meta{factor}. Because of this, the following
rule is used: Once it has been determined, that a \meta{factor} is present, in
principle, the \meta{factor} contains everything up to the next occurrence of
|*(|. Note that there is no space between the asterisk and the parenthesis.

It is permissible to put the \meta{factor} in curly braces. This can be used
whenever it is unclear where the \meta{factor} would end.

Here are some examples of coordinate specifications that consist of exactly one
\meta{factor} and one \meta{coordinate}:
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);

  \fill [red] ($2*(1,1)$) circle (2pt);
  \fill [green] (${1+1}*(1,.5)$) circle (2pt);
  \fill [blue] ($cos(0)*sin(90)*(1,1)$) circle (2pt);
  \fill [black] (${3*(4-3)}*(1,0.5)$) circle (2pt);
\end{tikzpicture}
\end{codeexample}


\subsubsection{The Syntax of Partway Modifiers}

A \meta{coordinate} can be followed by different \meta{modifiers}. The first
kind of modifier is the \emph{partway modifier}. The syntax (which is loosely
inspired by Uwe Kern's |xcolor| package) is the following:
%
\begin{quote}
    \meta{coordinate}\declare{|!|\meta{number}|!|\opt{\meta{angle}|:|}\meta{second coordinate}}
\end{quote}
%
One could write for instance
%
\begin{codeexample}[code only]
(1,2)!.75!(3,4)
\end{codeexample}
%
The meaning of this is: ``Use the coordinate that is three quarters on the way
from |(1,2)| to |(3,4)|.'' In general, \meta{coordinate
x}|!|\meta{number}|!|\meta{coordinate y} yields the coordinate $(1 -
\meta{number})\meta{coordinate x} + \meta{number} \meta{coordinate y}$. Note
that this is a bit different from the way the \meta{number} is interpreted in
the |xcolor| package: First, you use a factor between $0$ and $1$, not a
percentage, and, second, as the \meta{number} approaches $1$, we approach the
second coordinate, not the first. It is permissible to use a \meta{number} that
is smaller than $0$ or larger than $1$. The \meta{number} is evaluated using
the |\pgfmathparse| command and, thus, it can involve complicated computations.
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);

  \draw (1,0) -- (3,2);

  \foreach \i in {0,0.2,0.5,0.9,1}
    \node at ($(1,0)!\i!(3,2)$) {\i};
\end{tikzpicture}
\end{codeexample}

The \meta{second coordinate} may be prefixed by an \meta{angle}, separated with
a colon, as in |(1,1)!.5!60:(2,2)|. The general meaning of
\meta{a}|!|\meta{factor}|!|\meta{angle}|:|\meta{b} is: ``First, consider the
line from \meta{a} to \meta{b}. Then rotate this line by \meta{angle}
\emph{around the point \meta{a}}. Then the two endpoints of this line will be
\meta{a} and some point \meta{c}. Use this point \meta{c} for the subsequent
computation, namely the partway computation.''

Here are two examples:
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,3);

  \coordinate (a) at (1,0);
  \coordinate (b) at (3,2);

  \draw[->] (a) -- (b);

  \coordinate (c) at ($ (a)!1! 10:(b) $);

  \draw[->,red] (a) -- (c);

  \fill ($ (a)!.5! 10:(b) $) circle (2pt);
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (4,4);

  \foreach \i in {0,0.1,...,2}
    \fill ($(2,2) !\i! \i*180:(3,2)$) circle (2pt);
\end{tikzpicture}
\end{codeexample}

You can repeatedly apply modifiers. That is, after any modifier you can add
another (possibly different) modifier.
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);

  \draw (0,0) -- (3,2);
  \draw[red] ($(0,0)!.3!(3,2)$) -- (3,0);
  \fill[red] ($(0,0)!.3!(3,2)!.7!(3,0)$) circle (2pt);
\end{tikzpicture}
\end{codeexample}


\subsubsection{The Syntax of Distance Modifiers}

A \emph{distance modifier} has nearly the same syntax as a partway modifier,
only you use a \meta{dimension} (something like |1cm|) instead of a
\meta{factor} (something like |0.5|):
%
\begin{quote}
    \meta{coordinate}\declare{|!|\meta{dimension}|!|\opt{\meta{angle}|:|}\meta{second coordinate}}
\end{quote}

When you write \meta{a}|!|\meta{dimension}|!|\meta{b}, this means the
following: Use the point that is distanced \meta{dimension} from \meta{a} on
the straight line from \meta{a} to \meta{b}. Here is an example:
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);

  \draw (1,0) -- (3,2);

  \foreach \i in {0cm,1cm,15mm}
    \node at ($(1,0)!\i!(3,2)$) {\i};
\end{tikzpicture}
\end{codeexample}

As before, if you use a \meta{angle}, the \meta{second coordinate} is rotated
by this much around the \meta{coordinate} before it is used.

The combination of an \meta{angle} of |90| degrees with a distance can be used
to ``offset'' a point relative to a line. Suppose, for instance, that you have
computed a point |(c)| that lies somewhere on a line from |(a)| to~|(b)| and
you now wish to offset this point by |1cm| so that the distance from this
offset point to the line is |1cm|. This can be achieved as follows:
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);

  \coordinate (a) at (1,0);
  \coordinate (b) at (3,1);

  \draw (a) -- (b);

  \coordinate (c) at ($ (a)!.25!(b) $);
  \coordinate (d) at ($ (c)!1cm!90:(b) $);

  \draw [<->] (c) -- (d) node [sloped,midway,above] {1cm};
\end{tikzpicture}
\end{codeexample}


\subsubsection{The Syntax of Projection Modifiers}

The projection modifier is also similar to the above modifiers: It also gives a
point on a line from the \meta{coordinate} to the \meta{second coordinate}.
However, the \meta{number} or \meta{dimension} is replaced by a
\meta{projection coordinate}:
%
\begin{quote}
    \meta{coordinate}\declare{|!|\meta{projection coordinate}|!|\opt{\meta{angle}|:|}\meta{second coordinate}}
\end{quote}

Here is an example:
%
\begin{codeexample}[code only]
(1,2)!(0,5)!(3,4)
\end{codeexample}

The effect is the following: We project the \meta{projection coordinate}
orthogonally onto the line from \meta{coordinate} to \meta{second coordinate}.
This makes it easy to compute projected points:
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);

  \coordinate (a) at (0,1);
  \coordinate (b) at (3,2);
  \coordinate (c) at (2.5,0);

  \draw (a) -- (b) -- (c) -- cycle;

  \draw[red]    (a) -- ($(b)!(a)!(c)$);
  \draw[orange] (b) -- ($(a)!(b)!(c)$);
  \draw[blue]   (c) -- ($(a)!(c)!(b)$);
\end{tikzpicture}
\end{codeexample}
