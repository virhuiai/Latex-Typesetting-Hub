
\subsubsection{Canvas, XYZ, and Polar Coordinate Systems\\画布、XYZ 和极坐标系}

Let us start with the basic coordinate systems.

让我们从基本的坐标系开始。

\begin{coordinatesystem}{canvas}
    The simplest way of specifying a coordinate is to use the |canvas|
    coordinate system. You provide a dimension $d_x$ using the |x=| option and
    another dimension $d_y$ using the |y=| option. The position on the canvas
    is located at the position that is $d_x$ to the right and $d_y$ above the
    origin.

    指定坐标的最简单方法是使用 |canvas| 坐标系。使用 |x=| 选项提供一个维度 $d_x$，使用 |y=| 选项提供另一个维度 $d_y$。画布上的位置位于距离原点向右 $d_x$、向上 $d_y$ 的位置。

    \begin{key}{/tikz/cs/x=\meta{dimension} (initially 0pt)}
        Distance by which the coordinate is to the right of the origin. You can
        also write things like |1cm+2pt| since the mathematical engine is used
        to evaluate the \meta{dimension}.

        坐标相对于原点向右的距离。可以写成 |1cm+2pt| 这样的形式，因为使用数学引擎来评估 \meta{尺寸}。
    \end{key}

    \begin{key}{/tikz/cs/y=\meta{dimension} (initially 0pt)}
        Distance by which the coordinate is above the origin.

        坐标相对于原点向上的距离。
    \end{key}

\begin{codeexample}[]
\begin{tikzpicture}
  \draw[help lines] (0,0) grid (3,2);

  \fill (canvas cs:x=1cm,y=1.5cm)    circle (2pt);
  \fill (canvas cs:x=2cm,y=-5mm+2pt) circle (2pt);
\end{tikzpicture}
\end{codeexample}

    To specify a coordinate in the coordinate system implicitly, you use two
    dimensions that are separated by a comma as in |(0cm,3pt)| or
    |(2cm,\textheight)|.
    
    
    要隐式指定坐标系，可以使用用逗号分隔的两个维度，如 |(0cm,3pt)| 或 |(2cm,\textheight)|。%
\begin{codeexample}[]
\begin{tikzpicture}
  \draw[help lines] (0,0) grid (3,2);

  \fill (1cm,1.5cm)    circle (2pt);
  \fill (2cm,-5mm+2pt) circle (2pt);
\end{tikzpicture}
\end{codeexample}
    %
\end{coordinatesystem}

\begin{coordinatesystem}{xyz}
    The |xyz| coordinate system allows you to specify a point as a multiple of
    three vectors called the $x$-, $y$-, and $z$-vectors. By default, the
    $x$-vector points 1cm to the right, the $y$-vector points 1cm upwards, but
    this can be changed arbitrarily as explained in Section~\ref{section-xyz}.
    The default $z$-vector points to
    $\bigl(-3.85\textrm{mm},-3.85\textrm{mm}\bigr)$.

    |xyz| 坐标系允许您将点指定为三个向量（$x$ 向量、$y$ 向量和 $z$ 向量）的倍数。默认情况下，$x$ 向量指向右侧 1cm，$y$ 向量指向上方 1cm，但可以根据需要进行任意更改，如第~\ref{section-xyz} 节中所述。默认的 $z$ 向量指向 $\bigl(-3.85\textrm{mm},-3.5\textrm{mm}\bigr)$。


    To specify the factors by which the vectors should be multiplied before
    being added, you use the following three options:
    
    要指定向量相加之前的倍数，可以使用以下三个选项：%
    \begin{key}{/tikz/cs/x=\meta{factor} (initially 0)}
        Factor by which the $x$-vector is multiplied.
    \end{key}
    %
    \begin{key}{/tikz/cs/y=\meta{factor} (initially 0)}
        Works like |x|.
    \end{key}
    %
    \begin{key}{/tikz/cs/z=\meta{factor} (initially 0)}
        Works like |x|.
    \end{key}

\begin{codeexample}[]
\begin{tikzpicture}[->]
  \draw (0,0) -- (xyz cs:x=1);
  \draw (0,0) -- (xyz cs:y=1);
  \draw (0,0) -- (xyz cs:z=1);
\end{tikzpicture}
\end{codeexample}

    This coordinate system can also be selected implicitly. To do so, you just
    provide two or three comma-separated factors (not dimensions).
    
    
    这个坐标系也可以隐式选择。为此，只需提供两个或三个以逗号分隔的因子（不是尺寸）。
%
\begin{codeexample}[]
\begin{tikzpicture}[->]
  \draw (0,0) -- (1,0);
  \draw (0,0) -- (0,1,0);
  \draw (0,0) -- (0,0,1);
\end{tikzpicture}
\end{codeexample}
    %
\end{coordinatesystem}

\emph{Note:} It is possible to use coordinates like |(1,2cm)|, which are
neither |canvas| coordinates nor |xyz| coordinates. The rule is the following:
If a coordinate is of the implicit form |(|\meta{x}|,|\meta{y}|)|, then
\meta{x} and \meta{y} are checked, independently, whether they have a dimension
or whether they are dimensionless. If both have a dimension, the |canvas|
coordinate system is used. If both lack a dimension, the |xyz| coordinate
system is used. If \meta{x} has a dimension and \meta{y} has not, then the sum
of two coordinate |(|\meta{x}|,0pt)| and |(0,|\meta{y}|)| is used. If \meta{y}
has a dimension and \meta{x} has not, then the sum of two coordinate
|(|\meta{x}|,0)| and |(0pt,|\meta{y}|)| is used.

\emph{注意：}可以使用诸如 |(1,2cm)| 这样的坐标，它们既不是 |canvas| 坐标也不是 |xyz| 坐标。规则如下：如果坐标的隐式形式为 |(|\meta{x}|,|\meta{y}|)|，则会独立检查 \meta{x} 和 \meta{y} 是否具有尺寸或无尺寸。如果两者都有尺寸，则使用 |canvas| 坐标系。如果两者都没有尺寸，则使用 |xyz| 坐标系。如果 \meta{x} 有尺寸而 \meta{y} 没有，则使用两个坐标 |(|\meta{x}|,0pt)| 和 |(0,|\meta{y}|)| 的和。如果 \meta{y} 有尺寸而 \meta{x} 没有，则使用两个坐标 |(|\meta{x}|,0)| 和 |(0pt,|\meta{y}|)| 的和。


\emph{Note furthermore:} An expression like |(2+3cm,0)| does \emph{not} mean
the same as |(2cm+3cm,0)|. Instead, if \meta{x} or \meta{y} internally uses a
mixture of dimensions and dimensionless values, then all dimensionless values
are ``upgraded'' to dimensions by interpreting them as |pt|. So, |2+3cm| is the
same dimension as |2pt+3cm|.

\emph{此外注意：}表达式 |(2+3cm,0)| 与 |(2cm+3cm,0)| \emph{不}相同。如果 \meta{x} 或 \meta{y} 内部使用尺寸和无尺寸值的混合，则所有无尺寸值都会通过将其解释为 |pt| 而被``升级''为尺寸。因此，|2+3cm| 和 |2pt+3cm| 表示相同的尺寸。


\begin{coordinatesystem}{canvas polar}
    The |canvas polar| coordinate system allows you to specify polar
    coordinates. You provide an angle using the |angle=| option and a radius
    using the |radius=| option. This yields the point on the canvas that is at
    the given radius distance from the origin at the given degree. An angle of
    zero degrees to the right, a degree of 90 upward.
    
    |canvas polar|坐标系允许您指定极坐标。您可以使用|angle=|选项提供角度，并使用|radius=|选项提供半径。这将给出位于给定角度处距离原点给定半径距离的画布上的点。角度为零度表示向右，90度表示向上。
%
    \begin{key}{/tikz/cs/angle=\meta{degrees}}
        The angle of the coordinate. The angle must always be given in degrees
        and should be between $-360$ and $720$.

        坐标的角度。角度必须始终以度为单位，并且应在$-360$到$720$之间。

    \end{key}
    %
    \begin{key}{/tikz/cs/radius=\meta{dimension}}
        The distance from the origin.

        距离原点的距离。

    \end{key}
    %
    \begin{key}{/tikz/cs/x radius=\meta{dimension}}
        A polar coordinate is, after all, just a point on a circle of the given
        \meta{radius}. When you provide an $x$-radius and also a $y$-radius,
        you specify an ellipse instead of a circle. The |radius| option has the
        same effect as specifying identical |x radius| and |y radius| options.

        极坐标实际上只是给定\meta{radius}的圆上的一个点。当您提供$x$半径和$y$半径时，您指定的是椭圆而不是圆。|radius|选项与指定相同的|x radius|和|y radius|选项具有相同的效果。
    \end{key}
    %
    \begin{key}{/tikz/cs/y radius=\meta{dimension}}
        Works like |x radius|.

        与|x radius|相同。

    \end{key}
    %
\begin{codeexample}[]
\tikz \draw (0,0) -- (canvas polar cs:angle=30,radius=1cm);
\end{codeexample}

    The implicit form for canvas polar coordinates is the following: you
    specify the angle and the distance, separated by a colon as in |(30:1cm)|.
    %

    画布极坐标的隐式形式如下：您使用冒号分隔的角度和距离来指定，例如 |(30:1cm)|。

\begin{codeexample}[]
\tikz \draw    (0cm,0cm) -- (30:1cm) -- (60:1cm) -- (90:1cm)
            -- (120:1cm) -- (150:1cm) -- (180:1cm);
\end{codeexample}

    Two different radii are specified by writing |(30:1cm and 2cm)|.

    通过编写 |(30:1cm and 2cm)| 可以指定两个不同的半径。



    For the implicit form, instead of an angle given as a number you can also
    use certain words. For example, |up| is the same as |90|, so that you can
    write |\tikz \draw (0,0) -- (2ex,0pt) -- +(up:1ex);| and get
    \tikz \draw (0,0) -- (2ex,0pt) -- +(up:1ex);. Apart from |up| you can use
    |down|, |left|, |right|, |north|, |south|, |west|, |east|, |north east|,
    |north west|, |south east|, |south west|, all of which have their natural
    meaning.

    对于隐式形式，您可以使用某些单词而不是数字来表示角度。例如，|up| 等同于 |90|，因此您可以编写 |\tikz \draw (0,0) -- (2ex,0pt) -- +(up:1ex);| 并获得 \tikz \draw (0,0) -- (2ex,0pt) -- +(up:1ex);。除了 |up|，您还可以使用 |down|、|left|、|right|、|north|、|south|、|west|、|east|、|north east|、|north west|、|south east| 和 |south west|，它们都有其自然的含义。

\end{coordinatesystem}

\begin{coordinatesystem}{xyz polar}
    This coordinate system work similarly to the |canvas polar| system.
    However, the radius and the angle are interpreted in the $xy$-coordinate
    system, not in the canvas system. More detailed, consider the circle or
    ellipse whose half axes are given by the current $x$-vector and the current
    $y$-vector. Then, consider the point that lies at a given angle on this
    ellipse, where an angle of zero is the same as the $x$-vector and an angle
    of 90 is the $y$-vector. Finally, multiply the resulting vector by the
    given radius factor. Voil\`a.
    
    这个坐标系与|canvas polar|系统类似。但是，半径和角度是在$xy$坐标系中解释的，而不是在画布坐标系中解释的。更详细地说，考虑由当前$x$向量和当前$y$向量给出的圆或椭圆。然后，考虑位于此椭圆上给定角度处的点，其中角度零与$x$向量相同，角度90与$y$向量相同。最后，将得到的向量乘以给定的半径因子。Voil`a。

%
    \begin{key}{/tikz/cs/angle=\meta{degrees}}
        The angle of the coordinate interpreted in the ellipse whose axes are
        the $x$-vector and the $y$-vector.

        坐标的角度，解释为以$x$向量和$y$向量为轴的椭圆中的角度。

    \end{key}
    %
    \begin{key}{/tikz/cs/radius=\meta{factor}}
        A factor by which the $x$-vector and $y$-vector are multiplied prior to
        forming the ellipse.

        在形成椭圆之前，$x$向量和$y$向量乘以的因子。

    \end{key}
    %
    \begin{key}{/tikz/cs/x radius=\meta{dimension}}
        A specific factor by which only the $x$-vector is multiplied.
    
        仅将$x$向量乘以的特定因子。
    \end{key}
    %
    \begin{key}{/tikz/cs/y radius=\meta{dimension}}
        Works like |x radius|.

        与|x radius|相同。

    \end{key}
    %
\begin{codeexample}[]
\begin{tikzpicture}[x=1.5cm,y=1cm]
  \draw[help lines] (0cm,0cm) grid (3cm,2cm);

  \draw (0,0) -- (xyz polar cs:angle=0,radius=1);
  \draw (0,0) -- (xyz polar cs:angle=30,radius=1);
  \draw (0,0) -- (xyz polar cs:angle=60,radius=1);
  \draw (0,0) -- (xyz polar cs:angle=90,radius=1);

  \draw (xyz polar cs:angle=0,radius=2)
     -- (xyz polar cs:angle=30,radius=2)
     -- (xyz polar cs:angle=60,radius=2)
     -- (xyz polar cs:angle=90,radius=2);
 \end{tikzpicture}
\end{codeexample}

    The implicit version of this option is the same as the implicit version of
    |canvas polar|, only you do not provide a unit.

    这个选项的隐式版本与|canvas polar|的隐式版本相同，只是您不需要提供单位。
\begin{codeexample}[]
\tikz[x={(0cm,1cm)},y={(-1cm,0cm)}]
  \draw  (0,0) -- (30:1) -- (60:1) -- (90:1)
             -- (120:1) -- (150:1) -- (180:1);
\end{codeexample}
    %
\end{coordinatesystem}

\begin{coordinatesystem}{xy polar}
    This is just an alias for |xyz polar|, which some people might prefer as
    there is no z-coordinate involved in the |xyz polar| coordinates.

    这只是|xyz polar|的别名，一些人可能更喜欢使用它，因为|xyz polar|坐标中没有涉及z坐标。
\end{coordinatesystem}


\subsubsection{Barycentric Systems\\重心系}
\label{section-barycentric-coordinates}

In the barycentric coordinate system a point is expressed as the linear
combination of multiple vectors. The idea is that you specify vectors $v_1$,
$v_2$, \dots, $v_n$ and numbers $\alpha_1$, $\alpha_2$, \dots, $\alpha_n$. Then
the barycentric coordinate specified by these vectors and numbers is

在重心坐标系中，一个点被表示为多个向量的线性组合。思路是您指定向量$v_1$、$v_2$、\dots、$v_n$和数字$\alpha_1$、$\alpha_2$、\dots、$\alpha_n$。然后由这些向量和数字指定的重心坐标为
%
\begin{align*}
    \frac{\alpha_1 v_1 + \alpha_2 v_2 + \cdots + \alpha_n v_n}{\alpha_1
        + \alpha_2 + \cdots + \alpha_n}
\end{align*}

The |barycentric cs| allows you to specify such coordinates easily.

|barycentric cs|允许您轻松指定这样的坐标。


\begin{coordinatesystem}{barycentric}
    For this coordinate system, the \meta{coordinate specification} should be a
    comma-separated list of expressions of the form \meta{node
    name}|=|\meta{number}. Note that (currently) the list should not contain
    any spaces before or after the \meta{node name} (unlike normal key--value
    pairs).

    对于这个坐标系，\meta{coordinate specification}应该是一个由逗号分隔的表达式列表，每个表达式的格式为\meta{node name}|=|\meta{number}。请注意（目前）列表中不应在\meta{node name}之前或之后包含任何空格（与常规键值对不同）。


    The specified coordinate is now computed as follows: Each pair provides one
    vector and a number. The vector is the |center| anchor of the \meta{node
    name}. The number is the \meta{number}. Note that (currently) you cannot
    specify a different anchor, so that in order to use, say, the |north|
    anchor of a node you first have to create a new coordinate at this north
    anchor. (Using for instance \texttt{\string\coordinate (mynorth) at
    (mynode.north);}.)

    现在，指定的坐标计算如下：每对提供一个向量和一个数字。向量是\meta{node name}的|center|锚点。数字是\meta{number}。请注意（目前）您不能指定不同的锚点，因此为了使用节点的|north|锚点，您首先必须在该北锚点处创建一个新的坐标（例如，使用\texttt{\string\coordinate (mynorth) at (mynode.north);}）。

    %
\begin{codeexample}[]
\begin{tikzpicture}
  \coordinate (content)   at (90:3cm);
  \coordinate (structure) at (210:3cm);
  \coordinate (form)      at (-30:3cm);

  \node [above]       at (content)   {content oriented};
  \node [below left]  at (structure) {structure oriented};
  \node [below right] at (form)      {form oriented};

  \draw [thick,gray] (content.south) -- (structure.north east) -- (form.north west) -- cycle;

  \small
  \node at (barycentric cs:content=0.5,structure=0.1 ,form=1)    {PostScript};
  \node at (barycentric cs:content=1  ,structure=0   ,form=0.4)  {DVI};
  \node at (barycentric cs:content=0.5,structure=0.5 ,form=1)    {PDF};
  \node at (barycentric cs:content=0  ,structure=0.25,form=1)    {CSS};
  \node at (barycentric cs:content=0.5,structure=1   ,form=0)    {XML};
  \node at (barycentric cs:content=0.5,structure=1   ,form=0.4)  {HTML};
  \node at (barycentric cs:content=1  ,structure=0.2 ,form=0.8)  {\TeX};
  \node at (barycentric cs:content=1  ,structure=0.6 ,form=0.8)  {\LaTeX};
  \node at (barycentric cs:content=0.8,structure=0.8 ,form=1)    {Word};
  \node at (barycentric cs:content=1  ,structure=0.05,form=0.05) {ASCII};
\end{tikzpicture}
\end{codeexample}
    %
\end{coordinatesystem}


\subsubsection{Node Coordinate System\\节点坐标系}
\label{section-node-coordinates}

In \pgfname\ and in \tikzname\ it is quite easy to define a node that you wish
to reference at a later point. Once you have defined a node, there are
different ways of referencing points of the node. To do so, you use the
following coordinate system:

在 \pgfname 和 \tikzname 中，定义一个稍后要引用的节点非常容易。一旦定义了一个节点，就有不同的方法来引用节点的点。为此，您可以使用以下坐标系：

\begin{coordinatesystem}{node}
    This coordinate system is used to reference a specific point inside or on
    the border of a previously defined node. It can be used in different ways,
    so let us go over them one by one.

    这个坐标系用于引用先前定义的节点内部或边界上的特定点。它可以以不同的方式使用，我们逐一介绍它们。


    You can use three options to specify which coordinate you mean:
    
    您可以使用三个选项来指定您指的是哪个坐标：
%
    \begin{key}{/tikz/cs/name=\meta{node name}}
        Specifies the node that you wish to use to specify a coordinate. The
        \meta{node name} is the name that was previously used to name the node
        using the |name=|\meta{node name} option or the special node name
        syntax.

        指定您希望用于指定坐标的节点。 \meta{node name}是先前使用|name=|\meta{node name}选项或特殊节点名称语法命名节点时使用的名称。

    \end{key}
    %
    \begin{key}{/tikz/anchor=\meta{anchor}}
        Specifies an anchor of the node. Here is an example:
        %

        指定节点的锚点。以下是一个示例：

\begin{codeexample}[preamble={\usetikzlibrary{arrows.meta}}]
\begin{tikzpicture}
  \node (shape)   at (0,2)  [draw] {|class Shape|};
  \node (rect)    at (-2,0) [draw] {|class Rectangle|};
  \node (circle)  at (2,0)  [draw] {|class Circle|};
  \node (ellipse) at (6,0)  [draw] {|class Ellipse|};

  \draw (node cs:name=circle,anchor=north) |- (0,1);
  \draw (node cs:name=ellipse,anchor=north) |- (0,1);
  \draw [arrows = -{Triangle[open, angle=60:3mm]}]
           (node cs:name=rect,anchor=north)
        |- (0,1) -| (node cs:name=shape,anchor=south);
\end{tikzpicture}
\end{codeexample}
    \end{key}
    %
    \begin{key}{/tikz/cs/angle=\meta{degrees}}
        It is also possible to provide an angle \emph{instead} of an anchor.
        This coordinate refers to a point of the node's border where a ray shot
        from the center in the given angle hits the border. Here is an example:
        
        也可以提供一个角度\emph{而不是}一个锚点。这个坐标是指节点边界上的一个点，从中心以给定角度射出的射线与边界相交的位置。这是一个例子：
        


\begin{codeexample}[preamble={\usetikzlibrary{shapes.geometric}}]
\begin{tikzpicture}
  \node (start) [draw,shape=ellipse] {start};
  \foreach \angle in {-90, -80, ..., 90}
    \draw (node cs:name=start,angle=\angle)
      .. controls +(\angle:1cm) and +(-1,0) .. (2.5,0);
  \end{tikzpicture}
\end{codeexample}
    \end{key}

    It is possible to provide \emph{neither} the |anchor=| option nor the
    |angle=| option. In this case, \tikzname\ will calculate an appropriate
    border position for you. Here is an example:
    
    可以\emph{既不}使用 |anchor=| 选项，也不使用 |angle=| 选项。在这种情况下，\tikzname\ 会为您计算一个适当的边界位置。这是一个例子：
%
\begin{codeexample}[preamble={\usetikzlibrary{shapes.geometric}}]
\begin{tikzpicture}
  \path (0,0)  node(a) [ellipse,rotate=10,draw] {An ellipse}
        (3,-1) node(b) [circle,draw]            {A circle};
  \draw[thick] (node cs:name=a) -- (node cs:name=b);
\end{tikzpicture}
\end{codeexample}

    \tikzname\ will be reasonably clever at determining the border points that
    you ``mean'', but, naturally, this may fail in some situations. If
    \tikzname\ fails to determine an appropriate border point, the center will
    be used instead.

    \tikzname\ 在确定您所“指定”的边界点时会相当聪明，但是自然地，在某些情况下会出现失败。如果\tikzname\ 无法确定适当的边界点，则使用中心点代替。


    Automatic computation of anchors works only with the line-to operations
    |--|, the vertical/horizontal versions \verb!|-! and \verb!-|!, and with
    the curve-to operation |..|. For other path commands, such as |parabola| or
    |plot|, the center will be used. If this is not desired, you should give a
    named anchor or an angle anchor.

    自动计算锚点仅适用于线性操作 |--|，垂直/水平版本 \verb!|-! 和 \verb!-|!，以及曲线操作 |..|。对于其他路径命令（如 |parabola| 或 |plot|），将使用中心点。如果不希望这样，请给出一个命名的锚点或角度锚点。


    Note that if you use an automatic coordinate for both the start and the end
    of a line-to, as in |--(node cs:name=b)--|, then \emph{two} border
    coordinates are computed with a move-to between them. This is usually
    exactly what you want.

    请注意，如果您对一条线段的起点和终点都使用自动坐标，例如 |--(node cs:name=b)--|，则将计算出\emph{两个}边界坐标，并在它们之间进行移动。这通常是您想要的。


    If you use relative coordinates together with automatic anchor coordinates,
    the relative coordinates are computed relative to the node's center, not
    relative to the border point. Here is an example:
    
    如果您同时使用相对坐标和自动锚点坐标，则相对坐标是相对于节点的中心计算的，而不是相对于边界点计算的。这是一个例子：%
\begin{codeexample}[]
\tikz \draw (0,0) node(x) [draw] {Text}
            rectangle (1,1)
            (node cs:name=x) -- +(1,1);
\end{codeexample}

    Similarly, in the following examples both control points are $(1,1)$:
    
    类似地，在以下示例中，两个控制点都是 $(1,1)$：
%
\begin{codeexample}[]
\tikz \draw (0,0) node(x) [draw] {X}
            (2,0) node(y) {Y}
            (node cs:name=x) .. controls +(1,1) and +(-1,1) ..
            (node cs:name=y);
\end{codeexample}

    The implicit way of specifying the node coordinate system is to simply use
    the name of the node in parentheses as in |(a)| or to specify a name
    together with an anchor or an angle separated by a dot as in |(a.north)| or
    |(a.10)|.

    隐式指定节点坐标系统的方法是简单地使用节点的名称，如 |(a)|，或者使用由点分隔的名称和锚点或角度，如 |(a.north)| 或 |(a.10)|。



    Here is a more complete example:

    这是一个更完整的示例：

    %
\begin{codeexample}[preamble={\usetikzlibrary{shapes.geometric}}]
\begin{tikzpicture}[fill=blue!20]
  \draw[help lines] (-1,-2) grid (6,3);
  \path (0,0)  node(a) [ellipse,rotate=10,draw,fill]    {An ellipse}
        (3,-1) node(b) [circle,draw,fill]               {A circle}
        (2,2)  node(c) [rectangle,rotate=20,draw,fill]  {A rectangle}
        (5,2)  node(d) [rectangle,rotate=-30,draw,fill] {Another rectangle};
  \draw[thick] (a.south) -- (b) -- (c) -- (d);
  \draw[thick,red,->] (a) |- +(1,3) -| (c) |- (b);
  \draw[thick,blue,<->] (b) .. controls +(right:2cm) and +(down:1cm) .. (d);
\end{tikzpicture}
\end{codeexample}
    %
\end{coordinatesystem}

% -----------------------------------------------------------------------------
% Deprecated:
% -----------------------------------------------------------------------------
%
\subsubsection{Intersection Coordinate Systems}

Often you wish to specify a point that is on the
intersection of two lines or shapes. For this, the following
coordinate system is useful:

\begin{coordinatesystem}{intersection}
  First, you must specify two objects that should be
  intersected. These ``objects'' can either be lines or the shapes of
  nodes. There are two option to specify the first object:
  \begin{key}{/tikz/cs/first line={\ttfamily\char`\{}|(|\meta{first
          coordinate}|)--(|\meta{second coordinate}|)|{\ttfamily\char`\}}}
    Specifies that the first object is a line that goes from
    \meta{first coordinate} to meta{second coordinate}.
  \end{key}
  Note that you have to write |--| between the coordinate, but this
  does not mean that anything is added to the path. This is simply a
  special syntax.
  \begin{key}{/tikz/cs/first node=\meta{node}}
    Specifies that the first object is a previously defined node named
    \meta{node}.
  \end{key}

  To specify the second object, you use one of the following keys:
  \begin{key}{/tikz/cs/second line={\ttfamily\char`\{}|(|\meta{first
          coordinate}|)--(|\meta{second coordinate}|)|{\ttfamily\char`\}}}
    As above.
  \end{key}
  \begin{key}{/tikz/cs/second node=\meta{node}}
    Specifies that the second object is a previously defined node
    named \meta{node}.
  \end{key}

  Since it is possible that two objects have multiple intersections,
  you may need to specify which solution you want:
  \begin{key}{/tikz/cs/solution=\meta{number} (initially 1)}
    Specifies which solution should be used. Numbering starts with 1.
  \end{key}
  The coordinate specified in this way is the \meta{number}th
  intersection of the two objects.  If the objects do not intersect,
  an error may occur.

\begin{codeexample}[]
\begin{tikzpicture}
  \draw[help lines] (0,0) grid (3,2);
  \draw (0,0) coordinate (A) -- (3,2) coordinate (B)
        (1,2)                -- (3,0);

  \fill[red] (intersection cs:
    first line={(A)--(B)},
    second line={(1,2)--(3,0)}) circle (2pt);
\end{tikzpicture}
\end{codeexample}

  The implicit way of specifying this coordinate system is to write
  \declare{|(intersection |\opt{\meta{number}}| of |\meta{first
      object}%
    | and |\meta{second object}|)|}. Here, \meta{first object} either
  has the form \meta{$p_1$}|--|\meta{$p_2$} or it is just a node
  name. Likewise for \meta{second object}. Note that there are \emph{no}
  parentheses around the $p_i$. Thus, you would write
  |(intersection of A--B and 1,2--3,0)|  for the intersection of the
  line through the coordinates |A| and |B| and the line through the
  points $(1,2)$ and $(3,0)$. You would write
  |(intersection 2 of c_1 and c_2)| for the second
  intersection of the node named |c_1| and the node named
  |c_2|.

  \tikzname\ needs an explicit algorithm for computing the
  intersection of two shapes and such an algorithm is available only
  for few shapes. Currently, the following intersection will be
  computed correctly:
  \begin{itemize}
  \item a line and a line
  \item a |circle| node and a line (in any order)
  \item a |circle| and a |circle|
  \end{itemize}
\begin{codeexample}[]
\begin{tikzpicture}[scale=.25]
  \coordinate [label=-135:$a$] (a) at ($ (0,0)   + (rand,rand) $);
  \coordinate [label=45:$b$]   (b) at ($ (3,2) + (rand,rand) $);

  \coordinate [label=-135:$u$] (u) at (-1,1);
  \coordinate [label=45:$v$]   (v) at (6,0);

  \draw (a) -- (b)
        (u) -- (v);

  \node (c1) at (a) [draw,circle through=(b)] {};
  \node (c2) at (b) [draw,circle through=(a)] {};

  \coordinate [label=135:$c$] (c) at (intersection 2 of c1 and c2);
  \coordinate [label=-45:$d$] (d) at (intersection of u--v and c2);
  \coordinate [label=135:$e$] (e) at (intersection of u--v and a--b);

  \foreach \p in {a,b,c,d,e,u,v}
    \fill [opacity=.5] (\p) circle (8pt);
\end{tikzpicture}
\end{codeexample}
\end{coordinatesystem}
% -----------------------------------------------------------------------------


\subsubsection{Tangent Coordinate Systems}

\begin{coordinatesystem}{tangent}
    This coordinate system, which is available only when the \tikzname\ library
    |calc| is loaded, allows you to compute the point that lies tangent to a
    shape. In detail, consider a \meta{node} and a \meta{point}. Now, draw a
    straight line from the \meta{point} so that it ``touches'' the \meta{node}
    (more formally, so that it is \emph{tangent} to this \meta{node}). The
    point where the line touches the shape is the point referred to by the
    |tangent| coordinate system.

    The following options may be given:
    %
    \begin{key}{/tikz/cs/node=\meta{node}}
        This key specifies the node on whose border the tangent should lie.
    \end{key}
    %
    \begin{key}{/tikz/cs/point=\meta{point}}
        This key specifies the point through which the tangent should go.
    \end{key}
    %
    \begin{key}{/tikz/cs/solution=\meta{number}}
        Specifies which solution should be used if there are more than one.
    \end{key}

    A special algorithm is needed in order to compute the tangent for a given
    shape. Currently, tangents can be computed for nodes whose shape is one of
    the following:
    %
    \begin{itemize}
        \item |coordinate|
        \item |circle|
    \end{itemize}
    %
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw[help lines] (0,0) grid (3,2);

  \coordinate (a) at (3,2);

  \node [circle,draw] (c) at (1,1) [minimum size=40pt] {$c$};

  \draw[red] (a)  -- (tangent cs:node=c,point={(a)},solution=1) --
       (c.center) -- (tangent cs:node=c,point={(a)},solution=2) -- cycle;
\end{tikzpicture}
\end{codeexample}

    There is no implicit syntax for this coordinate system.
\end{coordinatesystem}


\subsubsection{Defining New Coordinate Systems}

While the set of coordinate systems that \tikzname\ can parse via their special
syntax is fixed, it is possible and quite easy to define new explicitly named
coordinate systems. For this, the following commands are used:

\begin{command}{\tikzdeclarecoordinatesystem\marg{name}\marg{code}}
    This command declares a new coordinate system named \meta{name} that can
    later on be used by writing |(|\meta{name}| cs:|\meta{arguments}|)|. When
    \tikzname\ encounters a coordinate specified in this way, the
    \meta{arguments} are passed to \meta{code} as argument |#1|.

    It is now the job of \meta{code} to make sense of the \meta{arguments}. At
    the end of \meta{code}, the two \TeX\ dimensions |\pgf@x| and |\pgf@y|
    should be have the $x$- and $y$-canvas coordinate of the coordinate.

    It is not necessary, but customary, to parse \meta{arguments} using the
    key--value syntax. However, you can also parse it in any way you like.

    In the following example, a coordinate system |cylindrical| is defined.
    %
\begin{codeexample}[]
\makeatletter
\define@key{cylindricalkeys}{angle}{\def\myangle{#1}}
\define@key{cylindricalkeys}{radius}{\def\myradius{#1}}
\define@key{cylindricalkeys}{z}{\def\myz{#1}}
\tikzdeclarecoordinatesystem{cylindrical}%
{%
  \setkeys{cylindricalkeys}{#1}%
  \pgfpointadd{\pgfpointxyz{0}{0}{\myz}}{\pgfpointpolarxy{\myangle}{\myradius}}
}
\begin{tikzpicture}[z=0.2pt]
  \draw [->] (0,0,0) -- (0,0,350);
  \foreach \num in {0,10,...,350}
    \fill (cylindrical cs:angle=\num,radius=1,z=\num) circle (1pt);
\end{tikzpicture}
\end{codeexample}
    %
\end{command}

\begin{command}{\tikzaliascoordinatesystem\marg{new name}\marg{old name}}
    Creates an alias of \meta{old name}.
\end{command}


\subsection{Coordinates at Intersections}
\label{section-intersection-coordinates}

You will wish to compute the intersection of two paths. For the special and
frequent case of two perpendicular lines, a special coordinate system called
|perpendicular| is available. For more general cases, the |intersection|
library can be used.


\subsubsection{Intersections of Perpendicular Lines}

A frequent special case of path intersections is the intersection of a vertical
line going through a point $p$ and a horizontal line going through some other
point $q$. For this situation there is a useful coordinate system.

\begin{coordinatesystem}{perpendicular}
    You can specify the two lines using the following keys:

    \begin{key}{/tikz/cs/horizontal line through={\ttfamily\char`\{}|(|\meta{coordinate}|)|{\ttfamily\char`\}}}
        Specifies that one line is a horizontal line that goes through the
        given coordinate.
    \end{key}
    %
    \begin{key}{/tikz/cs/vertical line through={\ttfamily\char`\{}|(|\meta{coordinate}|)|{\ttfamily\char`\}}}
        Specifies that the other line is vertical and goes through the given
        coordinate.
    \end{key}

    However, in almost all cases you should, instead, use the implicit syntax.
    Here, you write \declare{|(|\meta{p}\verb! |- !\meta{q}|)|} or
    \declare{|(|\meta{q}\verb! -| !\meta{p}|)|}.

    For example, \verb!(2,1 |- 3,4)! and  \verb!(3,4 -| 2,1)! both yield the
    same as \verb!(2,4)! (provided the $xy$-co\-or\-di\-nate system has not
    been modified).

    The most useful application of the syntax is to draw a line up to some
    point on a vertical or horizontal line. Here is an example:
    %
\begin{codeexample}[]
\begin{tikzpicture}
  \path (30:1cm) node(p1) {$p_1$}   (75:1cm) node(p2) {$p_2$};

  \draw (-0.2,0) -- (1.2,0) node(xline)[right] {$q_1$};
  \draw (2,-0.2) -- (2,1.2) node(yline)[above] {$q_2$};

  \draw[->] (p1) -- (p1 |- xline);
  \draw[->] (p2) -- (p2 |- xline);
  \draw[->] (p1) -- (p1 -| yline);
  \draw[->] (p2) -- (p2 -| yline);
\end{tikzpicture}
\end{codeexample}

    Note that in \declare{|(|\meta{c}\verb! |- !\meta{d}|)|} the coordinates
    \meta{c} and \meta{d} are \emph{not} surrounded by parentheses. If they
    need to be complicated expressions (like a computation using the
    |$|-syntax), you must surround them with braces; parentheses will then be   %$
    added around them.

    As an example, let us specify a point that lies horizontally at the middle
    of the line from $A$ to~$B$ and vertically at the middle of the line from
    $C$ to~$D$:
    %
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \node (A) at (0,1)    {A};
  \node (B) at (1,1.5)  {B};
  \node (C) at (2,0)    {C};
  \node (D) at (2.5,-2) {D};

  \draw (A) -- (B) node [midway] {x};
  \draw (C) -- (D) node [midway] {x};

  \node at ({$(A)!.5!(B)$} -| {$(C)!.5!(D)$}) {X};
\end{tikzpicture}
\end{codeexample}
    %
\end{coordinatesystem}


\subsubsection{Intersections of Arbitrary Paths}

\begin{tikzlibrary}{intersections}
    This library enables the calculation of intersections of two arbitrary
    paths. However, due to the low accuracy of \TeX, the paths should not be
    ``too complicated''. In particular, you should not try to intersect paths
    consisting of lots of very small segments such as plots or decorated paths.
\end{tikzlibrary}

To find the intersections of two paths in \tikzname, they must be ``named''. A
``named path'' is, quite simply, a path that has been named using the following
key (note that this is a \emph{different} key from the |name| key, which only
attaches a hyperlink target to a path, but does not store the path in a way the
is useful for the intersection computation):

\begin{keylist}{%
    /tikz/name path=\meta{name},
    /tikz/name path global=\meta{name}%
}
    The effect of this key is that, after the path has been constructed, just
    before it is used, it is associated with \meta{name}. For |name path|, this
    association survives beyond the final semi-colon of the path but not the
    end of the surrounding scope. For |name path global|, the association will
    survive beyond any scope as well. Handle with care.

    Any paths created by nodes on the (main) path are ignored, unless this key
    is explicitly used. If the same \meta{name} is used for the main path and
    the node path(s), then the paths will be added together and then associated
    with \meta{name}.
\end{keylist}

To find the intersection of named paths, the following key is used:

\begin{key}{/tikz/name intersections=\marg{options}}
    This key changes the key path to |/tikz/intersection| and processes
    \meta{options}. These options determine, among other things, which paths to
    use for the intersection. Having processed the options, any intersections
    are then found. A coordinate is created at each intersection, which by
    default, will be named |intersection-1|, |intersection-2|, and so on.
    Optionally, the prefix |intersection| can be changed, and the total number
    of intersections stored in a \TeX-macro.
    %
\begin{codeexample}[preamble={\usetikzlibrary{intersections}}]
\begin{tikzpicture}[every node/.style={opacity=1, black, above left}]
  \draw [help lines] grid (3,2);
  \draw [name path=ellipse] (2,0.5) ellipse (0.75cm and 1cm);
  \draw [name path=rectangle, rotate=10] (0.5,0.5) rectangle +(2,1);
  \fill [red, opacity=0.5, name intersections={of=ellipse and rectangle}]
    (intersection-1) circle (2pt) node {1}
    (intersection-2) circle (2pt) node {2};
\end{tikzpicture}
\end{codeexample}

    The following keys can be used in \meta{options}:

    \begin{key}{/tikz/intersection/of=\meta{name path 1}| and |\meta{name path 2}}
        This key is used to specify the names of the paths to use for the
        intersection.
    \end{key}

    \begin{key}{/tikz/intersection/name=\meta{prefix} (initially intersection)}
        This key specifies the prefix name for the coordinate nodes placed at
        each intersection.
    \end{key}

    \begin{key}{/tikz/intersection/total=\meta{macro}}
        This key means that the total number of intersections found will be
        stored in \meta{macro}.
    \end{key}

\begin{codeexample}[preamble={\usetikzlibrary{intersections}}]
\begin{tikzpicture}
  \clip (-2,-2) rectangle (2,2);
  \draw [name path=curve 1] (-2,-1) .. controls (8,-1) and (-8,1) .. (2,1);
  \draw [name path=curve 2] (-1,-2) .. controls (-1,8) and (1,-8) .. (1,2);

  \fill [name intersections={of=curve 1 and curve 2, name=i, total=\t}]
        [red, opacity=0.5, every node/.style={above left, black, opacity=1}]
        \foreach \s in {1,...,\t}{(i-\s) circle (2pt) node {\footnotesize\s}};
\end{tikzpicture}
\end{codeexample}

    \begin{key}{/tikz/intersection/by=\meta{comma-separated list}}
        This key allows you to specify a list of names for the intersection
        coordinates. The intersection coordinates will still be named
        \meta{prefix}|-|\meta{number}, but additionally the first coordinate
        will also be named by the first element of the \meta{comma-separated
        list}. What happens is that the \meta{comma-separated list} is passed
        to the |\foreach| statement and for \meta{list member} a coordinate is
        created at the already-named intersection.
        %
\begin{codeexample}[preamble={\usetikzlibrary{intersections}}]
\begin{tikzpicture}
  \clip (-2,-2) rectangle (2,2);
  \draw [name path=curve 1] (-2,-1) .. controls (8,-1) and (-8,1) .. (2,1);
  \draw [name path=curve 2] (-1,-2) .. controls (-1,8) and (1,-8) .. (1,2);

  \fill [name intersections={of=curve 1 and curve 2, by={a,b}}]
        (a) circle (2pt)
        (b) circle (2pt);
\end{tikzpicture}
\end{codeexample}

        You can also use the |...| notation of the |\foreach| statement inside
        the \meta{comma-separated list}.

        In case an element of the \meta{comma-separated list} starts with
        options in square brackets, these options are used when the coordinate
        is created. A coordinate name can still, but need not, follow the
        options. This makes it easy to add labels to intersections:
        %
\begin{codeexample}[preamble={\usetikzlibrary{intersections}}]
\begin{tikzpicture}
  \clip (-2,-2) rectangle (2,2);
  \draw [name path=curve 1] (-2,-1) .. controls (8,-1) and (-8,1) .. (2,1);
  \draw [name path=curve 2] (-1,-2) .. controls (-1,8) and (1,-8) .. (1,2);

  \fill [name intersections={
          of=curve 1 and curve 2,
          by={[label=center:a],[label=center:...],[label=center:i]}}];
\end{tikzpicture}
\end{codeexample}
    \end{key}

    \begin{key}{/tikz/intersection/sort by=\meta{path name}}
        By default, the intersections are simply returned in the order that the
        intersection algorithm finds them. Unfortunately, this is not
        necessarily a ``helpful'' ordering. This key can be used to sort the
        intersections along the path specified by \meta{path name}, which
        should be one of the paths mentioned in the |/tikz/intersection/of|
        key.
        %
\begin{codeexample}[preamble={\usetikzlibrary{intersections}}]
\begin{tikzpicture}
\clip (-0.5,-0.75) rectangle (3.25,2.25);
\foreach \pathname/\shift in {line/0cm, curve/2cm}{
  \tikzset{xshift=\shift}
  \draw [->, name path=curve] (1,1.5) .. controls (-1,1) and (2,0.5) .. (0,0);
  \draw [->, name path=line]  (0,-.5) -- (1,2) ;
  \fill [name intersections={of=line and curve,sort by=\pathname, name=i}]
    [red, opacity=0.5, every node/.style={left=.25cm, black, opacity=1}]
    \foreach \s in {1,2,3}{(i-\s) circle (2pt) node {\footnotesize\s}};
}
\end{tikzpicture}
\end{codeexample}
    \end{key}
\end{key}


\subsection{Relative and Incremental Coordinates}

\subsubsection{Specifying Relative Coordinates}

You can prefix coordinates by |++| to make them ``relative''. A coordinate such
as |++(1cm,0pt)| means ``1cm to the right of the previous position, making this
the new current position''. Relative coordinates are often useful in ``local''
contexts:
%
\begin{codeexample}[]
\begin{tikzpicture}
  \draw (0,0)     -- ++(1,0) -- ++(0,1) -- ++(-1,0) -- cycle;
  \draw (2,0)     -- ++(1,0) -- ++(0,1) -- ++(-1,0) -- cycle;
  \draw (1.5,1.5) -- ++(1,0) -- ++(0,1) -- ++(-1,0) -- cycle;
\end{tikzpicture}
\end{codeexample}

Instead of |++| you can also use a single |+|. This also specifies a relative
coordinate, but it does not ``update'' the current point for subsequent usages
of relative coordinates. Thus, you can use this notation to specify numerous
points, all relative to the same ``initial'' point:

\begin{codeexample}[]
\begin{tikzpicture}
  \draw (0,0)     -- +(1,0) -- +(1,1) -- +(0,1) -- cycle;
  \draw (2,0)     -- +(1,0) -- +(1,1) -- +(0,1) -- cycle;
  \draw (1.5,1.5) -- +(1,0) -- +(1,1) -- +(0,1) -- cycle;
\end{tikzpicture}
\end{codeexample}

There is a special situation, where relative coordinates are interpreted
differently. If you use a relative coordinate as a control point of a Bézier
curve, the following rule applies: First, a relative first control point is
taken relative to the beginning of the curve. Second, a relative second control
point is taken relative to the end of the curve. Third, a relative end point of
a curve is taken relative to the start of the curve.

This special behavior makes it easy to specify that a curve should ``leave or
arrive from a certain direction'' at the start or end. In the following
example, the curve ``leaves'' at $30^\circ$ and ``arrives'' at $60^\circ$:
%
\begin{codeexample}[]
\begin{tikzpicture}
  \draw (1,0) .. controls +(30:1cm) and +(60:1cm) .. (3,-1);
  \draw[gray,->] (1,0) -- +(30:1cm);
  \draw[gray,<-] (3,-1) -- +(60:1cm);
\end{tikzpicture}
\end{codeexample}


\subsubsection{Rotational Relative Coordinates}

You may sometimes wish to specify points relative not only to the previous
point, but additionally relative to the tangent entering the previous point.
For this, the following key is useful:

\begin{key}{/tikz/turn}
    This key can be given as an option to a \meta{coordinate} as in the
    following example:
    %
\begin{codeexample}[]
\tikz \draw (0,0) -- (1,1) -- ([turn]-45:1cm) -- ([turn]-30:1cm);
\end{codeexample}
    %
    The effect of this key is to locally shift the coordinate system so that
    the last point reached is at the origin and the coordinate system is
    ``turned'' so that the $x$-axis points in the direction of a tangent
    entering the last point. This means, in effect, that when you use polar
    coordinates of the form \meta{relative angle}|:|\meta{distance} together
    with the |turn| option, you specify a point that lies at \meta{distance}
    from the last point in the direction of the last tangent entering the last
    point, but with a rotation of \meta{relative angle}.

    This key also works with curves \dots
    %
\begin{codeexample}[]
\tikz [delta angle=30, radius=1cm]
  \draw (0,0) arc [start angle=0]  -- ([turn]0:1cm)
              arc [start angle=30] -- ([turn]0:1cm)
              arc [start angle=60] -- ([turn]30:1cm);
\end{codeexample}
\begin{codeexample}[]
\tikz \draw (0,0) to [bend left] (2,1) -- ([turn]0:1cm);
\end{codeexample}
    %
    \dots and with plots \dots
    %
\begin{codeexample}[]
\tikz \draw plot coordinates {(0,0) (1,1) (2,0) (3,0) } -- ([turn]30:1cm);
\end{codeexample}

    Although the above examples use polar coordinates with |turn|, you can also
    use any normal coordinate. For instance, |([turn]1,1)| will append a line
    of length $\sqrt 2$ that is turns by $45^\circ$ relative to the tangent to
    the last point.
    %
\begin{codeexample}[]
\tikz \draw (0.5,0.5) -| (2,1) -- ([turn]1,1)
         .. controls ([turn]0:1cm) .. ([turn]-90:1cm);
\end{codeexample}
    %
\end{key}


\subsubsection{Relative Coordinates and Scopes}
\label{section-scopes-relative}

An interesting question is, how do relative coordinates behave in the presence
of scopes? That is, suppose we use curly braces in a path to make part of it
``local'', how does that affect the current position? On the one hand, the
current position certainly changes since the scope only affects options, not
the path itself. On the other hand, it may be useful to ``temporarily escape''
from the updating of the current point.

Since both interpretations of how the current point and scopes should
``interact'' are useful, there is a (local!) option that allows you to decide
which you need.

\begin{key}{/tikz/current point is local=\opt{\meta{boolean}} (initially false)}
    Normally, the scope path operation has no effect on the current point. That
    is, curly braces on a path have no effect on the current position:
    %
\begin{codeexample}[]
\begin{tikzpicture}
  \draw      (0,0) -- ++(1,0)   -- ++(0,1)   -- ++(-1,0);
  \draw[red] (2,0) -- ++(1,0) { -- ++(0,1) } -- ++(-1,0);
\end{tikzpicture}
\end{codeexample}
    %
    If you set this key to |true|, this behavior changes. In this case, at the
    end of a group created on a path, the last current position reverts to
    whatever value it had at the beginning of the scope. More precisely, when
    \tikzname\ encounters |}| on a path, it checks whether at this particular
    moment the key is set to |true|. If so, the current position reverts to the
    value it had when the matching |{| was read.
    %
\begin{codeexample}[]
\begin{tikzpicture}
  \draw      (0,0) -- ++(1,0)   -- ++(0,1)   -- ++(-1,0);
  \draw[red] (2,0) -- ++(1,0)
     { [current point is local] -- ++(0,1) } -- ++(-1,0);
\end{tikzpicture}
\end{codeexample}
    %
    In the above example, we could also have given the option outside the
    scope, for instance as a parameter to the whole scope.
\end{key}


\subsection{Coordinate Calculations}
\label{tikz-lib-calc}

\begin{tikzlibrary}{calc}
    You need to load this library in order to use the coordinate calculation
    functions described in the present section.
\end{tikzlibrary}

It is possible to do some basic calculations that involve coordinates. In
essence, you can add and subtract coordinates, scale them, compute midpoints,
and do projections. For instance, |($(a) + 1/3*(1cm,0)$)| is the coordinate
that is $1/3 \text{cm}$ to the right of the point |a|:
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);

  \node (a) at (1,1) {A};
  \fill [red] ($(a) + 1/3*(1cm,0)$) circle (2pt);
\end{tikzpicture}
\end{codeexample}


\subsubsection{The General Syntax}

The general syntax is the following:
%
\begin{quote}
    \declare{|(|\opt{|[|\meta{options}|]|}|$|\meta{coordinate computation}|$)|}.
\end{quote}

As you can see, the syntax uses the \TeX\ math symbol |$| to %$
indicate that a ``mathematical computation'' is involved. However, the |$| %$
has no other effect, in particular, no mathematical text is typeset.

The \meta{coordinate computation} has the following structure:
%
\begin{enumerate}
    \item It starts with
        %
        \begin{quote}
            \opt{\meta{factor}|*|}\meta{coordinate}\opt{\meta{modifiers}}
        \end{quote}
    \item This is optionally followed by |+| or |-| and then another
        %
        \begin{quote}
            \opt{\meta{factor}|*|}\meta{coordinate}\opt{\meta{modifiers}}
        \end{quote}
    \item This is once more followed by |+| or |-| and another of the above
        modified coordinate; and so on.
\end{enumerate}

In the following, the syntax of factors and of the different modifiers
is explained in detail.


\subsubsection{The Syntax of Factors}

The \meta{factor}s are optional and detected by checking whether the
\meta{coordinate computation} starts with a |(|. Also, after each $\pm$ a
\meta{factor} is present if, and only if, the |+| or |-| sign is not directly
followed by~|(|.

If a \meta{factor} is present, it is evaluated using the |\pgfmathparse| macro.
This means that you can use pretty complicated computations inside a factor. A
\meta{factor} may even contain opening parentheses, which creates a
complication: How does \tikzname\ know where a \meta{factor} ends and where a
coordinate starts? For instance, if the beginning of a \meta{coordinate
computation} is |2*(3+4|\dots, it is not clear whether |3+4| is part of a
\meta{coordinate} or part of a \meta{factor}. Because of this, the following
rule is used: Once it has been determined, that a \meta{factor} is present, in
principle, the \meta{factor} contains everything up to the next occurrence of
|*(|. Note that there is no space between the asterisk and the parenthesis.

It is permissible to put the \meta{factor} in curly braces. This can be used
whenever it is unclear where the \meta{factor} would end.

Here are some examples of coordinate specifications that consist of exactly one
\meta{factor} and one \meta{coordinate}:
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);

  \fill [red] ($2*(1,1)$) circle (2pt);
  \fill [green] (${1+1}*(1,.5)$) circle (2pt);
  \fill [blue] ($cos(0)*sin(90)*(1,1)$) circle (2pt);
  \fill [black] (${3*(4-3)}*(1,0.5)$) circle (2pt);
\end{tikzpicture}
\end{codeexample}


\subsubsection{The Syntax of Partway Modifiers}

A \meta{coordinate} can be followed by different \meta{modifiers}. The first
kind of modifier is the \emph{partway modifier}. The syntax (which is loosely
inspired by Uwe Kern's |xcolor| package) is the following:
%
\begin{quote}
    \meta{coordinate}\declare{|!|\meta{number}|!|\opt{\meta{angle}|:|}\meta{second coordinate}}
\end{quote}
%
One could write for instance
%
\begin{codeexample}[code only]
(1,2)!.75!(3,4)
\end{codeexample}
%
The meaning of this is: ``Use the coordinate that is three quarters on the way
from |(1,2)| to |(3,4)|.'' In general, \meta{coordinate
x}|!|\meta{number}|!|\meta{coordinate y} yields the coordinate $(1 -
\meta{number})\meta{coordinate x} + \meta{number} \meta{coordinate y}$. Note
that this is a bit different from the way the \meta{number} is interpreted in
the |xcolor| package: First, you use a factor between $0$ and $1$, not a
percentage, and, second, as the \meta{number} approaches $1$, we approach the
second coordinate, not the first. It is permissible to use a \meta{number} that
is smaller than $0$ or larger than $1$. The \meta{number} is evaluated using
the |\pgfmathparse| command and, thus, it can involve complicated computations.
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);

  \draw (1,0) -- (3,2);

  \foreach \i in {0,0.2,0.5,0.9,1}
    \node at ($(1,0)!\i!(3,2)$) {\i};
\end{tikzpicture}
\end{codeexample}

The \meta{second coordinate} may be prefixed by an \meta{angle}, separated with
a colon, as in |(1,1)!.5!60:(2,2)|. The general meaning of
\meta{a}|!|\meta{factor}|!|\meta{angle}|:|\meta{b} is: ``First, consider the
line from \meta{a} to \meta{b}. Then rotate this line by \meta{angle}
\emph{around the point \meta{a}}. Then the two endpoints of this line will be
\meta{a} and some point \meta{c}. Use this point \meta{c} for the subsequent
computation, namely the partway computation.''

Here are two examples:
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,3);

  \coordinate (a) at (1,0);
  \coordinate (b) at (3,2);

  \draw[->] (a) -- (b);

  \coordinate (c) at ($ (a)!1! 10:(b) $);

  \draw[->,red] (a) -- (c);

  \fill ($ (a)!.5! 10:(b) $) circle (2pt);
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (4,4);

  \foreach \i in {0,0.1,...,2}
    \fill ($(2,2) !\i! \i*180:(3,2)$) circle (2pt);
\end{tikzpicture}
\end{codeexample}

You can repeatedly apply modifiers. That is, after any modifier you can add
another (possibly different) modifier.
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);

  \draw (0,0) -- (3,2);
  \draw[red] ($(0,0)!.3!(3,2)$) -- (3,0);
  \fill[red] ($(0,0)!.3!(3,2)!.7!(3,0)$) circle (2pt);
\end{tikzpicture}
\end{codeexample}


\subsubsection{The Syntax of Distance Modifiers}

A \emph{distance modifier} has nearly the same syntax as a partway modifier,
only you use a \meta{dimension} (something like |1cm|) instead of a
\meta{factor} (something like |0.5|):
%
\begin{quote}
    \meta{coordinate}\declare{|!|\meta{dimension}|!|\opt{\meta{angle}|:|}\meta{second coordinate}}
\end{quote}

When you write \meta{a}|!|\meta{dimension}|!|\meta{b}, this means the
following: Use the point that is distanced \meta{dimension} from \meta{a} on
the straight line from \meta{a} to \meta{b}. Here is an example:
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);

  \draw (1,0) -- (3,2);

  \foreach \i in {0cm,1cm,15mm}
    \node at ($(1,0)!\i!(3,2)$) {\i};
\end{tikzpicture}
\end{codeexample}

As before, if you use a \meta{angle}, the \meta{second coordinate} is rotated
by this much around the \meta{coordinate} before it is used.

The combination of an \meta{angle} of |90| degrees with a distance can be used
to ``offset'' a point relative to a line. Suppose, for instance, that you have
computed a point |(c)| that lies somewhere on a line from |(a)| to~|(b)| and
you now wish to offset this point by |1cm| so that the distance from this
offset point to the line is |1cm|. This can be achieved as follows:
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);

  \coordinate (a) at (1,0);
  \coordinate (b) at (3,1);

  \draw (a) -- (b);

  \coordinate (c) at ($ (a)!.25!(b) $);
  \coordinate (d) at ($ (c)!1cm!90:(b) $);

  \draw [<->] (c) -- (d) node [sloped,midway,above] {1cm};
\end{tikzpicture}
\end{codeexample}


\subsubsection{The Syntax of Projection Modifiers}

The projection modifier is also similar to the above modifiers: It also gives a
point on a line from the \meta{coordinate} to the \meta{second coordinate}.
However, the \meta{number} or \meta{dimension} is replaced by a
\meta{projection coordinate}:
%
\begin{quote}
    \meta{coordinate}\declare{|!|\meta{projection coordinate}|!|\opt{\meta{angle}|:|}\meta{second coordinate}}
\end{quote}

Here is an example:
%
\begin{codeexample}[code only]
(1,2)!(0,5)!(3,4)
\end{codeexample}

The effect is the following: We project the \meta{projection coordinate}
orthogonally onto the line from \meta{coordinate} to \meta{second coordinate}.
This makes it easy to compute projected points:
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);

  \coordinate (a) at (0,1);
  \coordinate (b) at (3,2);
  \coordinate (c) at (2.5,0);

  \draw (a) -- (b) -- (c) -- cycle;

  \draw[red]    (a) -- ($(b)!(a)!(c)$);
  \draw[orange] (b) -- ($(a)!(b)!(c)$);
  \draw[blue]   (c) -- ($(a)!(c)!(b)$);
\end{tikzpicture}
\end{codeexample}
