
\subsubsection{Node Coordinate System\\节点坐标系}
\label{section-node-coordinates}

In \pgfname\ and in \tikzname\ it is quite easy to define a node that you wish
to reference at a later point. Once you have defined a node, there are
different ways of referencing points of the node. To do so, you use the
following coordinate system:

在 \pgfname 和 \tikzname 中，定义一个稍后要引用的节点非常容易。一旦定义了一个节点，就有不同的方法来引用节点的点。为此，您可以使用以下坐标系：

\begin{coordinatesystem}{node}
    This coordinate system is used to reference a specific point inside or on
    the border of a previously defined node. It can be used in different ways,
    so let us go over them one by one.

    这个坐标系用于引用先前定义的节点内部或边界上的特定点。它可以以不同的方式使用，我们逐一介绍它们。


    You can use three options to specify which coordinate you mean:
    
    您可以使用三个选项来指定您指的是哪个坐标：
%
    \begin{key}{/tikz/cs/name=\meta{node name}}
        Specifies the node that you wish to use to specify a coordinate. The
        \meta{node name} is the name that was previously used to name the node
        using the |name=|\meta{node name} option or the special node name
        syntax.

        指定您希望用于指定坐标的节点。 \meta{node name}是先前使用|name=|\meta{node name}选项或特殊节点名称语法命名节点时使用的名称。

    \end{key}
    %
    \begin{key}{/tikz/anchor=\meta{anchor}}
        Specifies an anchor of the node. Here is an example:
        %

        指定节点的锚点。以下是一个示例：

\begin{codeexample}[preamble={\usetikzlibrary{arrows.meta}}]
\begin{tikzpicture}
  \node (shape)   at (0,2)  [draw] {|class Shape|};
  \node (rect)    at (-2,0) [draw] {|class Rectangle|};
  \node (circle)  at (2,0)  [draw] {|class Circle|};
  \node (ellipse) at (6,0)  [draw] {|class Ellipse|};

  \draw (node cs:name=circle,anchor=north) |- (0,1);
  \draw (node cs:name=ellipse,anchor=north) |- (0,1);
  \draw [arrows = -{Triangle[open, angle=60:3mm]}]
           (node cs:name=rect,anchor=north)
        |- (0,1) -| (node cs:name=shape,anchor=south);
\end{tikzpicture}
\end{codeexample}
    \end{key}
    %
    \begin{key}{/tikz/cs/angle=\meta{degrees}}
        It is also possible to provide an angle \emph{instead} of an anchor.
        This coordinate refers to a point of the node's border where a ray shot
        from the center in the given angle hits the border. Here is an example:
        
        也可以提供一个角度\emph{而不是}一个锚点。这个坐标是指节点边界上的一个点，从中心以给定角度射出的射线与边界相交的位置。这是一个例子：
        


\begin{codeexample}[preamble={\usetikzlibrary{shapes.geometric}}]
\begin{tikzpicture}
  \node (start) [draw,shape=ellipse] {start};
  \foreach \angle in {-90, -80, ..., 90}
    \draw (node cs:name=start,angle=\angle)
      .. controls +(\angle:1cm) and +(-1,0) .. (2.5,0);
  \end{tikzpicture}
\end{codeexample}
    \end{key}

    It is possible to provide \emph{neither} the |anchor=| option nor the
    |angle=| option. In this case, \tikzname\ will calculate an appropriate
    border position for you. Here is an example:
    
    可以\emph{既不}使用 |anchor=| 选项，也不使用 |angle=| 选项。在这种情况下，\tikzname\ 会为您计算一个适当的边界位置。这是一个例子：
%
\begin{codeexample}[preamble={\usetikzlibrary{shapes.geometric}}]
\begin{tikzpicture}
  \path (0,0)  node(a) [ellipse,rotate=10,draw] {An ellipse}
        (3,-1) node(b) [circle,draw]            {A circle};
  \draw[thick] (node cs:name=a) -- (node cs:name=b);
\end{tikzpicture}
\end{codeexample}

    \tikzname\ will be reasonably clever at determining the border points that
    you ``mean'', but, naturally, this may fail in some situations. If
    \tikzname\ fails to determine an appropriate border point, the center will
    be used instead.

    \tikzname\ 在确定您所“指定”的边界点时会相当聪明，但是自然地，在某些情况下会出现失败。如果\tikzname\ 无法确定适当的边界点，则使用中心点代替。


    Automatic computation of anchors works only with the line-to operations
    |--|, the vertical/horizontal versions \verb!|-! and \verb!-|!, and with
    the curve-to operation |..|. For other path commands, such as |parabola| or
    |plot|, the center will be used. If this is not desired, you should give a
    named anchor or an angle anchor.

    自动计算锚点仅适用于线性操作 |--|，垂直/水平版本 \verb!|-! 和 \verb!-|!，以及曲线操作 |..|。对于其他路径命令（如 |parabola| 或 |plot|），将使用中心点。如果不希望这样，请给出一个命名的锚点或角度锚点。


    Note that if you use an automatic coordinate for both the start and the end
    of a line-to, as in |--(node cs:name=b)--|, then \emph{two} border
    coordinates are computed with a move-to between them. This is usually
    exactly what you want.

    请注意，如果您对一条线段的起点和终点都使用自动坐标，例如 |--(node cs:name=b)--|，则将计算出\emph{两个}边界坐标，并在它们之间进行移动。这通常是您想要的。


    If you use relative coordinates together with automatic anchor coordinates,
    the relative coordinates are computed relative to the node's center, not
    relative to the border point. Here is an example:
    
    如果您同时使用相对坐标和自动锚点坐标，则相对坐标是相对于节点的中心计算的，而不是相对于边界点计算的。这是一个例子：%
\begin{codeexample}[]
\tikz \draw (0,0) node(x) [draw] {Text}
            rectangle (1,1)
            (node cs:name=x) -- +(1,1);
\end{codeexample}

    Similarly, in the following examples both control points are $(1,1)$:
    
    类似地，在以下示例中，两个控制点都是 $(1,1)$：
%
\begin{codeexample}[]
\tikz \draw (0,0) node(x) [draw] {X}
            (2,0) node(y) {Y}
            (node cs:name=x) .. controls +(1,1) and +(-1,1) ..
            (node cs:name=y);
\end{codeexample}

    The implicit way of specifying the node coordinate system is to simply use
    the name of the node in parentheses as in |(a)| or to specify a name
    together with an anchor or an angle separated by a dot as in |(a.north)| or
    |(a.10)|.

    隐式指定节点坐标系统的方法是简单地使用节点的名称，如 |(a)|，或者使用由点分隔的名称和锚点或角度，如 |(a.north)| 或 |(a.10)|。



    Here is a more complete example:

    这是一个更完整的示例：

    %
\begin{codeexample}[preamble={\usetikzlibrary{shapes.geometric}}]
\begin{tikzpicture}[fill=blue!20]
  \draw[help lines] (-1,-2) grid (6,3);
  \path (0,0)  node(a) [ellipse,rotate=10,draw,fill]    {An ellipse}
        (3,-1) node(b) [circle,draw,fill]               {A circle}
        (2,2)  node(c) [rectangle,rotate=20,draw,fill]  {A rectangle}
        (5,2)  node(d) [rectangle,rotate=-30,draw,fill] {Another rectangle};
  \draw[thick] (a.south) -- (b) -- (c) -- (d);
  \draw[thick,red,->] (a) |- +(1,3) -| (c) |- (b);
  \draw[thick,blue,<->] (b) .. controls +(right:2cm) and +(down:1cm) .. (d);
\end{tikzpicture}
\end{codeexample}
    %
\end{coordinatesystem}

% -----------------------------------------------------------------------------
% Deprecated:
% -----------------------------------------------------------------------------
%
\subsubsection{Intersection Coordinate Systems}

Often you wish to specify a point that is on the
intersection of two lines or shapes. For this, the following
coordinate system is useful:

\begin{coordinatesystem}{intersection}
  First, you must specify two objects that should be
  intersected. These ``objects'' can either be lines or the shapes of
  nodes. There are two option to specify the first object:
  \begin{key}{/tikz/cs/first line={\ttfamily\char`\{}|(|\meta{first
          coordinate}|)--(|\meta{second coordinate}|)|{\ttfamily\char`\}}}
    Specifies that the first object is a line that goes from
    \meta{first coordinate} to meta{second coordinate}.
  \end{key}
  Note that you have to write |--| between the coordinate, but this
  does not mean that anything is added to the path. This is simply a
  special syntax.
  \begin{key}{/tikz/cs/first node=\meta{node}}
    Specifies that the first object is a previously defined node named
    \meta{node}.
  \end{key}

  To specify the second object, you use one of the following keys:
  \begin{key}{/tikz/cs/second line={\ttfamily\char`\{}|(|\meta{first
          coordinate}|)--(|\meta{second coordinate}|)|{\ttfamily\char`\}}}
    As above.
  \end{key}
  \begin{key}{/tikz/cs/second node=\meta{node}}
    Specifies that the second object is a previously defined node
    named \meta{node}.
  \end{key}

  Since it is possible that two objects have multiple intersections,
  you may need to specify which solution you want:
  \begin{key}{/tikz/cs/solution=\meta{number} (initially 1)}
    Specifies which solution should be used. Numbering starts with 1.
  \end{key}
  The coordinate specified in this way is the \meta{number}th
  intersection of the two objects.  If the objects do not intersect,
  an error may occur.

\begin{codeexample}[]
\begin{tikzpicture}
  \draw[help lines] (0,0) grid (3,2);
  \draw (0,0) coordinate (A) -- (3,2) coordinate (B)
        (1,2)                -- (3,0);

  \fill[red] (intersection cs:
    first line={(A)--(B)},
    second line={(1,2)--(3,0)}) circle (2pt);
\end{tikzpicture}
\end{codeexample}

  The implicit way of specifying this coordinate system is to write
  \declare{|(intersection |\opt{\meta{number}}| of |\meta{first
      object}%
    | and |\meta{second object}|)|}. Here, \meta{first object} either
  has the form \meta{$p_1$}|--|\meta{$p_2$} or it is just a node
  name. Likewise for \meta{second object}. Note that there are \emph{no}
  parentheses around the $p_i$. Thus, you would write
  |(intersection of A--B and 1,2--3,0)|  for the intersection of the
  line through the coordinates |A| and |B| and the line through the
  points $(1,2)$ and $(3,0)$. You would write
  |(intersection 2 of c_1 and c_2)| for the second
  intersection of the node named |c_1| and the node named
  |c_2|.

  \tikzname\ needs an explicit algorithm for computing the
  intersection of two shapes and such an algorithm is available only
  for few shapes. Currently, the following intersection will be
  computed correctly:
  \begin{itemize}
  \item a line and a line
  \item a |circle| node and a line (in any order)
  \item a |circle| and a |circle|
  \end{itemize}
\begin{codeexample}[]
\begin{tikzpicture}[scale=.25]
  \coordinate [label=-135:$a$] (a) at ($ (0,0)   + (rand,rand) $);
  \coordinate [label=45:$b$]   (b) at ($ (3,2) + (rand,rand) $);

  \coordinate [label=-135:$u$] (u) at (-1,1);
  \coordinate [label=45:$v$]   (v) at (6,0);

  \draw (a) -- (b)
        (u) -- (v);

  \node (c1) at (a) [draw,circle through=(b)] {};
  \node (c2) at (b) [draw,circle through=(a)] {};

  \coordinate [label=135:$c$] (c) at (intersection 2 of c1 and c2);
  \coordinate [label=-45:$d$] (d) at (intersection of u--v and c2);
  \coordinate [label=135:$e$] (e) at (intersection of u--v and a--b);

  \foreach \p in {a,b,c,d,e,u,v}
    \fill [opacity=.5] (\p) circle (8pt);
\end{tikzpicture}
\end{codeexample}
\end{coordinatesystem}
% -----------------------------------------------------------------------------


\subsubsection{Tangent Coordinate Systems}

\begin{coordinatesystem}{tangent}
    This coordinate system, which is available only when the \tikzname\ library
    |calc| is loaded, allows you to compute the point that lies tangent to a
    shape. In detail, consider a \meta{node} and a \meta{point}. Now, draw a
    straight line from the \meta{point} so that it ``touches'' the \meta{node}
    (more formally, so that it is \emph{tangent} to this \meta{node}). The
    point where the line touches the shape is the point referred to by the
    |tangent| coordinate system.

    The following options may be given:
    %
    \begin{key}{/tikz/cs/node=\meta{node}}
        This key specifies the node on whose border the tangent should lie.
    \end{key}
    %
    \begin{key}{/tikz/cs/point=\meta{point}}
        This key specifies the point through which the tangent should go.
    \end{key}
    %
    \begin{key}{/tikz/cs/solution=\meta{number}}
        Specifies which solution should be used if there are more than one.
    \end{key}

    A special algorithm is needed in order to compute the tangent for a given
    shape. Currently, tangents can be computed for nodes whose shape is one of
    the following:
    %
    \begin{itemize}
        \item |coordinate|
        \item |circle|
    \end{itemize}
    %
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw[help lines] (0,0) grid (3,2);

  \coordinate (a) at (3,2);

  \node [circle,draw] (c) at (1,1) [minimum size=40pt] {$c$};

  \draw[red] (a)  -- (tangent cs:node=c,point={(a)},solution=1) --
       (c.center) -- (tangent cs:node=c,point={(a)},solution=2) -- cycle;
\end{tikzpicture}
\end{codeexample}

    There is no implicit syntax for this coordinate system.
\end{coordinatesystem}


\subsubsection{Defining New Coordinate Systems}

While the set of coordinate systems that \tikzname\ can parse via their special
syntax is fixed, it is possible and quite easy to define new explicitly named
coordinate systems. For this, the following commands are used:

\begin{command}{\tikzdeclarecoordinatesystem\marg{name}\marg{code}}
    This command declares a new coordinate system named \meta{name} that can
    later on be used by writing |(|\meta{name}| cs:|\meta{arguments}|)|. When
    \tikzname\ encounters a coordinate specified in this way, the
    \meta{arguments} are passed to \meta{code} as argument |#1|.

    It is now the job of \meta{code} to make sense of the \meta{arguments}. At
    the end of \meta{code}, the two \TeX\ dimensions |\pgf@x| and |\pgf@y|
    should be have the $x$- and $y$-canvas coordinate of the coordinate.

    It is not necessary, but customary, to parse \meta{arguments} using the
    key--value syntax. However, you can also parse it in any way you like.

    In the following example, a coordinate system |cylindrical| is defined.
    %
\begin{codeexample}[]
\makeatletter
\define@key{cylindricalkeys}{angle}{\def\myangle{#1}}
\define@key{cylindricalkeys}{radius}{\def\myradius{#1}}
\define@key{cylindricalkeys}{z}{\def\myz{#1}}
\tikzdeclarecoordinatesystem{cylindrical}%
{%
  \setkeys{cylindricalkeys}{#1}%
  \pgfpointadd{\pgfpointxyz{0}{0}{\myz}}{\pgfpointpolarxy{\myangle}{\myradius}}
}
\begin{tikzpicture}[z=0.2pt]
  \draw [->] (0,0,0) -- (0,0,350);
  \foreach \num in {0,10,...,350}
    \fill (cylindrical cs:angle=\num,radius=1,z=\num) circle (1pt);
\end{tikzpicture}
\end{codeexample}
    %
\end{command}

\begin{command}{\tikzaliascoordinatesystem\marg{new name}\marg{old name}}
    Creates an alias of \meta{old name}.
\end{command}


\subsection{Coordinates at Intersections}
\label{section-intersection-coordinates}

You will wish to compute the intersection of two paths. For the special and
frequent case of two perpendicular lines, a special coordinate system called
|perpendicular| is available. For more general cases, the |intersection|
library can be used.


\subsubsection{Intersections of Perpendicular Lines}

A frequent special case of path intersections is the intersection of a vertical
line going through a point $p$ and a horizontal line going through some other
point $q$. For this situation there is a useful coordinate system.

\begin{coordinatesystem}{perpendicular}
    You can specify the two lines using the following keys:

    \begin{key}{/tikz/cs/horizontal line through={\ttfamily\char`\{}|(|\meta{coordinate}|)|{\ttfamily\char`\}}}
        Specifies that one line is a horizontal line that goes through the
        given coordinate.
    \end{key}
    %
    \begin{key}{/tikz/cs/vertical line through={\ttfamily\char`\{}|(|\meta{coordinate}|)|{\ttfamily\char`\}}}
        Specifies that the other line is vertical and goes through the given
        coordinate.
    \end{key}

    However, in almost all cases you should, instead, use the implicit syntax.
    Here, you write \declare{|(|\meta{p}\verb! |- !\meta{q}|)|} or
    \declare{|(|\meta{q}\verb! -| !\meta{p}|)|}.

    For example, \verb!(2,1 |- 3,4)! and  \verb!(3,4 -| 2,1)! both yield the
    same as \verb!(2,4)! (provided the $xy$-co\-or\-di\-nate system has not
    been modified).

    The most useful application of the syntax is to draw a line up to some
    point on a vertical or horizontal line. Here is an example:
    %
\begin{codeexample}[]
\begin{tikzpicture}
  \path (30:1cm) node(p1) {$p_1$}   (75:1cm) node(p2) {$p_2$};

  \draw (-0.2,0) -- (1.2,0) node(xline)[right] {$q_1$};
  \draw (2,-0.2) -- (2,1.2) node(yline)[above] {$q_2$};

  \draw[->] (p1) -- (p1 |- xline);
  \draw[->] (p2) -- (p2 |- xline);
  \draw[->] (p1) -- (p1 -| yline);
  \draw[->] (p2) -- (p2 -| yline);
\end{tikzpicture}
\end{codeexample}

    Note that in \declare{|(|\meta{c}\verb! |- !\meta{d}|)|} the coordinates
    \meta{c} and \meta{d} are \emph{not} surrounded by parentheses. If they
    need to be complicated expressions (like a computation using the
    |$|-syntax), you must surround them with braces; parentheses will then be   %$
    added around them.

    As an example, let us specify a point that lies horizontally at the middle
    of the line from $A$ to~$B$ and vertically at the middle of the line from
    $C$ to~$D$:
    %
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \node (A) at (0,1)    {A};
  \node (B) at (1,1.5)  {B};
  \node (C) at (2,0)    {C};
  \node (D) at (2.5,-2) {D};

  \draw (A) -- (B) node [midway] {x};
  \draw (C) -- (D) node [midway] {x};

  \node at ({$(A)!.5!(B)$} -| {$(C)!.5!(D)$}) {X};
\end{tikzpicture}
\end{codeexample}
    %
\end{coordinatesystem}


\subsubsection{Intersections of Arbitrary Paths}

\begin{tikzlibrary}{intersections}
    This library enables the calculation of intersections of two arbitrary
    paths. However, due to the low accuracy of \TeX, the paths should not be
    ``too complicated''. In particular, you should not try to intersect paths
    consisting of lots of very small segments such as plots or decorated paths.
\end{tikzlibrary}

To find the intersections of two paths in \tikzname, they must be ``named''. A
``named path'' is, quite simply, a path that has been named using the following
key (note that this is a \emph{different} key from the |name| key, which only
attaches a hyperlink target to a path, but does not store the path in a way the
is useful for the intersection computation):

\begin{keylist}{%
    /tikz/name path=\meta{name},
    /tikz/name path global=\meta{name}%
}
    The effect of this key is that, after the path has been constructed, just
    before it is used, it is associated with \meta{name}. For |name path|, this
    association survives beyond the final semi-colon of the path but not the
    end of the surrounding scope. For |name path global|, the association will
    survive beyond any scope as well. Handle with care.

    Any paths created by nodes on the (main) path are ignored, unless this key
    is explicitly used. If the same \meta{name} is used for the main path and
    the node path(s), then the paths will be added together and then associated
    with \meta{name}.
\end{keylist}

To find the intersection of named paths, the following key is used:

\begin{key}{/tikz/name intersections=\marg{options}}
    This key changes the key path to |/tikz/intersection| and processes
    \meta{options}. These options determine, among other things, which paths to
    use for the intersection. Having processed the options, any intersections
    are then found. A coordinate is created at each intersection, which by
    default, will be named |intersection-1|, |intersection-2|, and so on.
    Optionally, the prefix |intersection| can be changed, and the total number
    of intersections stored in a \TeX-macro.
    %
\begin{codeexample}[preamble={\usetikzlibrary{intersections}}]
\begin{tikzpicture}[every node/.style={opacity=1, black, above left}]
  \draw [help lines] grid (3,2);
  \draw [name path=ellipse] (2,0.5) ellipse (0.75cm and 1cm);
  \draw [name path=rectangle, rotate=10] (0.5,0.5) rectangle +(2,1);
  \fill [red, opacity=0.5, name intersections={of=ellipse and rectangle}]
    (intersection-1) circle (2pt) node {1}
    (intersection-2) circle (2pt) node {2};
\end{tikzpicture}
\end{codeexample}

    The following keys can be used in \meta{options}:

    \begin{key}{/tikz/intersection/of=\meta{name path 1}| and |\meta{name path 2}}
        This key is used to specify the names of the paths to use for the
        intersection.
    \end{key}

    \begin{key}{/tikz/intersection/name=\meta{prefix} (initially intersection)}
        This key specifies the prefix name for the coordinate nodes placed at
        each intersection.
    \end{key}

    \begin{key}{/tikz/intersection/total=\meta{macro}}
        This key means that the total number of intersections found will be
        stored in \meta{macro}.
    \end{key}

\begin{codeexample}[preamble={\usetikzlibrary{intersections}}]
\begin{tikzpicture}
  \clip (-2,-2) rectangle (2,2);
  \draw [name path=curve 1] (-2,-1) .. controls (8,-1) and (-8,1) .. (2,1);
  \draw [name path=curve 2] (-1,-2) .. controls (-1,8) and (1,-8) .. (1,2);

  \fill [name intersections={of=curve 1 and curve 2, name=i, total=\t}]
        [red, opacity=0.5, every node/.style={above left, black, opacity=1}]
        \foreach \s in {1,...,\t}{(i-\s) circle (2pt) node {\footnotesize\s}};
\end{tikzpicture}
\end{codeexample}

    \begin{key}{/tikz/intersection/by=\meta{comma-separated list}}
        This key allows you to specify a list of names for the intersection
        coordinates. The intersection coordinates will still be named
        \meta{prefix}|-|\meta{number}, but additionally the first coordinate
        will also be named by the first element of the \meta{comma-separated
        list}. What happens is that the \meta{comma-separated list} is passed
        to the |\foreach| statement and for \meta{list member} a coordinate is
        created at the already-named intersection.
        %
\begin{codeexample}[preamble={\usetikzlibrary{intersections}}]
\begin{tikzpicture}
  \clip (-2,-2) rectangle (2,2);
  \draw [name path=curve 1] (-2,-1) .. controls (8,-1) and (-8,1) .. (2,1);
  \draw [name path=curve 2] (-1,-2) .. controls (-1,8) and (1,-8) .. (1,2);

  \fill [name intersections={of=curve 1 and curve 2, by={a,b}}]
        (a) circle (2pt)
        (b) circle (2pt);
\end{tikzpicture}
\end{codeexample}

        You can also use the |...| notation of the |\foreach| statement inside
        the \meta{comma-separated list}.

        In case an element of the \meta{comma-separated list} starts with
        options in square brackets, these options are used when the coordinate
        is created. A coordinate name can still, but need not, follow the
        options. This makes it easy to add labels to intersections:
        %
\begin{codeexample}[preamble={\usetikzlibrary{intersections}}]
\begin{tikzpicture}
  \clip (-2,-2) rectangle (2,2);
  \draw [name path=curve 1] (-2,-1) .. controls (8,-1) and (-8,1) .. (2,1);
  \draw [name path=curve 2] (-1,-2) .. controls (-1,8) and (1,-8) .. (1,2);

  \fill [name intersections={
          of=curve 1 and curve 2,
          by={[label=center:a],[label=center:...],[label=center:i]}}];
\end{tikzpicture}
\end{codeexample}
    \end{key}

    \begin{key}{/tikz/intersection/sort by=\meta{path name}}
        By default, the intersections are simply returned in the order that the
        intersection algorithm finds them. Unfortunately, this is not
        necessarily a ``helpful'' ordering. This key can be used to sort the
        intersections along the path specified by \meta{path name}, which
        should be one of the paths mentioned in the |/tikz/intersection/of|
        key.
        %
\begin{codeexample}[preamble={\usetikzlibrary{intersections}}]
\begin{tikzpicture}
\clip (-0.5,-0.75) rectangle (3.25,2.25);
\foreach \pathname/\shift in {line/0cm, curve/2cm}{
  \tikzset{xshift=\shift}
  \draw [->, name path=curve] (1,1.5) .. controls (-1,1) and (2,0.5) .. (0,0);
  \draw [->, name path=line]  (0,-.5) -- (1,2) ;
  \fill [name intersections={of=line and curve,sort by=\pathname, name=i}]
    [red, opacity=0.5, every node/.style={left=.25cm, black, opacity=1}]
    \foreach \s in {1,2,3}{(i-\s) circle (2pt) node {\footnotesize\s}};
}
\end{tikzpicture}
\end{codeexample}
    \end{key}
\end{key}


\subsection{Relative and Incremental Coordinates}

\subsubsection{Specifying Relative Coordinates}

You can prefix coordinates by |++| to make them ``relative''. A coordinate such
as |++(1cm,0pt)| means ``1cm to the right of the previous position, making this
the new current position''. Relative coordinates are often useful in ``local''
contexts:
%
\begin{codeexample}[]
\begin{tikzpicture}
  \draw (0,0)     -- ++(1,0) -- ++(0,1) -- ++(-1,0) -- cycle;
  \draw (2,0)     -- ++(1,0) -- ++(0,1) -- ++(-1,0) -- cycle;
  \draw (1.5,1.5) -- ++(1,0) -- ++(0,1) -- ++(-1,0) -- cycle;
\end{tikzpicture}
\end{codeexample}

Instead of |++| you can also use a single |+|. This also specifies a relative
coordinate, but it does not ``update'' the current point for subsequent usages
of relative coordinates. Thus, you can use this notation to specify numerous
points, all relative to the same ``initial'' point:

\begin{codeexample}[]
\begin{tikzpicture}
  \draw (0,0)     -- +(1,0) -- +(1,1) -- +(0,1) -- cycle;
  \draw (2,0)     -- +(1,0) -- +(1,1) -- +(0,1) -- cycle;
  \draw (1.5,1.5) -- +(1,0) -- +(1,1) -- +(0,1) -- cycle;
\end{tikzpicture}
\end{codeexample}

There is a special situation, where relative coordinates are interpreted
differently. If you use a relative coordinate as a control point of a Bézier
curve, the following rule applies: First, a relative first control point is
taken relative to the beginning of the curve. Second, a relative second control
point is taken relative to the end of the curve. Third, a relative end point of
a curve is taken relative to the start of the curve.

This special behavior makes it easy to specify that a curve should ``leave or
arrive from a certain direction'' at the start or end. In the following
example, the curve ``leaves'' at $30^\circ$ and ``arrives'' at $60^\circ$:
%
\begin{codeexample}[]
\begin{tikzpicture}
  \draw (1,0) .. controls +(30:1cm) and +(60:1cm) .. (3,-1);
  \draw[gray,->] (1,0) -- +(30:1cm);
  \draw[gray,<-] (3,-1) -- +(60:1cm);
\end{tikzpicture}
\end{codeexample}


\subsubsection{Rotational Relative Coordinates}

You may sometimes wish to specify points relative not only to the previous
point, but additionally relative to the tangent entering the previous point.
For this, the following key is useful:

\begin{key}{/tikz/turn}
    This key can be given as an option to a \meta{coordinate} as in the
    following example:
    %
\begin{codeexample}[]
\tikz \draw (0,0) -- (1,1) -- ([turn]-45:1cm) -- ([turn]-30:1cm);
\end{codeexample}
    %
    The effect of this key is to locally shift the coordinate system so that
    the last point reached is at the origin and the coordinate system is
    ``turned'' so that the $x$-axis points in the direction of a tangent
    entering the last point. This means, in effect, that when you use polar
    coordinates of the form \meta{relative angle}|:|\meta{distance} together
    with the |turn| option, you specify a point that lies at \meta{distance}
    from the last point in the direction of the last tangent entering the last
    point, but with a rotation of \meta{relative angle}.

    This key also works with curves \dots
    %
\begin{codeexample}[]
\tikz [delta angle=30, radius=1cm]
  \draw (0,0) arc [start angle=0]  -- ([turn]0:1cm)
              arc [start angle=30] -- ([turn]0:1cm)
              arc [start angle=60] -- ([turn]30:1cm);
\end{codeexample}
\begin{codeexample}[]
\tikz \draw (0,0) to [bend left] (2,1) -- ([turn]0:1cm);
\end{codeexample}
    %
    \dots and with plots \dots
    %
\begin{codeexample}[]
\tikz \draw plot coordinates {(0,0) (1,1) (2,0) (3,0) } -- ([turn]30:1cm);
\end{codeexample}

    Although the above examples use polar coordinates with |turn|, you can also
    use any normal coordinate. For instance, |([turn]1,1)| will append a line
    of length $\sqrt 2$ that is turns by $45^\circ$ relative to the tangent to
    the last point.
    %
\begin{codeexample}[]
\tikz \draw (0.5,0.5) -| (2,1) -- ([turn]1,1)
         .. controls ([turn]0:1cm) .. ([turn]-90:1cm);
\end{codeexample}
    %
\end{key}


\subsubsection{Relative Coordinates and Scopes}
\label{section-scopes-relative}

An interesting question is, how do relative coordinates behave in the presence
of scopes? That is, suppose we use curly braces in a path to make part of it
``local'', how does that affect the current position? On the one hand, the
current position certainly changes since the scope only affects options, not
the path itself. On the other hand, it may be useful to ``temporarily escape''
from the updating of the current point.

Since both interpretations of how the current point and scopes should
``interact'' are useful, there is a (local!) option that allows you to decide
which you need.

\begin{key}{/tikz/current point is local=\opt{\meta{boolean}} (initially false)}
    Normally, the scope path operation has no effect on the current point. That
    is, curly braces on a path have no effect on the current position:
    %
\begin{codeexample}[]
\begin{tikzpicture}
  \draw      (0,0) -- ++(1,0)   -- ++(0,1)   -- ++(-1,0);
  \draw[red] (2,0) -- ++(1,0) { -- ++(0,1) } -- ++(-1,0);
\end{tikzpicture}
\end{codeexample}
    %
    If you set this key to |true|, this behavior changes. In this case, at the
    end of a group created on a path, the last current position reverts to
    whatever value it had at the beginning of the scope. More precisely, when
    \tikzname\ encounters |}| on a path, it checks whether at this particular
    moment the key is set to |true|. If so, the current position reverts to the
    value it had when the matching |{| was read.
    %
\begin{codeexample}[]
\begin{tikzpicture}
  \draw      (0,0) -- ++(1,0)   -- ++(0,1)   -- ++(-1,0);
  \draw[red] (2,0) -- ++(1,0)
     { [current point is local] -- ++(0,1) } -- ++(-1,0);
\end{tikzpicture}
\end{codeexample}
    %
    In the above example, we could also have given the option outside the
    scope, for instance as a parameter to the whole scope.
\end{key}


\subsection{Coordinate Calculations}
\label{tikz-lib-calc}

\begin{tikzlibrary}{calc}
    You need to load this library in order to use the coordinate calculation
    functions described in the present section.
\end{tikzlibrary}

It is possible to do some basic calculations that involve coordinates. In
essence, you can add and subtract coordinates, scale them, compute midpoints,
and do projections. For instance, |($(a) + 1/3*(1cm,0)$)| is the coordinate
that is $1/3 \text{cm}$ to the right of the point |a|:
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);

  \node (a) at (1,1) {A};
  \fill [red] ($(a) + 1/3*(1cm,0)$) circle (2pt);
\end{tikzpicture}
\end{codeexample}


\subsubsection{The General Syntax}

The general syntax is the following:
%
\begin{quote}
    \declare{|(|\opt{|[|\meta{options}|]|}|$|\meta{coordinate computation}|$)|}.
\end{quote}

As you can see, the syntax uses the \TeX\ math symbol |$| to %$
indicate that a ``mathematical computation'' is involved. However, the |$| %$
has no other effect, in particular, no mathematical text is typeset.

The \meta{coordinate computation} has the following structure:
%
\begin{enumerate}
    \item It starts with
        %
        \begin{quote}
            \opt{\meta{factor}|*|}\meta{coordinate}\opt{\meta{modifiers}}
        \end{quote}
    \item This is optionally followed by |+| or |-| and then another
        %
        \begin{quote}
            \opt{\meta{factor}|*|}\meta{coordinate}\opt{\meta{modifiers}}
        \end{quote}
    \item This is once more followed by |+| or |-| and another of the above
        modified coordinate; and so on.
\end{enumerate}

In the following, the syntax of factors and of the different modifiers
is explained in detail.


\subsubsection{The Syntax of Factors}

The \meta{factor}s are optional and detected by checking whether the
\meta{coordinate computation} starts with a |(|. Also, after each $\pm$ a
\meta{factor} is present if, and only if, the |+| or |-| sign is not directly
followed by~|(|.

If a \meta{factor} is present, it is evaluated using the |\pgfmathparse| macro.
This means that you can use pretty complicated computations inside a factor. A
\meta{factor} may even contain opening parentheses, which creates a
complication: How does \tikzname\ know where a \meta{factor} ends and where a
coordinate starts? For instance, if the beginning of a \meta{coordinate
computation} is |2*(3+4|\dots, it is not clear whether |3+4| is part of a
\meta{coordinate} or part of a \meta{factor}. Because of this, the following
rule is used: Once it has been determined, that a \meta{factor} is present, in
principle, the \meta{factor} contains everything up to the next occurrence of
|*(|. Note that there is no space between the asterisk and the parenthesis.

It is permissible to put the \meta{factor} in curly braces. This can be used
whenever it is unclear where the \meta{factor} would end.

Here are some examples of coordinate specifications that consist of exactly one
\meta{factor} and one \meta{coordinate}:
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);

  \fill [red] ($2*(1,1)$) circle (2pt);
  \fill [green] (${1+1}*(1,.5)$) circle (2pt);
  \fill [blue] ($cos(0)*sin(90)*(1,1)$) circle (2pt);
  \fill [black] (${3*(4-3)}*(1,0.5)$) circle (2pt);
\end{tikzpicture}
\end{codeexample}


\subsubsection{The Syntax of Partway Modifiers}

A \meta{coordinate} can be followed by different \meta{modifiers}. The first
kind of modifier is the \emph{partway modifier}. The syntax (which is loosely
inspired by Uwe Kern's |xcolor| package) is the following:
%
\begin{quote}
    \meta{coordinate}\declare{|!|\meta{number}|!|\opt{\meta{angle}|:|}\meta{second coordinate}}
\end{quote}
%
One could write for instance
%
\begin{codeexample}[code only]
(1,2)!.75!(3,4)
\end{codeexample}
%
The meaning of this is: ``Use the coordinate that is three quarters on the way
from |(1,2)| to |(3,4)|.'' In general, \meta{coordinate
x}|!|\meta{number}|!|\meta{coordinate y} yields the coordinate $(1 -
\meta{number})\meta{coordinate x} + \meta{number} \meta{coordinate y}$. Note
that this is a bit different from the way the \meta{number} is interpreted in
the |xcolor| package: First, you use a factor between $0$ and $1$, not a
percentage, and, second, as the \meta{number} approaches $1$, we approach the
second coordinate, not the first. It is permissible to use a \meta{number} that
is smaller than $0$ or larger than $1$. The \meta{number} is evaluated using
the |\pgfmathparse| command and, thus, it can involve complicated computations.
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);

  \draw (1,0) -- (3,2);

  \foreach \i in {0,0.2,0.5,0.9,1}
    \node at ($(1,0)!\i!(3,2)$) {\i};
\end{tikzpicture}
\end{codeexample}

The \meta{second coordinate} may be prefixed by an \meta{angle}, separated with
a colon, as in |(1,1)!.5!60:(2,2)|. The general meaning of
\meta{a}|!|\meta{factor}|!|\meta{angle}|:|\meta{b} is: ``First, consider the
line from \meta{a} to \meta{b}. Then rotate this line by \meta{angle}
\emph{around the point \meta{a}}. Then the two endpoints of this line will be
\meta{a} and some point \meta{c}. Use this point \meta{c} for the subsequent
computation, namely the partway computation.''

Here are two examples:
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,3);

  \coordinate (a) at (1,0);
  \coordinate (b) at (3,2);

  \draw[->] (a) -- (b);

  \coordinate (c) at ($ (a)!1! 10:(b) $);

  \draw[->,red] (a) -- (c);

  \fill ($ (a)!.5! 10:(b) $) circle (2pt);
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (4,4);

  \foreach \i in {0,0.1,...,2}
    \fill ($(2,2) !\i! \i*180:(3,2)$) circle (2pt);
\end{tikzpicture}
\end{codeexample}

You can repeatedly apply modifiers. That is, after any modifier you can add
another (possibly different) modifier.
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);

  \draw (0,0) -- (3,2);
  \draw[red] ($(0,0)!.3!(3,2)$) -- (3,0);
  \fill[red] ($(0,0)!.3!(3,2)!.7!(3,0)$) circle (2pt);
\end{tikzpicture}
\end{codeexample}


\subsubsection{The Syntax of Distance Modifiers}

A \emph{distance modifier} has nearly the same syntax as a partway modifier,
only you use a \meta{dimension} (something like |1cm|) instead of a
\meta{factor} (something like |0.5|):
%
\begin{quote}
    \meta{coordinate}\declare{|!|\meta{dimension}|!|\opt{\meta{angle}|:|}\meta{second coordinate}}
\end{quote}

When you write \meta{a}|!|\meta{dimension}|!|\meta{b}, this means the
following: Use the point that is distanced \meta{dimension} from \meta{a} on
the straight line from \meta{a} to \meta{b}. Here is an example:
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);

  \draw (1,0) -- (3,2);

  \foreach \i in {0cm,1cm,15mm}
    \node at ($(1,0)!\i!(3,2)$) {\i};
\end{tikzpicture}
\end{codeexample}

As before, if you use a \meta{angle}, the \meta{second coordinate} is rotated
by this much around the \meta{coordinate} before it is used.

The combination of an \meta{angle} of |90| degrees with a distance can be used
to ``offset'' a point relative to a line. Suppose, for instance, that you have
computed a point |(c)| that lies somewhere on a line from |(a)| to~|(b)| and
you now wish to offset this point by |1cm| so that the distance from this
offset point to the line is |1cm|. This can be achieved as follows:
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);

  \coordinate (a) at (1,0);
  \coordinate (b) at (3,1);

  \draw (a) -- (b);

  \coordinate (c) at ($ (a)!.25!(b) $);
  \coordinate (d) at ($ (c)!1cm!90:(b) $);

  \draw [<->] (c) -- (d) node [sloped,midway,above] {1cm};
\end{tikzpicture}
\end{codeexample}


\subsubsection{The Syntax of Projection Modifiers}

The projection modifier is also similar to the above modifiers: It also gives a
point on a line from the \meta{coordinate} to the \meta{second coordinate}.
However, the \meta{number} or \meta{dimension} is replaced by a
\meta{projection coordinate}:
%
\begin{quote}
    \meta{coordinate}\declare{|!|\meta{projection coordinate}|!|\opt{\meta{angle}|:|}\meta{second coordinate}}
\end{quote}

Here is an example:
%
\begin{codeexample}[code only]
(1,2)!(0,5)!(3,4)
\end{codeexample}

The effect is the following: We project the \meta{projection coordinate}
orthogonally onto the line from \meta{coordinate} to \meta{second coordinate}.
This makes it easy to compute projected points:
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);

  \coordinate (a) at (0,1);
  \coordinate (b) at (3,2);
  \coordinate (c) at (2.5,0);

  \draw (a) -- (b) -- (c) -- cycle;

  \draw[red]    (a) -- ($(b)!(a)!(c)$);
  \draw[orange] (b) -- ($(a)!(b)!(c)$);
  \draw[blue]   (c) -- ($(a)!(c)!(b)$);
\end{tikzpicture}
\end{codeexample}
