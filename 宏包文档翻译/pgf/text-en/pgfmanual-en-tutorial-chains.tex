

\subsubsection{Creating Nodes Using the Graph Command\\使用图命令创建节点}

Ilka has heard that the |graph| command is also supposed to make it easy to
create nodes, not only to connect them. This is, indeed, correct: When the
|use existing nodes| option is not used and when a node name is not surrounded
by parentheses, then \tikzname\ will actually create a node whose name and text
is the node name:

Ilka听说|graph|命令还可以方便地创建节点，不仅可以连接它们。这是正确的：当没有使用|use existing nodes|选项并且节点名称没有用括号括起来时，\tikzname 实际上会创建一个节点，其名称和文本都是节点名称：

%
\begin{codeexample}[preamble={\usetikzlibrary{graphs}}]
\tikz \graph [grow right=2cm] { unsigned integer -> d -> digit -> E };
\end{codeexample}
%
Not quite perfect, but we are getting somewhere. First, let us change the
positioning algorithm by saying |grow right sep|, which causes new nodes to be
placed to the right of the previous nodes with a certain fixed separation
(|1em| by default). Second, we add some options to make the node ``look nice''.
Third, note the funny |d| node above: Ilka tried writing just |.| there first,
but got some error messages. The reason is that a node cannot be called |.| in
\tikzname, so she had to choose a different name -- which is not good, since
she wants a dot to be shown! The trick is to put the dot in quotation marks,
this allows you to use ``quite arbitrary text'' as a node name:

还不是很完美，但我们正在取得进展。首先，让我们通过使用|grow right sep|命令来更改定位算法，这将使新节点放置在前一个节点的右侧，并保持一定的固定间距（默认为|1em|）。其次，我们添加一些选项来使节点“看起来不错”。第三，在上面的例子中注意到有一个有趣的节点|d|：Ilka首先尝试只在那里写一个|.|，但是得到了一些错误消息。原因是在\tikzname 中节点不能被称为 |.| ，所以她不得不选择一个不同的名称——这并不好，因为她希望显示一个点！诀窍是将点放在引号中，这样你就可以使用“相当任意的文本”作为节点名称：


%
\begin{codeexample}[preamble={\usetikzlibrary{graphs,shapes.misc}}]
\tikz \graph [grow right sep] {
  unsigned integer[nonterminal] -> "."[terminal] -> digit[terminal] -> E[terminal]
};
\end{codeexample}
%
Now comes the fork to the plus and minus signs. Here, Ilka can use the grouping
mechanism of the |graph| command to create a split:

现在到了分支加减号的部分。在这里，Ilka可以使用|graph|命令的分组机制来创建一个分支：

%
\begin{codeexample}[preamble={\usetikzlibrary{graphs,shapes.misc}}]
\tikz \graph [grow right sep] {
  unsigned integer  [nonterminal] ->
  "."               [terminal] ->
  digit             [terminal] ->
  E                 [terminal] ->
  {
    "+"             [terminal],
    ""              [coordinate],
    "-"             [terminal]
  } ->
  ui2/unsigned integer [nonterminal]
};
\end{codeexample}
%
Let us see, what is happening here. We want two |unsigned integer| nodes, but
if we just were to use this text twice, then \tikzname\ would have noticed that
the same name was used already in the current graph and, being smart (actually
too smart in this case), would have created an edge back to the already-created
node. Thus, a fresh name is needed here. However, Ilka also cannot just write
|unsigned integer2|, because she wants the original text to be shown, after
all! The trick is to use a slash inside the node name: In order to ``render''
the node, the text following the slash is used instead of the node name, which
is the text before the slash. Alternatively, the |as| option can be used, which
also allows you to specify how a node should be rendered.

让我们看看这里发生了什么。我们想要两个|unsigned integer|节点，但是如果我们只是两次使用相同的文本，那么\tikzname 会注意到在当前图中已经使用了相同的名称，并且会创建一条返回到已创建节点的边。因此，在这里需要一个新的名称。然而，Ilka也不能只是写|unsigned integer2|，因为她希望显示原始文本！诀窍是在节点名称中使用斜杠：为了“渲染”节点，斜杠后面的文本将被用于替代节点名称，节点名称则是斜杠前面的文本。或者，也可以使用|as|选项，它还允许指定节点的呈现方式。

It turns out that Ilka does not need to invent a name like |ui2| for a node
that she will not reference again anyway. In this case, she can just leave out
the name (write nothing before |/|), which always stands for a ``fresh,
anonymous'' node name.

事实证明，Ilka不需要为她不会再次引用的节点发明一个像|ui2|这样的名称。在这种情况下，她可以只留空名称（在|/|之前不写任何内容），它始终代表一个“新的匿名”节点名称。

Next, Ilka needs to add some coordinates in between of some nodes where the
back-loops should got and she needs to shift the nodes a bit:

接下来，Ilka需要在一些节点之间添加一些坐标，用于连接反向循环，并且她需要稍微移动节点：

%
\begin{codeexample}[
    preamble={\usetikzlibrary{arrows.meta,graphs,shapes.misc}},
    pre={\tikzset{
    skip loop/.style={to path={-- ++(0,##1) -| (\tikztotarget)}},
    hv path/.style={to path={-| (\tikztotarget)}},
    vh path/.style={to path={|- (\tikztotarget)}},
}},
]
\begin{tikzpicture}[>={Stealth[round]}, thick, black!50, text=black,
                    every new ->/.style={shorten >=1pt},
                    graphs/every graph/.style={edges=rounded corners}]
  \graph [grow right sep, branch down=7mm] {
    /                  [coordinate] ->
    unsigned integer   [nonterminal] --
    p1                 [coordinate] ->
    "."                [terminal] --
    p2                 [coordinate] ->
    digit              [terminal] --
    p3                 [coordinate] --
    p4                 [coordinate] --
    p5                 [coordinate] ->
    E                  [terminal] --
    q1                 [coordinate] ->[vh path]
    { [nodes={yshift=7mm}]
      "+"                [terminal],
      q2/                [coordinate],
      "-"                [terminal]
    } -> [hv path]
    q3                 [coordinate] --
    /unsigned integer  [nonterminal] --
    p6                 [coordinate] ->
    /                  [coordinate];

    p1 ->[skip loop=5mm]   p4;
    p3 ->[skip loop=-5mm]  p2;
    p5 ->[skip loop=-11mm] p6;
  };
\end{tikzpicture}
\end{codeexample}

All that remains to be done is to somehow get rid of the strange curves between
the |E| and the unsigned integer. They are caused by \tikzname's attempt at
creating an edge that first goes vertical and then horizontal but is actually
just horizontal. Additionally, the edge should not really be pointed; but it
seems difficult to get rid of this since the \emph{other} edges from |q1|,
namely to |plus| and |minus| should be pointed.

剩下的就是如何消除|E|和unsigned integer之间的奇怪曲线了。它们是由\tikzname 试图创建首先垂直然后水平的边而实际上只是水平的边引起的。此外，该边实际上不应该有箭头；但是似乎很难摆脱，因为从|q1|到其他边，即|plus|和|minus|，应该有箭头。

It turns out that there is a nice way of solving this problem: You can specify
that a graph is |simple|. This means that there can be at most one edge between
any two nodes. Now, if you specify an edge twice, the options of the second
specification ``win''. Thus, by adding two more lines that ``correct'' these
edges, we get the final diagram with its complete code:

事实证明，有一种很好的方法可以解决这个问题：您可以指定图是|simple|的。这意味着任何两个节点之间最多只能有一条边。现在，如果您指定了两次边，第二次规定的选项将“胜出”。因此，通过添加两行来“修正”这些边，我们得到了带有完整代码的最终图表：

%
\begin{codeexample}[preamble={\usetikzlibrary{arrows.meta,graphs,shapes.misc}}]
\tikz [>={Stealth[round]}, black!50, text=black, thick,
       every new ->/.style          = {shorten >=1pt},
       graphs/every graph/.style    = {edges=rounded corners},
       skip loop/.style             = {to path={-- ++(0,#1) -| (\tikztotarget)}},
       hv path/.style               = {to path={-| (\tikztotarget)}},
       vh path/.style               = {to path={|- (\tikztotarget)}},
       nonterminal/.style           = {
         rectangle, minimum size=6mm, very thick, draw=red!50!black!50, top color=white,
         bottom color=red!50!black!20, font=\itshape, text height=1.5ex,text depth=.25ex},
       terminal/.style              = {
         rounded rectangle,  minimum size=6mm, very thick, draw=black!50, top color=white,
         bottom color=black!20, font=\ttfamily, text height=1.5ex, text depth=.25ex},
       shape                        = coordinate
       ]
  \graph [grow right sep, branch down=7mm, simple] {
    / -> unsigned integer[nonterminal] -- p1 -> "." [terminal] -- p2 -> digit[terminal] --
    p3 -- p4 -- p5 -> E[terminal] -- q1 ->[vh path]
    {[nodes={yshift=7mm}]
      "+"[terminal], q2, "-"[terminal]
    } -> [hv path]
    q3 -- /unsigned integer [nonterminal] -- p6 -> /;

    p1 ->[skip loop=5mm]   p4;
    p3 ->[skip loop=-5mm]  p2;
    p5 ->[skip loop=-11mm] p6;

    q1 -- q2 -- q3;  % make these edges plain
  };
\end{codeexample}




\mshowc{section}
\mshowc{subsection}
\mshowc{subsubsection}
\end{document}


%% TODOsp: a commented subsection
% \subsection{Using Chains}
%
% Matrices allow Ilka to align the nodes nicely, but the connections are
% not quite perfect. The problem is that the code does not really
% reflect the paths that underlie the diagram.
%
%
% For this reason, Ilka decides to try out \emph{chains} by including
% the |chain| library. Basically, a chain is just a sequence of
% (usually) connected nodes. The nodes can already have been constructed
% or they can be constructed as the chain is constructed (or these
% processes can be mixed).
%
% \subsubsection{Creating a Simple Chain}
%
%
% Ilka starts with creating a chain from scratch. For this, she starts a
% chain using the |start chain| option in a scope. Then, inside the
% scope, she uses the |on chain| option on nodes to add them to the
% chain.
% \begin{codeexample}[]
% \begin{tikzpicture}[start chain,node distance=5mm]
%   \node [on chain,nonterminal]  {unsigned integer};
%   \node [on chain,terminal]     {.};
%   \node [on chain,terminal]     {digit};
%   \node [on chain,terminal]     {E};
%   \node [on chain,nonterminal]  {unsigned integer};
% \end{tikzpicture}
% \end{codeexample}
% (Ilka will add the plus and minus nodes later.)
%
% As can be seen, the nodes of a chain are placed in a row. This can be
% changed, for instance by saying |start chain=going below| we get a
% chain where each node is below the previous one.
%
% The next step is to \emph{join} the nodes of the chain. For this, we
% add the |join| option to each node. This joins the node with the
% previous node (for the first node nothing happens).
% \begin{codeexample}[]
% \begin{tikzpicture}[start chain,node distance=5mm]
%   \node [on chain,join,nonterminal]  {unsigned integer};
%   \node [on chain,join,terminal]     {.};
%   \node [on chain,join,terminal]     {digit};
%   \node [on chain,join,terminal]     {E};
%   \node [on chain,join,nonterminal]  {unsigned integer};
% \end{tikzpicture}
% \end{codeexample}
% In order to get a arrow tip, we redefine the |every join| style. Also,
% we move the |join| and |on chain| options to the |every node|
% style so that we do not have to repeat them so often.
% \begin{codeexample}[]
% \begin{tikzpicture}[start chain,node distance=5mm, every node/.style={on chain,join}, every join/.style={->}]
%   \node [nonterminal]  {unsigned integer};
%   \node [terminal]     {.};
%   \node [terminal]     {digit};
%   \node [terminal]     {E};
%   \node [nonterminal]  {unsigned integer};
% \end{tikzpicture}
% \end{codeexample}
%
%
% \subsubsection{Branching and Joining a Chain}
%
% It is now time to add the plus and minus signs. They obviously
% \emph{branch off} the main chain. For this reason, we start a branch
% for them using the |start branch| option.
% \begin{codeexample}[]
% \begin{tikzpicture}[start chain,node distance=5mm, every node/.style={on chain,join}, every join/.style={->}]
%   \node [nonterminal]  {unsigned integer};
%   \node [terminal]     {.};
%   \node [terminal]     {digit};
%   \node [terminal]     {E};
%   \begin{scope}[start branch=plus]
%     \node (plus)  [terminal,on chain=going above right] {+};
%   \end{scope}
%   \begin{scope}[start branch=minus]
%     \node (minus) [terminal,on chain=going below right] {-};
%   \end{scope}
%   \node [nonterminal,join=with plus,join=with minus]  {unsigned integer};
% \end{tikzpicture}
% \end{codeexample}
%
% Let us see, what is going on here. First, the |start branch| begins a
% branch, starting with the node last created on the current chain,
% which is the |E| node in our case. This is implicitly also the first
% node on this branch. A branch is nothing different from a chain, which
% is why the plus node is put on this branch using the |on chain|
% option. However, this time we specify the placement of the node
% explicitly using |going |\meta{direction}. This causes the plus sign
% to be placed above and right of the |E| node. It is automatically
% joined to its predecessor on the branch by the implicit |join|
% option.
%
% When the first branch ends, only the plus node has been added and the
% current chain is the original chain once more and we are back to the
% |E| node. Now we start a new branch for the minus node. After this
% branch, the current chain ends at |E| node once more.
%
% Finally, the rightmost unsigned integer is added to the (main) chain,
% which is why it is joined correctly with the |E| node. The two
% additional |join| options get a special |with| parameter. This allows
% you to join a node with a node other than the predecessor on the
% chain. The  |with| should be followed by the name of a node.
%
% Since Ilka will need scopes more often in the following, she includes
% the |scopes| library. This allows her to replace |\begin{scope}|
%   simply by an opening brace and  |\end{scope}| by the corresponding
% closing brace. Also, in the following example we reference
% the nodes |plus| and |minus| using
% their automatic name: The $i$th node on a chain is called
% |chain-|\meta{i}. For a branch \meta{branch}, the $i$th node is called
% |chain/|\meta{branch}|-|\meta{i}. The \meta{i} can be replaced by
% |begin| and |end| to reference the first and (currently) last node on
% the chain.
%
% \begin{codeexample}[]
% \begin{tikzpicture}[start chain,node distance=5mm, every on chain/.style={join}, every join/.style={->}]
%   \node [on chain,nonterminal]  {unsigned integer};
%   \node [on chain,terminal]     {.};
%   \node [on chain,terminal]     {digit};
%   \node [on chain,terminal]     {E};
%   { [start branch=plus]
%     \node (plus)  [terminal,on chain=going above right] {+};
%   }
%   { [start branch=minus]
%     \node (minus) [terminal,on chain=going below right] {-};
%   }
%   \node [nonterminal,on chain,join=with chain/plus-end,join=with chain/minus-end]  {unsigned integer};
% \end{tikzpicture}
% \end{codeexample}
%
%
% The next step is to add intermediate coordinate nodes in the same
% manner as Ilka did for the matrix. For them, we change the |join|
% style slightly, namely for these nodes we do not want an arrow
% tip. This can be achieved either by (locally) changing the
% |every join| style or, which is what is done in the below example, by
% giving the desired style using |join=by ...|, where |...| is the style
% to be used for the join.
%
% \begin{codeexample}[]
% \begin{tikzpicture}[start chain,node distance=5mm and 2mm,
%                     every node/.style={on chain},
%                     nonterminal/.append style={join=by ->},
%                     terminal/.append style={join=by ->},
%                     point/.style={join=by -,circle,fill=red,minimum size=2pt,inner sep=0pt}]
%   \node [point] {};  \node [nonterminal] {unsigned integer};
%   \node [point] {};  \node [terminal]    {.};
%   \node [point] {};  \node [terminal]    {digit};
%   \node [point] {};  \node [point]       {};
%   \node [point] {};  \node [terminal]    {E};
%   \node [point] {};
%   { [node distance=5mm and 1cm] % local change in horizontal distance
%     { [start branch=plus]
%       \node (plus)  [terminal,on chain=going above right] {+};
%     }
%     { [start branch=minus]
%       \node (minus) [terminal,on chain=going below right] {-};
%     }
%     \node [point,below right=of plus,join=with chain/plus-end by ->,join=with chain/minus-end by ->] {};
%   }
%   \node [nonterminal] {unsigned integer};
%   \node [point]       {};
% \end{tikzpicture}
% \end{codeexample}
%
%
% \subsubsection{Chaining Together Already Positioned Nodes}
%
% The final step is to add the missing arrows. We can also use branches
% for them (even though we do not have to, but it is good practice and
% they exhibit the structure of the diagram in the code).
%
% Let us start with the repeat loop around the |digit|. This can be
% thought of as a branch that starts at the point after the digit and
% that ends at the point before the digit. However, we have already
% constructed the point before the digit! In such cases, it is possible
% to ``chain in'' an already positioned node, using the |\chainin|
% command. This command must be followed by a coordinate that contains a
% node name and optionally some options. The effect is that the named
% node is made part of the current chain.
%
% \begin{codeexample}[pre={\tikzset{node distance=5mm and 2mm,
%                     every node/.style={on chain},
%                     terminal/.append style={join=by ->},
%                     point/.style={join=by -,circle,fill=red,minimum size=2pt,inner sep=0pt}}}]
% \begin{tikzpicture}[start chain] % plus some styles that are not shown
%   \node                [point] {};
%   \node (before digit) [point] {};
%   \node                [terminal]    {digit};
%   \node                [point] {};
%   { [start branch=digit loop]
%     \chainin (before digit) [join=by {->,skip loop=-5mm}];
%   }
%   \node                [point] {};
% \end{tikzpicture}
% \end{codeexample}
%
%
% \subsubsection{Combined Use of Matrices and Chains}
%
% Ilka's final idea is to combine matrices and chains in the following
% manner: She will use a matrix to position the nodes. However, to show
% the logical ``flow structure'' inside the diagram, she will create
% chains and branches that show what is going on.
%
% Ilka starts with the matrix we had earlier, only with slightly adapted
% styles. Then she writes down the main chain and its branches:
%
% \begin{codeexample}[preamble={\usetikzlibrary{arrows.meta}}]
% \begin{tikzpicture}[point/.style={coordinate},>={Stealth[round]},thick,draw=black!50,
%                     tip/.style={->,shorten >=1pt},every join/.style={rounded corners},
%                     hv path/.style={to path={-| (\tikztotarget)}},
%                     vh path/.style={to path={|- (\tikztotarget)}}]
%   \matrix[column sep=4mm] {
%     % First row:
%     & & & & & & &  & & & & \node (plus) [terminal] {+};\\
%     % Second row:
%     \node (p1) [point]  {}; &    \node (ui1)   [nonterminal] {unsigned integer}; &
%     \node (p2) [point]  {}; &    \node (dot)   [terminal]    {.};                &
%     \node (p3) [point]  {}; &    \node (digit) [terminal]    {digit};            &
%     \node (p4) [point]  {}; &    \node (p5)    [point]  {};                      &
%     \node (p6) [point]  {}; &    \node (e)     [terminal]    {E};                &
%     \node (p7) [point]  {}; &                                                    &
%     \node (p8) [point]  {}; &    \node (ui2)   [nonterminal] {unsigned integer}; &
%     \node (p9) [point]  {}; &    \node (p10)   [point]       {};\\
%     % Third row:
%     & & & & & & &  & & & & \node (minus)[terminal] {-};\\
%   };
%
%   { [start chain]
%     \chainin (p1);
%     \chainin (ui1)   [join=by tip];
%     \chainin (p2)    [join];
%     \chainin (dot)   [join=by tip];
%     \chainin (p3)    [join];
%     \chainin (digit) [join=by tip];
%     \chainin (p4)    [join];
%     { [start branch=digit loop]
%       \chainin (p3) [join=by {skip loop=-6mm,tip}];
%     }
%     \chainin (p5)    [join,join=with p2 by {skip loop=6mm,tip}];
%     \chainin (p6)    [join];
%     \chainin (e)     [join=by tip];
%     \chainin (p7)    [join];
%     { [start branch=plus]
%       \chainin (plus)  [join=by {vh path,tip}];
%       \chainin (p8)    [join=by {hv path,tip}];
%     }
%     { [start branch=minus]
%       \chainin (minus) [join=by {vh path,tip}];
%       \chainin (p8)    [join=by {hv path,tip}];
%     }
%     \chainin (p8)    [join];
%     \chainin (ui2)   [join=by tip];
%     \chainin (p9)    [join,join=with p6 by {skip loop=-11mm,tip}];
%     \chainin (p10)   [join=by tip];
%   }
% \end{tikzpicture}
% \end{codeexample}
