% Copyright 2020 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Free Documentation License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.


% \section{Tutorial: A Petri-Net for Hagen\\教程：Hagen的Petri网}

% In this second tutorial we explore the node mechanism of \tikzname\ and
% \pgfname.

% 在这个第二个教程中，我们将探索\tikzname\ 和 \pgfname\ 的节点机制。

% Hagen must give a talk tomorrow about his favorite formalism for distributed
% systems: Petri nets! Hagen used to give his talks using a blackboard and
% everyone seemed to be perfectly content with this. Unfortunately, his audience
% has been spoiled recently with fancy projector-based presentations and there
% seems to be a certain amount of peer pressure that his Petri nets should also
% be drawn using a graphic program. One of the professors at his institute
% recommends \tikzname\ for this and Hagen decides to give it a try.

% Hagen必须在明天做关于他最喜欢的分布式系统形式主义——Petri网的演讲！Hagen过去通常使用黑板来进行演讲，而且每个人似乎对此都非常满意。不幸的是，最近他的观众被时髦的投影仪演示所宠坏了，似乎有一定的压力要求他的Petri网也必须使用图形程序绘制。他所在学院的一位教授推荐使用\tikzname\ ，于是Hagen决定试一试。


% \subsection{Problem Statement\\问题陈述}

% For his talk, Hagen wishes to create a graphic that demonstrates how a net with
% place capacities can be simulated by a net without capacities. The graphic
% should look like this, ideally:

% 为了他的演讲，Hagen希望创建一个图形，演示带有位置容量的网如何通过没有容量的网进行模拟。理想情况下，图形应该如下所示：


% \begin{quote}
% \begin{tikzpicture}
%   [node distance=1.3cm,>={Stealth[round]},bend angle=45,auto,
%    place/.style={circle,thick,draw=blue!75,fill=blue!20,minimum size=6mm},
%    red place/.style={place,draw=red!75,fill=red!20},
%    transition/.style={rectangle,thick,draw=black!75,fill=black!20,minimum size=4mm},
%    every label/.style={red},on grid]

%   \begin{scope}
%     % First net
%     \node [place,tokens=1] (w1)                                    {};
%     \node [place] (c1) [below=of w1]                      {};
%     \node [place] (s)  [below=of c1,label=above:$s\le 3$] {};
%     \node [place] (c2) [below=of s]                       {};
%     \node [place,tokens=1] (w2) [below=of c2]                      {};

%     \node [transition] (e1) [left=of c1] {}
%       edge [pre,bend left]                  (w1)
%       edge [post,bend right]                (s)
%       edge [post]                           (c1);

%     \node [transition] (e2) [left=of c2] {}
%       edge [pre,bend right]                 (w2)
%       edge [post,bend left]                 (s)
%       edge [post]                           (c2);

%     \node [transition] (l1) [right=of c1] {}
%       edge [pre]                            (c1)
%       edge [pre,bend left]                  (s)
%       edge [post,bend right] node[swap] {2} (w1);

%     \node [transition] (l2) [right=of c2] {}
%       edge [pre]                            (c2)
%       edge [pre,bend right]                 (s)
%       edge [post,bend left]  node {2}       (w2);
%   \end{scope}

%   \begin{scope}[xshift=6cm]
%     % Second net
%     \node [place,tokens=1]
%                       (w1')                                                {};
%     \node [place]     (c1') [below=of w1']                                 {};
%     \node [red place] (s1') [below=of c1',xshift=-5mm,label=left:$s$]      {};
%     \node [red place,tokens=3]
%                       (s2') [below=of c1',xshift=5mm,label=right:$\bar s$] {};
%     \node [place]     (c2') [below=of s1',xshift=5mm]                      {};
%     \node [place,tokens=1]
%                       (w2') [below=of c2']                                 {};

%     \node [transition] (e1') [left=of c1'] {}
%       edge [pre,bend left]                  (w1')
%       edge [post]                           (s1')
%       edge [pre]                            (s2')
%       edge [post]                           (c1');

%     \node [transition] (e2') [left=of c2'] {}
%       edge [pre,bend right]                 (w2')
%       edge [post]                           (s1')
%       edge [pre]                            (s2')
%       edge [post]                           (c2');

%     \node [transition] (l1') [right=of c1'] {}
%       edge [pre]                            (c1')
%       edge [pre]                            (s1')
%       edge [post]                           (s2')
%       edge [post,bend right] node[swap] {2} (w1');

%     \node [transition] (l2') [right=of c2'] {}
%       edge [pre]                            (c2')
%       edge [pre]                            (s1')
%       edge [post]                           (s2')
%       edge [post,bend left]  node {2}       (w2');
%   \end{scope}

%   \begin{scope}[on background layer]
%     \node (r1) [fill=black!10,rounded corners,fit=(w1)(w2)(e1)(e2)(l1)(l2)] {};
%     \node (r2) [fill=black!10,rounded corners,fit=(w1')(w2')(e1')(e2')(l1')(l2')] {};
%   \end{scope}

%   \draw [shorten >=1mm,->,thick,decorate,decoration={snake,amplitude=.4mm,segment
%       length=2mm,pre=moveto,pre length=1mm,post length=2mm}]
%     (r1) -- (r2)
%     node [above=1mm,midway,text width=3cm,align=center]
%       {replacement of the \textcolor{red}{capacity} by \textcolor{red}{two places}};

% \end{tikzpicture}
% \end{quote}

% \subsection{Setting up the Environment\\设置环境}

% For the picture Hagen will need to load the \tikzname\ package as did Karl in
% the previous tutorial. However, Hagen will also need to load some additional
% \emph{library packages} that Karl did not need. These library packages contain
% additional definitions like extra arrow tips that are typically not needed in a
% picture and that need to be loaded explicitly.

% 对于图片，Hagen需要加载\tikzname\ 包，就像Karl在前一个教程中所做的一样。然而，Hagen还需要加载一些Karl不需要的额外\emph{库包}。这些库包包含了额外的定义，如通常不需要在图片中使用的额外箭头样式，需要显式地加载。


% Hagen will need to load several libraries: The |arrows.meta| library for the
% special arrow tip used in the graphic, the |decorations.pathmorphing| library
% for the ``snaking line'' in the middle, the |backgrounds| library for the two
% rectangular areas that are behind the two main parts of the picture, the |fit|
% library to easily compute the sizes of these rectangles, and the |positioning|
% library for placing nodes relative to other nodes.

% Hagen需要加载几个库：|arrows.meta| 库用于图形中使用的特殊箭头样式，|decorations.pathmorphing| 库用于中间的``蛇形线''，|backgrounds| 库用于两个主要部分后面的两个矩形区域，|fit| 库用于轻松计算这些矩形的尺寸，以及|positioning| 库用于相对于其他节点放置节点。


% \subsubsection{Setting up the Environment in \LaTeX\\在\LaTeX 中设置环境}

% When using \LaTeX\ use:
% %

% 在使用\LaTeX 时，使用以下代码：
% \begin{codeexample}[code only]
% \documentclass{article} % say

% \usepackage{tikz}
% \usetikzlibrary{arrows.meta,decorations.pathmorphing,backgrounds,positioning,fit,petri}

% \begin{document}
% \begin{tikzpicture}
%   \draw (0,0) -- (1,1);
% \end{tikzpicture}
% \end{document}
% \end{codeexample}


% \subsubsection{Setting up the Environment in Plain \TeX\\在Plain \TeX 中设置环境}

% When using plain \TeX\ use:

% 在使用Plain \TeX 时，使用以下代码：

% \begin{codeexample}[code only]
% %% Plain TeX file
% \input tikz.tex
% \usetikzlibrary{arrows.meta,decorations.pathmorphing,backgrounds,positioning,fit,petri}
% \baselineskip=12pt
% \hsize=6.3truein
% \vsize=8.7truein
% \tikzpicture
%   \draw (0,0) -- (1,1);
% \endtikzpicture
% \bye
% \end{codeexample}


% \subsubsection{Setting up the Environment in Con\TeX t\\在Con\TeX t 中设置环境}

% When using Con\TeX t, use:

% 在使用Con\TeX t时，使用以下代码：


% \begin{codeexample}[code only]
% %% ConTeXt file
% \usemodule[tikz]
% \usetikzlibrary[arrows.meta,decorations.pathmorphing,backgrounds,positioning,fit,petri]

% \starttext
%   \starttikzpicture
%     \draw (0,0) -- (1,1);
%   \stoptikzpicture
% \stoptext
% \end{codeexample}



% \subsection{Introduction to Nodes\\节点简介}

% In principle, we already know how to create the graphics that Hagen desires
% (except perhaps for the snaked line, we will come to that): We start with big
% light gray rectangle and then add lots of circles and small rectangle, plus
% some arrows.

% 原则上，我们已经知道如何创建Hagen所需的图形（也许除了蛇形线，我们将在后面讨论它）：我们从一个大的浅灰色矩形开始，然后添加许多圆圈和小矩形，以及一些箭头。

% However, this approach has numerous disadvantages: First, it is hard to change
% anything at a later stage. For example, if we decide to add more places to the
% Petri nets (the circles are called places in Petri net theory), all of the
% coordinates change and we need to recalculate everything. Second, it is hard to
% read the code for the Petri net as it is just a long and complicated list of
% coordinates and drawing commands -- the underlying structure of the Petri net
% is lost.

% 然而，这种方法有许多缺点：首先，在后期更改任何内容都很困难。例如，如果我们决定向Petri网中添加更多的库所（在Petri网理论中，圆圈被称为库所），所有的坐标都会改变，我们需要重新计算所有内容。其次，很难阅读Petri网的代码，因为它只是一个冗长而复杂的坐标和绘图命令列表——Petri网的底层结构丢失了。

% Fortunately, \tikzname\ offers a powerful mechanism for avoiding the above
% problems: nodes. We already came across nodes in the previous tutorial, where
% we used them to add labels to Karl's graphic. In the present tutorial we will
% see that nodes are much more powerful.

% 幸运的是，\tikzname\ 提供了一个强大的机制来避免上述问题：节点。在前一个教程中，我们已经了解到节点，我们用它们来为Karl的图形添加标签。在本教程中，我们将看到节点更加强大。

% A node is a small part of a picture. When a node is created, you provide a
% position where the node should be drawn and a \emph{shape}. A node of shape
% |circle| will be drawn as a circle, a node of shape |rectangle| as a rectangle,
% and so on. A node may also contain some text, which is why Karl used nodes to
% show text. Finally, a node can get a \emph{name} for later reference.

% 节点是图片的一个小部分。当创建一个节点时，需要提供节点应该绘制的位置和一个\emph{形状}。形状为|circle|的节点将绘制为圆，形状为|rectangle|的节点将绘制为矩形，等等。节点还可以包含一些文本，这就是为什么Karl使用节点来显示文本。最后，节点可以获得一个\emph{名称}以供以后引用。

% In Hagen's picture we will use nodes for the places and for the transitions of
% the Petri net (the places are the circles, the transitions are the rectangles).
% Let us start with the upper half of the left Petri net. In this upper half we
% have three places and two transitions. Instead of drawing three circles and two
% rectangles, we use three nodes of shape |circle| and two nodes of shape
% |rectangle|.
% %

% 在Hagen的图片中，我们将使用节点来表示Petri网的库所和变迁（库所是圆圈，变迁是矩形）。让我们从左侧Petri网的上半部分开始。在这个上半部分，我们有三个库所和两个变迁。我们不使用三个圆圈和两个矩形来绘制，而是使用三个形状为|circle|的节点和两个形状为|rectangle|的节点。%

% \begin{codeexample}[]
% \begin{tikzpicture}
%   \path ( 0,2) node [shape=circle,draw] {}
%         ( 0,1) node [shape=circle,draw] {}
%         ( 0,0) node [shape=circle,draw] {}
%         ( 1,1) node [shape=rectangle,draw] {}
%         (-1,1) node [shape=rectangle,draw] {};
% \end{tikzpicture}
% \end{codeexample}


% Hagen notes that this does not quite look like the final picture, but it seems
% like a good first step.

% Hagen指出，这看起来还不像最终的图片，但它似乎是一个不错的第一步。

% Let us have a more detailed look at the code. The whole picture consists of a
% single path. Ignoring the |node| operations, there is not much going on in this
% path: It is just a sequence of coordinates with nothing ``happening'' between
% them. Indeed, even if something were to happen like a line-to or a curve-to,
% the |\path| command would not ``do'' anything with the resulting path. So, all
% the magic must be in the |node| commands.

% 让我们详细看一下代码。整个图片由一个路径组成。忽略|node|操作，这个路径中没有太多的东西：它只是一系列的坐标，它们之间没有发生任何事情。事实上，即使有什么事情发生，比如画线或曲线，|\path|命令也不会对生成的路径做任何操作。因此，所有的奇迹必须在|node|命令中。

% In the previous tutorial we learned that a |node| will add a piece of text at
% the last coordinate. Thus, each of the five nodes is added at a different
% position. In the above code, this text is empty (because of the empty |{}|).
% So, why do we see anything at all? The answer is the |draw| option for the
% |node| operation: It causes the ``shape around the text'' to be drawn.

% 在上一篇教程中，我们学到了|node|会在最后一个坐标上添加一段文本。因此，五个节点中的每一个都会添加在不同的位置。在上面的代码中，这段文本是空的（因为是空的|{}|）。那么为什么我们看到了任何东西呢？答案是|node|操作中的|draw|选项：它导致``文本周围的形状''被绘制出来。

% So, the code |(0,2) node [shape=circle,draw] {}| means the following: ``In the
% main path, add a move-to to the coordinate |(0,2)|. Then, temporarily suspend
% the construction of the main path while the node is built. This node will be a
% |circle| around an empty text. This circle is to be |draw|n, but not filled or
% otherwise used. Once this whole node is constructed, it is saved until after
% the main path is finished. Then, it is drawn.'' The following
% |(0,1) node [shape=circle,draw] {}| then has the following effect: ``Continue
% the main path with a move-to to |(0,1)|. Then construct a node at this position
% also. This node is also shown after the main path is finished.'' And so on.

% 所以，代码|(0,2) node [shape=circle,draw] {}|的意思是：在主路径中，添加一个移动到坐标|(0,2)|的操作。然后，在构建主路径时，临时暂停，直到节点被构建完成。这个节点将是一个围绕着空文本的|circle|。这个圆要被绘制，但不填充或以其他方式使用。一旦整个节点构建完成，它就会被保存，直到主路径完成后再被绘制。''接下来的|(0,1) node [shape=circle,draw] {}|的效果是：用一个移动到|(0,1)|的操作继续主路径。然后在这个位置上构建一个节点。这个节点也会在主路径完成后显示。''依此类推。



% \subsection{Placing Nodes Using the At Syntax\\使用At语法放置节点}

% Hagen now understands how the |node| operation adds nodes to the path, but it
% seems a bit silly to create a path using the |\path| operation, consisting of
% numerous superfluous move-to operations, only to place nodes. He is pleased to
% learn that there are ways to add nodes in a more sensible manner.

% Hagen现在明白了|node|操作是如何将节点添加到路径中的，但是只使用|\path|操作创建一个包含许多多余的移动操作的路径来放置节点似乎有点愚蠢。他很高兴地得知有更合理的方法来添加节点。

% First, the |node| operation allows one to add |at (|\meta{coordinate}|)| in
% order to directly specify where the node should be placed, sidestepping the
% rule that nodes are placed on the last coordinate. Hagen can then write the
% following:

% 首先，|node|操作允许在|at (|\meta{coordinate}|)|中直接指定节点应该放置的位置，绕过了节点放置在最后一个坐标上的规则。Hagen可以这样写：
% %
% \begin{codeexample}[]
% \begin{tikzpicture}
%   \path node at ( 0,2) [shape=circle,draw] {}
%         node at ( 0,1) [shape=circle,draw] {}
%         node at ( 0,0) [shape=circle,draw] {}
%         node at ( 1,1) [shape=rectangle,draw] {}
%         node at (-1,1) [shape=rectangle,draw] {};
% \end{tikzpicture}
% \end{codeexample}

% Now Hagen is still left with a single empty path, but at least the path no
% longer contains strange move-to's. It turns out that this can be improved
% further: The |\node| command is an abbreviation for |\path node|, which allows
% Hagen to write:

% 现在Hagen还是得到了一个空路径，但至少路径不再包含奇怪的移动操作了。事实证明，这还可以进一步改进：|\node|命令是|\path node|的缩写形式，这使得Hagen可以这样写：
% %
% \begin{codeexample}[]
% \begin{tikzpicture}
%   \node at ( 0,2) [circle,draw] {};
%   \node at ( 0,1) [circle,draw] {};
%   \node at ( 0,0) [circle,draw] {};
%   \node at ( 1,1) [rectangle,draw] {};
%   \node at (-1,1) [rectangle,draw] {};
% \end{tikzpicture}
% \end{codeexample}

% Hagen likes this syntax much better than the previous one. Note that Hagen has
% also omitted the |shape=| since, like |color=|, \tikzname\ allows you to omit
% the |shape=| if there is no confusion.

% % Hagen比起之前的语法更喜欢这种语法。请注意，Hagen还省略了|shape=|，因为像|color=|一样，如果没有混淆，\tikzname\ 允许省略|shape=|。

% Hagen非常喜欢这种语法，比起之前的语法要好得多。请注意，Hagen还省略了|shape=|，因为像|color=|一样，如果没有混淆，\tikzname 允许省略|shape=|。




% \subsection{Using Styles\\使用样式}

% Feeling adventurous, Hagen tries to make the nodes look nicer. In the final
% picture, the circles and rectangle should be filled with different colors,
% resulting in the following code:

% Hagen感到充满冒险精神，试图让节点看起来更漂亮。在最终的图片中，圆圈和矩形应该用不同的颜色填充，代码如下所示：

% %
% \begin{codeexample}[]
% \begin{tikzpicture}[thick]
%   \node at ( 0,2) [circle,draw=blue!50,fill=blue!20] {};
%   \node at ( 0,1) [circle,draw=blue!50,fill=blue!20] {};
%   \node at ( 0,0) [circle,draw=blue!50,fill=blue!20] {};
%   \node at ( 1,1) [rectangle,draw=black!50,fill=black!20] {};
%   \node at (-1,1) [rectangle,draw=black!50,fill=black!20] {};
% \end{tikzpicture}
% \end{codeexample}

% While this looks nicer in the picture, the code starts to get a bit ugly.
% Ideally, we would like our code to transport the message ``there are three
% places and two transitions'' and not so much which filling colors should be
% used.

% 虽然这在图片中看起来更漂亮，但代码变得有点丑陋。理想情况下，我们希望我们的代码传达的是"有三个位置和两个转换"这一信息，而不是使用哪些填充颜色。

% To solve this problem, Hagen uses styles. He defines a style for places and
% another style for transitions:

% 为了解决这个问题，Hagen使用样式。他为位置定义了一个样式，为转换定义了另一个样式：

% %
% \begin{codeexample}[]
% \begin{tikzpicture}
%   [place/.style={circle,draw=blue!50,fill=blue!20,thick},
%    transition/.style={rectangle,draw=black!50,fill=black!20,thick}]
%   \node at ( 0,2) [place] {};
%   \node at ( 0,1) [place] {};
%   \node at ( 0,0) [place] {};
%   \node at ( 1,1) [transition] {};
%   \node at (-1,1) [transition] {};
% \end{tikzpicture}
% \end{codeexample}


