% Copyright 2020 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Free Documentation License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.


% \section{Tutorial: A Petri-Net for Hagen\\教程：Hagen的Petri网}

% In this second tutorial we explore the node mechanism of \tikzname\ and
% \pgfname.

% 在这个第二个教程中，我们将探索\tikzname\ 和 \pgfname\ 的节点机制。

% Hagen must give a talk tomorrow about his favorite formalism for distributed
% systems: Petri nets! Hagen used to give his talks using a blackboard and
% everyone seemed to be perfectly content with this. Unfortunately, his audience
% has been spoiled recently with fancy projector-based presentations and there
% seems to be a certain amount of peer pressure that his Petri nets should also
% be drawn using a graphic program. One of the professors at his institute
% recommends \tikzname\ for this and Hagen decides to give it a try.

% Hagen必须在明天做关于他最喜欢的分布式系统形式主义——Petri网的演讲！Hagen过去通常使用黑板来进行演讲，而且每个人似乎对此都非常满意。不幸的是，最近他的观众被时髦的投影仪演示所宠坏了，似乎有一定的压力要求他的Petri网也必须使用图形程序绘制。他所在学院的一位教授推荐使用\tikzname\ ，于是Hagen决定试一试。


% \subsection{Problem Statement\\问题陈述}

% For his talk, Hagen wishes to create a graphic that demonstrates how a net with
% place capacities can be simulated by a net without capacities. The graphic
% should look like this, ideally:

% 为了他的演讲，Hagen希望创建一个图形，演示带有位置容量的网如何通过没有容量的网进行模拟。理想情况下，图形应该如下所示：


% \begin{quote}
% \begin{tikzpicture}
%   [node distance=1.3cm,>={Stealth[round]},bend angle=45,auto,
%    place/.style={circle,thick,draw=blue!75,fill=blue!20,minimum size=6mm},
%    red place/.style={place,draw=red!75,fill=red!20},
%    transition/.style={rectangle,thick,draw=black!75,fill=black!20,minimum size=4mm},
%    every label/.style={red},on grid]

%   \begin{scope}
%     % First net
%     \node [place,tokens=1] (w1)                                    {};
%     \node [place] (c1) [below=of w1]                      {};
%     \node [place] (s)  [below=of c1,label=above:$s\le 3$] {};
%     \node [place] (c2) [below=of s]                       {};
%     \node [place,tokens=1] (w2) [below=of c2]                      {};

%     \node [transition] (e1) [left=of c1] {}
%       edge [pre,bend left]                  (w1)
%       edge [post,bend right]                (s)
%       edge [post]                           (c1);

%     \node [transition] (e2) [left=of c2] {}
%       edge [pre,bend right]                 (w2)
%       edge [post,bend left]                 (s)
%       edge [post]                           (c2);

%     \node [transition] (l1) [right=of c1] {}
%       edge [pre]                            (c1)
%       edge [pre,bend left]                  (s)
%       edge [post,bend right] node[swap] {2} (w1);

%     \node [transition] (l2) [right=of c2] {}
%       edge [pre]                            (c2)
%       edge [pre,bend right]                 (s)
%       edge [post,bend left]  node {2}       (w2);
%   \end{scope}

%   \begin{scope}[xshift=6cm]
%     % Second net
%     \node [place,tokens=1]
%                       (w1')                                                {};
%     \node [place]     (c1') [below=of w1']                                 {};
%     \node [red place] (s1') [below=of c1',xshift=-5mm,label=left:$s$]      {};
%     \node [red place,tokens=3]
%                       (s2') [below=of c1',xshift=5mm,label=right:$\bar s$] {};
%     \node [place]     (c2') [below=of s1',xshift=5mm]                      {};
%     \node [place,tokens=1]
%                       (w2') [below=of c2']                                 {};

%     \node [transition] (e1') [left=of c1'] {}
%       edge [pre,bend left]                  (w1')
%       edge [post]                           (s1')
%       edge [pre]                            (s2')
%       edge [post]                           (c1');

%     \node [transition] (e2') [left=of c2'] {}
%       edge [pre,bend right]                 (w2')
%       edge [post]                           (s1')
%       edge [pre]                            (s2')
%       edge [post]                           (c2');

%     \node [transition] (l1') [right=of c1'] {}
%       edge [pre]                            (c1')
%       edge [pre]                            (s1')
%       edge [post]                           (s2')
%       edge [post,bend right] node[swap] {2} (w1');

%     \node [transition] (l2') [right=of c2'] {}
%       edge [pre]                            (c2')
%       edge [pre]                            (s1')
%       edge [post]                           (s2')
%       edge [post,bend left]  node {2}       (w2');
%   \end{scope}

%   \begin{scope}[on background layer]
%     \node (r1) [fill=black!10,rounded corners,fit=(w1)(w2)(e1)(e2)(l1)(l2)] {};
%     \node (r2) [fill=black!10,rounded corners,fit=(w1')(w2')(e1')(e2')(l1')(l2')] {};
%   \end{scope}

%   \draw [shorten >=1mm,->,thick,decorate,decoration={snake,amplitude=.4mm,segment
%       length=2mm,pre=moveto,pre length=1mm,post length=2mm}]
%     (r1) -- (r2)
%     node [above=1mm,midway,text width=3cm,align=center]
%       {replacement of the \textcolor{red}{capacity} by \textcolor{red}{two places}};

% \end{tikzpicture}
% \end{quote}

% \subsection{Setting up the Environment\\设置环境}

% For the picture Hagen will need to load the \tikzname\ package as did Karl in
% the previous tutorial. However, Hagen will also need to load some additional
% \emph{library packages} that Karl did not need. These library packages contain
% additional definitions like extra arrow tips that are typically not needed in a
% picture and that need to be loaded explicitly.

% 对于图片，Hagen需要加载\tikzname\ 包，就像Karl在前一个教程中所做的一样。然而，Hagen还需要加载一些Karl不需要的额外\emph{库包}。这些库包包含了额外的定义，如通常不需要在图片中使用的额外箭头样式，需要显式地加载。


% Hagen will need to load several libraries: The |arrows.meta| library for the
% special arrow tip used in the graphic, the |decorations.pathmorphing| library
% for the ``snaking line'' in the middle, the |backgrounds| library for the two
% rectangular areas that are behind the two main parts of the picture, the |fit|
% library to easily compute the sizes of these rectangles, and the |positioning|
% library for placing nodes relative to other nodes.

% Hagen需要加载几个库：|arrows.meta| 库用于图形中使用的特殊箭头样式，|decorations.pathmorphing| 库用于中间的``蛇形线''，|backgrounds| 库用于两个主要部分后面的两个矩形区域，|fit| 库用于轻松计算这些矩形的尺寸，以及|positioning| 库用于相对于其他节点放置节点。


% \subsubsection{Setting up the Environment in \LaTeX\\在\LaTeX 中设置环境}

% When using \LaTeX\ use:
% %

% 在使用\LaTeX 时，使用以下代码：
% \begin{codeexample}[code only]
% \documentclass{article} % say

% \usepackage{tikz}
% \usetikzlibrary{arrows.meta,decorations.pathmorphing,backgrounds,positioning,fit,petri}

% \begin{document}
% \begin{tikzpicture}
%   \draw (0,0) -- (1,1);
% \end{tikzpicture}
% \end{document}
% \end{codeexample}


% \subsubsection{Setting up the Environment in Plain \TeX\\在Plain \TeX 中设置环境}

% When using plain \TeX\ use:

% 在使用Plain \TeX 时，使用以下代码：

% \begin{codeexample}[code only]
% %% Plain TeX file
% \input tikz.tex
% \usetikzlibrary{arrows.meta,decorations.pathmorphing,backgrounds,positioning,fit,petri}
% \baselineskip=12pt
% \hsize=6.3truein
% \vsize=8.7truein
% \tikzpicture
%   \draw (0,0) -- (1,1);
% \endtikzpicture
% \bye
% \end{codeexample}


% \subsubsection{Setting up the Environment in Con\TeX t\\在Con\TeX t 中设置环境}

% When using Con\TeX t, use:

% 在使用Con\TeX t时，使用以下代码：


% \begin{codeexample}[code only]
% %% ConTeXt file
% \usemodule[tikz]
% \usetikzlibrary[arrows.meta,decorations.pathmorphing,backgrounds,positioning,fit,petri]

% \starttext
%   \starttikzpicture
%     \draw (0,0) -- (1,1);
%   \stoptikzpicture
% \stoptext
% \end{codeexample}



% \subsection{Introduction to Nodes\\节点简介}

% In principle, we already know how to create the graphics that Hagen desires
% (except perhaps for the snaked line, we will come to that): We start with big
% light gray rectangle and then add lots of circles and small rectangle, plus
% some arrows.

% 原则上，我们已经知道如何创建Hagen所需的图形（也许除了蛇形线，我们将在后面讨论它）：我们从一个大的浅灰色矩形开始，然后添加许多圆圈和小矩形，以及一些箭头。

% However, this approach has numerous disadvantages: First, it is hard to change
% anything at a later stage. For example, if we decide to add more places to the
% Petri nets (the circles are called places in Petri net theory), all of the
% coordinates change and we need to recalculate everything. Second, it is hard to
% read the code for the Petri net as it is just a long and complicated list of
% coordinates and drawing commands -- the underlying structure of the Petri net
% is lost.

% 然而，这种方法有许多缺点：首先，在后期更改任何内容都很困难。例如，如果我们决定向Petri网中添加更多的库所（在Petri网理论中，圆圈被称为库所），所有的坐标都会改变，我们需要重新计算所有内容。其次，很难阅读Petri网的代码，因为它只是一个冗长而复杂的坐标和绘图命令列表——Petri网的底层结构丢失了。

% Fortunately, \tikzname\ offers a powerful mechanism for avoiding the above
% problems: nodes. We already came across nodes in the previous tutorial, where
% we used them to add labels to Karl's graphic. In the present tutorial we will
% see that nodes are much more powerful.

% 幸运的是，\tikzname\ 提供了一个强大的机制来避免上述问题：节点。在前一个教程中，我们已经了解到节点，我们用它们来为Karl的图形添加标签。在本教程中，我们将看到节点更加强大。

% A node is a small part of a picture. When a node is created, you provide a
% position where the node should be drawn and a \emph{shape}. A node of shape
% |circle| will be drawn as a circle, a node of shape |rectangle| as a rectangle,
% and so on. A node may also contain some text, which is why Karl used nodes to
% show text. Finally, a node can get a \emph{name} for later reference.

% 节点是图片的一个小部分。当创建一个节点时，需要提供节点应该绘制的位置和一个\emph{形状}。形状为|circle|的节点将绘制为圆，形状为|rectangle|的节点将绘制为矩形，等等。节点还可以包含一些文本，这就是为什么Karl使用节点来显示文本。最后，节点可以获得一个\emph{名称}以供以后引用。

% In Hagen's picture we will use nodes for the places and for the transitions of
% the Petri net (the places are the circles, the transitions are the rectangles).
% Let us start with the upper half of the left Petri net. In this upper half we
% have three places and two transitions. Instead of drawing three circles and two
% rectangles, we use three nodes of shape |circle| and two nodes of shape
% |rectangle|.
% %

% 在Hagen的图片中，我们将使用节点来表示Petri网的库所和变迁（库所是圆圈，变迁是矩形）。让我们从左侧Petri网的上半部分开始。在这个上半部分，我们有三个库所和两个变迁。我们不使用三个圆圈和两个矩形来绘制，而是使用三个形状为|circle|的节点和两个形状为|rectangle|的节点。%

% \begin{codeexample}[]
% \begin{tikzpicture}
%   \path ( 0,2) node [shape=circle,draw] {}
%         ( 0,1) node [shape=circle,draw] {}
%         ( 0,0) node [shape=circle,draw] {}
%         ( 1,1) node [shape=rectangle,draw] {}
%         (-1,1) node [shape=rectangle,draw] {};
% \end{tikzpicture}
% \end{codeexample}


% Hagen notes that this does not quite look like the final picture, but it seems
% like a good first step.

% Hagen指出，这看起来还不像最终的图片，但它似乎是一个不错的第一步。

% Let us have a more detailed look at the code. The whole picture consists of a
% single path. Ignoring the |node| operations, there is not much going on in this
% path: It is just a sequence of coordinates with nothing ``happening'' between
% them. Indeed, even if something were to happen like a line-to or a curve-to,
% the |\path| command would not ``do'' anything with the resulting path. So, all
% the magic must be in the |node| commands.

% 让我们详细看一下代码。整个图片由一个路径组成。忽略|node|操作，这个路径中没有太多的东西：它只是一系列的坐标，它们之间没有发生任何事情。事实上，即使有什么事情发生，比如画线或曲线，|\path|命令也不会对生成的路径做任何操作。因此，所有的奇迹必须在|node|命令中。

% In the previous tutorial we learned that a |node| will add a piece of text at
% the last coordinate. Thus, each of the five nodes is added at a different
% position. In the above code, this text is empty (because of the empty |{}|).
% So, why do we see anything at all? The answer is the |draw| option for the
% |node| operation: It causes the ``shape around the text'' to be drawn.

% 在上一篇教程中，我们学到了|node|会在最后一个坐标上添加一段文本。因此，五个节点中的每一个都会添加在不同的位置。在上面的代码中，这段文本是空的（因为是空的|{}|）。那么为什么我们看到了任何东西呢？答案是|node|操作中的|draw|选项：它导致``文本周围的形状''被绘制出来。

% So, the code |(0,2) node [shape=circle,draw] {}| means the following: ``In the
% main path, add a move-to to the coordinate |(0,2)|. Then, temporarily suspend
% the construction of the main path while the node is built. This node will be a
% |circle| around an empty text. This circle is to be |draw|n, but not filled or
% otherwise used. Once this whole node is constructed, it is saved until after
% the main path is finished. Then, it is drawn.'' The following
% |(0,1) node [shape=circle,draw] {}| then has the following effect: ``Continue
% the main path with a move-to to |(0,1)|. Then construct a node at this position
% also. This node is also shown after the main path is finished.'' And so on.

% 所以，代码|(0,2) node [shape=circle,draw] {}|的意思是：在主路径中，添加一个移动到坐标|(0,2)|的操作。然后，在构建主路径时，临时暂停，直到节点被构建完成。这个节点将是一个围绕着空文本的|circle|。这个圆要被绘制，但不填充或以其他方式使用。一旦整个节点构建完成，它就会被保存，直到主路径完成后再被绘制。''接下来的|(0,1) node [shape=circle,draw] {}|的效果是：用一个移动到|(0,1)|的操作继续主路径。然后在这个位置上构建一个节点。这个节点也会在主路径完成后显示。''依此类推。



% \subsection{Placing Nodes Using the At Syntax\\使用At语法放置节点}

% Hagen now understands how the |node| operation adds nodes to the path, but it
% seems a bit silly to create a path using the |\path| operation, consisting of
% numerous superfluous move-to operations, only to place nodes. He is pleased to
% learn that there are ways to add nodes in a more sensible manner.

% Hagen现在明白了|node|操作是如何将节点添加到路径中的，但是只使用|\path|操作创建一个包含许多多余的移动操作的路径来放置节点似乎有点愚蠢。他很高兴地得知有更合理的方法来添加节点。

% First, the |node| operation allows one to add |at (|\meta{coordinate}|)| in
% order to directly specify where the node should be placed, sidestepping the
% rule that nodes are placed on the last coordinate. Hagen can then write the
% following:

% 首先，|node|操作允许在|at (|\meta{coordinate}|)|中直接指定节点应该放置的位置，绕过了节点放置在最后一个坐标上的规则。Hagen可以这样写：
% %
% \begin{codeexample}[]
% \begin{tikzpicture}
%   \path node at ( 0,2) [shape=circle,draw] {}
%         node at ( 0,1) [shape=circle,draw] {}
%         node at ( 0,0) [shape=circle,draw] {}
%         node at ( 1,1) [shape=rectangle,draw] {}
%         node at (-1,1) [shape=rectangle,draw] {};
% \end{tikzpicture}
% \end{codeexample}

% Now Hagen is still left with a single empty path, but at least the path no
% longer contains strange move-to's. It turns out that this can be improved
% further: The |\node| command is an abbreviation for |\path node|, which allows
% Hagen to write:

% 现在Hagen还是得到了一个空路径，但至少路径不再包含奇怪的移动操作了。事实证明，这还可以进一步改进：|\node|命令是|\path node|的缩写形式，这使得Hagen可以这样写：
% %
% \begin{codeexample}[]
% \begin{tikzpicture}
%   \node at ( 0,2) [circle,draw] {};
%   \node at ( 0,1) [circle,draw] {};
%   \node at ( 0,0) [circle,draw] {};
%   \node at ( 1,1) [rectangle,draw] {};
%   \node at (-1,1) [rectangle,draw] {};
% \end{tikzpicture}
% \end{codeexample}

% Hagen likes this syntax much better than the previous one. Note that Hagen has
% also omitted the |shape=| since, like |color=|, \tikzname\ allows you to omit
% the |shape=| if there is no confusion.

% % Hagen比起之前的语法更喜欢这种语法。请注意，Hagen还省略了|shape=|，因为像|color=|一样，如果没有混淆，\tikzname\ 允许省略|shape=|。

% Hagen非常喜欢这种语法，比起之前的语法要好得多。请注意，Hagen还省略了|shape=|，因为像|color=|一样，如果没有混淆，\tikzname 允许省略|shape=|。




% \subsection{Using Styles\\使用样式}

% Feeling adventurous, Hagen tries to make the nodes look nicer. In the final
% picture, the circles and rectangle should be filled with different colors,
% resulting in the following code:

% Hagen感到充满冒险精神，试图让节点看起来更漂亮。在最终的图片中，圆圈和矩形应该用不同的颜色填充，代码如下所示：

% %
% \begin{codeexample}[]
% \begin{tikzpicture}[thick]
%   \node at ( 0,2) [circle,draw=blue!50,fill=blue!20] {};
%   \node at ( 0,1) [circle,draw=blue!50,fill=blue!20] {};
%   \node at ( 0,0) [circle,draw=blue!50,fill=blue!20] {};
%   \node at ( 1,1) [rectangle,draw=black!50,fill=black!20] {};
%   \node at (-1,1) [rectangle,draw=black!50,fill=black!20] {};
% \end{tikzpicture}
% \end{codeexample}

% While this looks nicer in the picture, the code starts to get a bit ugly.
% Ideally, we would like our code to transport the message ``there are three
% places and two transitions'' and not so much which filling colors should be
% used.

% 虽然这在图片中看起来更漂亮，但代码变得有点丑陋。理想情况下，我们希望我们的代码传达的是"有三个位置和两个转换"这一信息，而不是使用哪些填充颜色。

% To solve this problem, Hagen uses styles. He defines a style for places and
% another style for transitions:

% 为了解决这个问题，Hagen使用样式。他为位置定义了一个样式，为转换定义了另一个样式：

% %
% \begin{codeexample}[]
% \begin{tikzpicture}
%   [place/.style={circle,draw=blue!50,fill=blue!20,thick},
%    transition/.style={rectangle,draw=black!50,fill=black!20,thick}]
%   \node at ( 0,2) [place] {};
%   \node at ( 0,1) [place] {};
%   \node at ( 0,0) [place] {};
%   \node at ( 1,1) [transition] {};
%   \node at (-1,1) [transition] {};
% \end{tikzpicture}
% \end{codeexample}



% \subsection{Node Size\\节点大小}

% Before Hagen starts naming and connecting the nodes, let us first make sure
% that the nodes get their final appearance. They are still too small. Indeed,
% Hagen wonders why they have any size at all, after all, the text is empty. The
% reason is that \tikzname\ automatically adds some space around the text. The
% amount is set using the option |inner sep|. So, to increase the size of the
% nodes, Hagen could write:

% 在Hagen开始为节点命名和连接它们之前，我们先确保节点具有最终的外观。它们仍然太小了。实际上，Hagen想知道为什么它们有任何大小，毕竟文本是空的。原因是\tikzname\ 自动在文本周围添加一些空间。这个空间的大小由选项|inner sep|设置。因此，为了增加节点的大小，Hagen可以这样写：

% %
% \begin{codeexample}[]
% \begin{tikzpicture}
%   [inner sep=2mm,
%    place/.style={circle,draw=blue!50,fill=blue!20,thick},
%    transition/.style={rectangle,draw=black!50,fill=black!20,thick}]
%   \node at ( 0,2) [place] {};
%   \node at ( 0,1) [place] {};
%   \node at ( 0,0) [place] {};
%   \node at ( 1,1) [transition] {};
%   \node at (-1,1) [transition] {};
% \end{tikzpicture}
% \end{codeexample}

% However, this is not really the best way to achieve the desired effect. It is
% much better to use the |minimum size| option instead. This option allows Hagen
% to specify a minimum size that the node should have. If the node actually needs
% to be bigger because of a longer text, it will be larger, but if the text is
% empty, then the node will have |minimum size|. This option is also useful to
% ensure that several nodes containing different amounts of text have the same
% size. The options |minimum height| and |minimum width| allow you to specify the
% minimum height and width independently.

% 然而，这并不是实现所需效果的最佳方法。更好的方法是使用 |minimum size| 选项。该选项允许 Hagen 指定节点应具有的最小尺寸。如果节点因为较长的文本而需要更大的尺寸，它将变得更大，但如果文本为空，则节点将具有 |minimum size|。该选项还可用于确保包含不同文本量的多个节点具有相同的大小。选项 |minimum height| 和 |minimum width| 允许您单独指定最小高度和宽度。

% So, what Hagen needs to do is to provide |minimum size| for the nodes. To be on
% the safe side, he also sets |inner sep=0pt|. This ensures that the nodes will
% really have size |minimum size| and not, for very small minimum sizes, the
% minimal size necessary to encompass the automatically added space.

% 因此，Hagen 需要为节点提供 |minimum size|。为了保险起见，他还设置了 |inner sep=0pt|。这确保节点确实具有 |minimum size|，而不是对于非常小的最小尺寸，仅足以包含自动添加的空间的最小尺寸。

% %
% \begin{codeexample}[]
% \begin{tikzpicture}
%   [place/.style={circle,draw=blue!50,fill=blue!20,thick,
%                  inner sep=0pt,minimum size=6mm},
%    transition/.style={rectangle,draw=black!50,fill=black!20,thick,
%                       inner sep=0pt,minimum size=4mm}]
%   \node at ( 0,2) [place] {};
%   \node at ( 0,1) [place] {};
%   \node at ( 0,0) [place] {};
%   \node at ( 1,1) [transition] {};
%   \node at (-1,1) [transition] {};
% \end{tikzpicture}
% \end{codeexample}





% \subsection{Naming Nodes\\节点命名}

% Hagen's next aim is to connect the nodes using arrows. This seems like a tricky
% business since the arrows should not start in the middle of the nodes, but
% somewhere on the border and Hagen would very much like to avoid computing these
% positions by hand.

% Hagen的下一个目标是使用箭头连接节点。这似乎是一个棘手的问题，因为箭头不应该从节点的中间开始，而应该从边界的某个位置开始。Hagen非常希望避免手动计算这些位置。

% Fortunately, \pgfname\ will perform all the necessary calculations for him.
% However, he first has to assign names to the nodes so that he can reference
% them later on.

% 幸运的是，\pgfname\ 将为他执行所有必要的计算。但是，他首先必须给节点指定名称，以便以后可以引用它们。

% There are two ways to name a node. The first is to use the |name=| option. The
% second method is to write the desired name in parentheses after the |node|
% operation. Hagen thinks that this second method seems strange, but he will soon
% change his opinion.


% 有两种方法可以给节点命名。第一种方法是使用 |name=| 选项。第二种方法是在 |node| 操作后的括号中写入所需的名称。Hagen认为第二种方法似乎很奇怪，但他很快会改变自己的看法。
% %
% \begin{codeexample}[setup code,hidden]
% \tikzset{
%     place/.style={circle,draw=blue!50,fill=blue!20,thick,
%                   inner sep=0pt,minimum size=6mm},
%     transition/.style={rectangle,draw=black!50,fill=black!20,thick,
%                        inner sep=0pt,minimum size=4mm}
% }
% \end{codeexample}
% %
% \begin{codeexample}[]
% % ... set up styles
% \begin{tikzpicture}
%   \node (waiting 1)      at ( 0,2) [place] {};
%   \node (critical 1)     at ( 0,1) [place] {};
%   \node (semaphore)      at ( 0,0) [place] {};
%   \node (leave critical) at ( 1,1) [transition] {};
%   \node (enter critical) at (-1,1) [transition] {};
% \end{tikzpicture}
% \end{codeexample}

% Hagen is pleased to note that the names help in understanding the code. Names
% for nodes can be pretty arbitrary, but they should not contain commas, periods,
% parentheses, colons, and some other special characters. However, they can
% contain underscores and hyphens.

% Hagen很高兴地注意到，这些名称有助于理解代码。节点的名称可以是任意的，但是不能包含逗号、句点、括号、冒号和其他一些特殊字符。但是，它们可以包含下划线和连字符。



% The syntax for the |node| operation is quite liberal with respect to the order
% in which node names, the |at| specifier, and the options must come. Indeed, you
% can even have multiple option blocks between the |node| and the text in curly
% braces, they accumulate. You can rearrange them arbitrarily and perhaps the
% following might be preferable:


% 对于 |node| 操作，语法在节点名称、|at| 指定符和选项之间的顺序方面非常自由。实际上，你甚至可以在 |node| 和花括号中的文本之间有多个选项块，它们会累积起来。你可以任意重新排列它们，也许以下代码可能更可取：%
% \begin{codeexample}[]
% \begin{tikzpicture}
%   \node[place]      (waiting 1)      at ( 0,2) {};
%   \node[place]      (critical 1)     at ( 0,1) {};
%   \node[place]      (semaphore)      at ( 0,0) {};
%   \node[transition] (leave critical) at ( 1,1) {};
%   \node[transition] (enter critical) at (-1,1) {};
% \end{tikzpicture}
% \end{codeexample}



% \subsection{Placing Nodes Using Relative Placement\\使用相对定位放置节点}

% Although Hagen still wishes to connect the nodes, he first wishes to address
% another problem again: The placement of the nodes. Although he likes the |at|
% syntax, in this particular case he would prefer placing the nodes ``relative to
% each other''. So, Hagen would like to say that the |critical 1| node should be
% below the |waiting 1| node, wherever the |waiting 1| node might be. There are
% different ways of achieving this, but the nicest one in Hagen's case is the
% |below| option:

% 虽然Hagen仍然希望连接节点，但他首先希望再次解决另一个问题：节点的放置。尽管他喜欢 |at| 语法，但在这种特殊情况下，他更愿意将节点“相对于彼此”放置。因此，Hagen希望指定 |critical 1| 节点应该在 |waiting 1| 节点的下方，无论 |waiting 1| 节点在哪里。有多种实现这一目标的方法，但在Hagen的情况下，最好的方法是使用 |below| 选项：
% %
% \begin{codeexample}[preamble={\usetikzlibrary{positioning}}]
% \begin{tikzpicture}
%   \node[place]      (waiting)                            {};
%   \node[place]      (critical)       [below=of waiting]  {};
%   \node[place]      (semaphore)      [below=of critical] {};
%   \node[transition] (leave critical) [right=of critical] {};
%   \node[transition] (enter critical) [left=of critical]  {};
% \end{tikzpicture}
% \end{codeexample}

% With the |positioning| library loaded, when an option like |below| is followed
% by |of|, then the position of the node is shifted in such a manner that it is
% placed at the distance |node distance| in the specified direction of the given
% direction. The |node distance| is either the distance between the centers of
% the nodes (when the |on grid| option is set to true) or the distance between
% the borders (when the |on grid| option is set to false, which is the default).

% 加载 |positioning| 库后，当选项如 |below| 后面跟着 |of| 时，节点的位置会按照指定的方向在距离 |node distance| 处移动节点。|node distance| 是节点之间的距离（当将 |on grid| 选项设置为 true 时，为节点中心之间的距离），或者是边界之间的距离（当将 |on grid| 选项设置为 false，这是默认设置）。

% Even though the above code has the same effect as the earlier code, Hagen can
% pass it to his colleagues who will be able to just read and understand it,
% perhaps without even having to see the picture.


% 尽管上面的代码与之前的代码具有相同的效果，但Hagen可以将其传递给他的同事，他们将能够只需阅读和理解它，甚至可能不必看到图片。
