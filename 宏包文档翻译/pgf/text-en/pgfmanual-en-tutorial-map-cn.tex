% Copyright 2019 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Free Documentation License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.


\section{Tutorial: A Lecture Map for Johannes\\教程：Johannes的讲座地图}

In this tutorial we explore the tree and mind map mechanisms of \tikzname.

在本教程中，我们将探索\tikzname 中的树和思维导图机制。

Johannes is quite excited: For the first time he will be teaching a course all
by himself during the upcoming semester! Unfortunately, the course is not on
his favorite subject, which is of course Theoretical Immunology, but on
Complexity Theory, but as a young academic Johannes is not likely to complain
too loudly. In order to help the students get a general overview of what is
going to happen during the course as a whole, he intends to draw some kind of
tree or graph containing the basic concepts. He got this idea from his old
professor who seems to be using these ``lecture maps'' with some success.
Independently of the success of these maps, Johannes thinks they look quite
neat.

Johannes非常兴奋：在即将到来的学期里，他将第一次独自教授一门课程！不幸的是，这门课程并不是他最喜欢的主题，当然他最喜欢的主题是理论免疫学，而是关于复杂性理论的课程，但作为一名年轻的学者，Johannes不太可能大声抱怨。为了帮助学生们对整个课程有一个总体的了解，他打算绘制一些包含基本概念的树或图形。他从他的老教授那里得到了这个想法，他的老教授似乎在使用这些“讲座地图”取得了一些成功。不管这些地图的成功与否，Johannes认为它们看起来非常整洁。


\subsection{Problem Statement\\问题陈述}

Johannes wishes to create a lecture map with the following features:

Johannes希望创建一个带有以下特点的讲座地图：
%
\begin{enumerate}
    \item It should contain a tree or graph depicting the main concepts.

    它应包含描述主要概念的树或图形。
    \item It should somehow visualize the different lectures that will be
        taught. Note that the lectures are not necessarily the same as the
        concepts since the graph may contain more concepts than will be
        addressed in lectures and some concepts may be addressed during more
        than one lecture.

        应以某种方式可视化将要授课的不同讲座。请注意，讲座与概念不一定相同，因为图中可能包含比讲座中要讨论的概念更多，并且某些概念可能在多个讲座中讨论。
    \item The map should also contain a calendar showing when the individual
        lectures will be given.

        该地图还应包含一个显示各个讲座时间的日历。
    \item The aesthetical reasons, the whole map should have a visually nice
        and information-rich background.

        出于美观的原因，整个地图应具有视觉上的美观和信息丰富的背景。
\end{enumerate}

As always, Johannes will have to include the right libraries and set up the
environment. Johannes is going to use the |mindmap| library and since he wishes
to show a calendar, he will also need the |calendar| library. In order to put
something on a background layer, it seems like a good idea to also include the
|backgrounds| library.

像往常一样，Johannes需要包含正确的库并设置环境。Johannes将使用|mindmap|库，因为他希望显示一个日历，他还将需要|calendar|库。为了将某个内容放置在背景层上，似乎也可以包含|backgrounds|库。


\subsection{Introduction to Trees\\树的介绍}

The first choice Johannes must make is whether he will organize the concepts as
a tree, with root concepts and concept branches and leaf concepts, or as a
general graph. The tree implicitly organizes the concepts, while a graph is
more flexible. Johannes decides to compromise: Basically, the concepts will be
organized as a tree. However, he will selectively add connections between
concepts that are related, but which appear on different levels or branches of
the tree.

Johannes首先要做的选择是，他是否将概念组织为树，根概念和概念分支以及叶概念，还是组织为一般图形。树隐式地组织了概念，而图形更加灵活。Johannes决定妥协：基本上，概念将以树的形式组织。但是，他将有选择地在不同级别或分支的概念之间添加相关的连接，尽管它们位于树的不同层级或分支上。

Johannes starts with a tree-like list of concepts that he feels are important
in Computational Complexity:

Johannes从他认为在计算复杂性中很重要的概念树列表开始：
%
\begin{itemize}
    \item Computational Problems

    计算问题
        \begin{itemize}\itemsep=0pt\parskip=0pt
            \item Problem Measures

            问题度量
            \item Problem Aspects

            问题方面
            \item Problem Domains

            问题领域
            \item Key Problems

            关键问题
        \end{itemize}
    \item Computational Models

    计算模型
        \begin{itemize}\itemsep=0pt\parskip=0pt
            \item Turing Machines

            图灵机
            \item Random-Access Machines

            随机访问机
            \item Circuits

            电路
            \item Binary Decision Diagrams

            二进制决策图
            \item Oracle Machines

            Oracle机
            \item Programming in Logic

            逻辑编程
        \end{itemize}
    \item Measuring Complexity

    复杂度度量
        \begin{itemize}\itemsep=0pt\parskip=0pt
            \item Complexity Measures

            复杂度度量
            \item Classifying Complexity

            复杂度分类
            \item Comparing Complexity

            复杂度比较
            \item Describing Complexity

            复杂度描述
        \end{itemize}
    \item Solving Problems

    解决问题
        \begin{itemize}\itemsep=0pt\parskip=0pt
            \item Exact Algorithms

            精确算法
            \item Randomization

            随机化
            \item Fixed-Parameter Algorithms

            固定参数算法
            \item Parallel Computation

            并行计算
            \item Partial Solutions

            部分解决方案
            \item Approximation

            近似算法
        \end{itemize}
\end{itemize}

Johannes will surely need to modify this list later on, but it looks good as a
first approximation. He will also need to add a number of subtopics (like
\emph{lots} of complexity classes under the topic ``classifying complexity''),
but he will do this as he constructs the map.

Johannes肯定以后需要修改这个列表，但作为第一个近似，它看起来不错。他还需要添加一些子主题（比如在“复杂度分类”主题下有很多复杂度类），但他将在构建地图时逐步添加。

Turning the list of topics into a \tikzname-tree is easy, in principle. The
basic idea is that a node can have \emph{children}, which in turn can have
children of their own, and so on. To add a child to a node, Johannes can simply
write |child {|\meta{node}|}| right after a node. The \meta{node} should, in
turn, be the code for creating a node. To add another node, Johannes can use
|child| once more, and so on. Johannes is eager to try out this construct and
writes down the following:


将这些主题列表转换为\tikzname 树很简单，原则上来说。基本思想是一个节点可以有“子节点”，而子节点可以有它们自己的子节点，依此类推。要向节点添加子节点，Johannes只需在节点后面写上|child {|\meta{node}|}|。而\meta{node}则应该是创建一个节点的代码。要添加另一个节点，Johannes可以再次使用|child|，依此类推。Johannes迫不及待地尝试这个结构，并写下以下内容：
%
\begin{codeexample}[]
\tikz
  \node {Computational Complexity} % root
    child { node {Computational Problems}
      child { node {Problem Measures} }
      child { node {Problem Aspects} }
      child { node {Problem Domains} }
      child { node {Key Problems} }
    }
    child { node {Computational Models}
      child { node {Turing Machines} }
      child { node {Random-Access Machines} }
      child { node {Circuits} }
      child { node {Binary Decision Diagrams} }
      child { node {Oracle Machines} }
      child { node {Programming in Logic} }
    }
    child { node {Measuring Complexity}
      child { node {Complexity Measures} }
      child { node {Classifying Complexity} }
      child { node {Comparing Complexity} }
      child { node {Describing Complexity} }
    }
    child { node {Solving Problems}
      child { node {Exact Algorithms} }
      child { node {Randomization} }
      child { node {Fixed-Parameter Algorithms} }
      child { node {Parallel Computation} }
      child { node {Partial Solutions} }
      child { node {Approximation} }
    };
\end{codeexample}

Well, that did not quite work out as expected (although, what, exactly, did one
expect?). There are two problems:

好吧，这并没有完全按预期工作（尽管，实际上，到底期望什么呢？）。存在两个问题：
%
\begin{enumerate}
    \item The overlap of the nodes is due to the fact that \tikzname\ is not
        particularly smart when it comes to placing child nodes. Even though
        it is possible to configure \tikzname\ to use rather clever placement
        methods, \tikzname\ has no way of taking the actual size of the child
        nodes into account. This may seem strange but the reason is that the
        child nodes are rendered and placed one at a time, so the size of the
        last node is not known when the first node is being processed. In
        essence, you have to specify appropriate level and sibling node
        spacings ``by hand''.

        节点重叠是因为\tikzname 在放置子节点时不太聪明。尽管可以配置\tikzname 使用相当聪明的放置方法，但\tikzname 没有办法考虑子节点的实际大小。这似乎很奇怪，但原因在于子节点是逐个渲染和放置的，因此在处理第一个节点时不知道最后一个节点的大小。本质上，你必须“手动”指定适当的级别和兄弟节点间距。
    \item The standard computer-science-top-down rendering of a tree is
        rather ill-suited to visualizing the concepts. It would be better to
        either rotate the map by ninety degrees or, even better, to use some
        sort of circular arrangement.

        标准的自顶向下的计算机科学树渲染对于可视化概念并不太合适。最好的选择是将地图旋转九十度，或者更好的是使用某种圆形排列。
\end{enumerate}

Johannes redraws the tree, but this time with some more appropriate options
set, which he found more or less by trial-and-error:


Johannes重新绘制了树，但这次设置了一些更合适的选项，这些选项他通过试错法找到了大致的值：
%
\begin{codeexample}[
    preamble={\usetikzlibrary{trees}},
    render instead={
        \tikz [font=\footnotesize,
               grow=right, level 1/.style={sibling distance=6em},
                           level 2/.style={sibling distance=1em}, level distance=5cm]
          \node {Computational Complexity} % root
            child { node {Computational Problems}
              child { node {Problem Measures} }           child { node {Problem Aspects} }
              child { node {Problem Domains} }            child { node {Key Problems} }
            }
            child { node {Computational Models}
              child { node {Turing Machines} }            child { node {Random-Access Machines} }
              child { node {Circuits} }                   child { node {Binary Decision Diagrams} }
              child { node {Oracle Machines} }            child { node {Programming in Logic} }
            }
            child { node {Measuring Complexity}
              child { node {Complexity Measures} }        child { node {Classifying Complexity} }
              child { node {Comparing Complexity} }       child { node {Describing Complexity} }
            }
            child { node {Solving Problems}
              child { node {Exact Algorithms} }           child { node {Randomization} }
              child { node {Fixed-Parameter Algorithms} } child { node {Parallel Computation} }
              child { node {Partial Solutions} }          child { node {Approximation} }
            };
    },
]
\tikz [font=\footnotesize,
       grow=right, level 1/.style={sibling distance=6em},
                   level 2/.style={sibling distance=1em}, level distance=5cm]
  \node {Computational Complexity} % root
    child { node {Computational Problems}
      child { node {Problem Measures} }
      child { node {Problem Aspects} }
      ... % as before
\end{codeexample}

Still not quite what Johannes had in mind, but he is getting somewhere.

这仍然不完全符合Johannes的想法，但他正在逐步接近。

For configuring the tree, two parameters are of particular importance: The
|level distance| tells \tikzname\ the distance between (the centers of) the
nodes on adjacent levels or layers of a tree. The |sibling distance| is, as the
name suggests, the distance between (the centers of) siblings of the tree.

对于配置树，有两个特别重要的参数：|level distance| 表示相邻级别或层的节点（中心）之间的距离。|sibling distance| 是兄弟节点之间（中心）的距离。


You can globally set these parameters for a tree by simply setting them
somewhere before the tree starts, but you will typically wish them to be
different for different levels of the tree. In this case, you should set styles
like |level 1| or |level 2|. For the first level of the tree, the |level 1|
style is used, for the second level the |level 2| style, and so on. You can
also set the sibling and level distances only for certain nodes by passing
these options to the |child| command as options. (Note that the options of a
|node| command are local to the node and have no effect on the children. Also
note that it is possible to specify options that do have an effect on the
children. Finally note that specifying options for children ``at the right
place'' is an arcane art and you should peruse
Section~\ref{section-tree-options} on a rainy Sunday afternoon, if you are
really interested.)

你可以通过在树开始之前的某个位置设置这些参数来全局设置这些参数，但你通常希望它们在树的不同级别上有所不同。在这种情况下，你应该设置像 |level 1| 或 |level 2| 这样的样式。对于树的第一级别，使用 |level 1| 样式，对于第二级别使用 |level 2| 样式，依此类推。你还可以通过将这些选项作为选项传递给 |child| 命令来仅为某些节点设置兄弟和级别距离。（请注意，|node| 命令的选项仅对该节点本身有效，对子节点没有影响。还要注意，可以指定对子节点有影响的选项。最后，请注意，在“正确的位置”为子节点指定选项是一门奥秘的艺术，如果你真的感兴趣，可以在一个下雨的星期天下午阅读第\ref{section-tree-options}节。）

The |grow| key is used to configure the direction in which a tree grows. You
can change growth direction ``in the middle of a tree'' simply by changing this
key for a single child or a whole level. By including the |trees| library you
also get access to additional growth strategies such as a ``circular'' growth:


|grow| 键用于配置树的生长方向。你可以通过为单个子节点或整个级别更改此键来在“树的中途”更改生长方向。通过包含 |trees| 库，你还可以访问其他生长策略，例如“圆形”生长：
%
\begin{codeexample}[
    preamble={\usetikzlibrary{trees}},
    render instead={
        \tikz [text width=2.7cm, align=flush center,
               grow cyclic,
               level 1/.style={level distance=2.5cm,sibling angle=90},
               level 2/.style={text width=2cm, font=\footnotesize, level distance=3cm,sibling angle=30}]
          \node[font=\bfseries] {Computational Complexity} % root
            child { node {Computational Problems}
              child { node {Problem Measures} }           child { node {Problem Aspects} }
              child { node {Problem Domains} }            child { node {Key Problems} }
            }
            child { node {Computational Models}
              child { node {Turing Machines} }            child { node {Random-Access Machines} }
              child { node {Circuits} }                   child { node {Binary Decision Diagrams} }
              child { node {Oracle Machines} }            child { node {Programming in Logic} }
            }
            child { node {Measuring Complexity}
              child { node {Complexity Measures} }        child { node {Classifying Complexity} }
              child { node {Comparing Complexity} }       child { node {Describing Complexity} }
            }
            child { node {Solving Problems}
              child { node {Exact Algorithms} }           child { node {Randomization} }
              child { node {Fixed-Parameter Algorithms} } child { node {Parallel Computation} }
              child { node {Partial Solutions} }          child { node {Approximation} }
            };
    },
]
\tikz [text width=2.7cm, align=flush center,
       grow cyclic,
       level 1/.style={level distance=2.5cm,sibling angle=90},
       level 2/.style={text width=2cm, font=\footnotesize, level distance=3cm,sibling angle=30}]
  \node[font=\bfseries] {Computational Complexity} % root
    child { node {Computational Problems}
      child { node {Problem Measures} }
      child { node {Problem Aspects} }
      ... % as before
\end{codeexample}

Johannes is pleased to learn that he can access and manipulate the nodes of the
tree like any normal node. In particular, he can name them using the |name=|
option or the |(|\meta{name}|)| notation and he can use any available shape or
style for the trees nodes. He can connect trees later on using the normal
|\draw (some node) -- (another node);| syntax. In essence, the |child| command
just computes an appropriate position for a node and adds a line from the child
to the parent node.

Johannes很高兴地了解到，他可以像处理普通节点一样访问和操作树的节点。特别是，他可以使用 |name=| 选项或 |(|\meta{name}|)| 表示法为它们命名，并且他可以为每个节点使用任何可用的形状或样式。他可以稍后使用正常的 |\draw (some node) -- (another node);| 语法连接树。本质上，|child| 命令只计算一个适当的位置给节点并从子节点到父节点添加一条线。


\subsection{Creating the Lecture Map\\创建讲座地图}

Johannes now has a first possible layout for his lecture map. The next step is
to make it ``look nicer''. For this, the |mindmap| library is helpful since it
makes a number of styles available that will make a tree look like a nice
``mind map'' or ``concept map''.

现在Johannes拥有了讲座地图的第一个可能布局。下一步是使其“看起来更好”。为此，|mindmap| 库非常有用，因为它提供了一些样式，可以使树看起来像一个漂亮的“思维导图”或“概念地图”。

The first step is to include the |mindmap| library, which Johannes already did.
Next, he must add one of the following options to a scope that will contain the
lecture map: |mindmap| or |large mindmap| or |huge mindmap|. These options all
have the same effect, except that for a |large mindmap| the predefined font
size and node sizes are somewhat larger than for a standard |mindmap| and for a
|huge mindmap| they are even larger. So, a |large mindmap| does not necessarily
need to have a lot of concepts, but it will need a lot of paper.

第一步是包含 |mindmap| 库，Johannes已经做到了。接下来，他必须在包含讲座地图的范围内添加以下选项之一：|mindmap|、|large mindmap| 或 |huge mindmap|。这些选项的效果是相同的，只是对于 |large mindmap|，预定义的字体大小和节点大小要比标准 |mindmap| 大一些，对于 |huge mindmap| 则更大。因此，|large mindmap| 并不一定需要很多概念，但它需要很多纸张。

The second step is to add the |concept| option to every node that will, indeed,
be a concept of the mindmap. The idea is that some nodes of a tree will be real
concepts, while other nodes might just be ``simple children''. Typically, this
is not the case, so you might consider saying |every node/.style=concept|.

第二步是为每个确实是思维导图概念的节点添加 |concept| 选项。思路是树的某些节点将是真正的概念，而其他节点可能只是“简单的子节点”。通常情况下，这并不是这样，所以你可以考虑说 |every node/.style=concept|。

The third step is to set up the sibling \emph{angle} (rather than a sibling
distance) to specify the angle between sibling concepts.

第三步是设置兄弟节点之间的角度（而不是兄弟节点之间的距离），以指定兄弟概念之间的角度。

%
\begin{codeexample}[
    preamble={\usetikzlibrary{mindmap}},
    render instead={
        \tikz [mindmap, every node/.style=concept, concept color=black!20,
               grow cyclic,
               level 1/.append style={level distance=4.5cm,sibling angle=90},
               level 2/.append style={level distance=3cm,sibling angle=45}]
          \node [root concept] {Computational Complexity} % root
            child { node {\hbox to 2cm{Computational\hss} Problems}
              child { node {Problem Measures} }
              child { node {Problem Aspects} }
              child { node {Problem Domains} }
              child { node {Key Problems} }
            }
            child { node {\hbox to 2cm{Computational\hss} Models}
              child { node {Turing Machines} }
              child { node {Random-Access Machines} }
              child { node {Circuits} }
              child { node {Binary Decision Diagrams} }
              child { node {Oracle Machines} }
              child { node {\hbox to1.5cm{Programming\hss} in Logic} }
            }
            child { node {Measuring Complexity}
              child { node {Complexity Measures} }
              child { node {Classifying Complexity} }
              child { node {Comparing Complexity} }
              child { node {Describing Complexity} }
            }
            child { node {Solving Problems}
              child { node {Exact Algorithms} }
              child { node {\hbox to 1.5cm{Randomization\hss}} }
              child { node {Fixed-Parameter Algorithms} }
              child { node {Parallel Computation} }
              child { node {Partial Solutions} }
              child { node {\hbox to1.5cm{Approximation\hss}} }
            };
    },
]
\tikz [mindmap, every node/.style=concept, concept color=black!20,
       grow cyclic,
       level 1/.append style={level distance=4.5cm,sibling angle=90},
       level 2/.append style={level distance=3cm,sibling angle=45}]
  \node [root concept] {Computational Complexity} % root
    child { node {Computational Problems}
      child { node {Problem Measures} }
      child { node {Problem Aspects} }
      ... % as before
\end{codeexample}

When Johannes typesets the above map, \TeX\ (rightfully) starts complaining
about several overfull boxes and, indeed, words like ``Randomization'' stretch
out beyond the circle of the concept. This seems a bit mysterious at first
sight: Why does \TeX\ not hyphenate the word? The reason is that \TeX\ will
never hyphenate the first word of a paragraph because it starts looking for
``hyphenatable'' letters only after a so-called glue. In order to have \TeX\
hyphenate these single words, Johannes must use a bit of evil trickery: He
inserts a |\hskip0pt| before the word. This has no effect except for inserting
an (invisible) glue before the word and, thereby, allowing \TeX\ to hyphenate
the first word also. Since Johannes does not want to add |\hskip0pt| inside
each node, he uses the |execute at begin node| option to make \tikzname\ insert
this text with every node.

当Johannes排版上述地图时，\TeX\ （正确地）开始抱怨有几个溢出的盒子，确实，像“Randomization”这样的单词超出了概念的圆圈。这一开始似乎有些神秘：为什么\TeX\ 不连字符化这个词呢？原因是\TeX\ 永远不会连字符化段落的第一个单词，因为它只在所谓的粘合剂之后开始寻找“可连字符化”的字母。为了让\TeX\ 连字符化这些单词，Johannes必须使用一些诡计：他在单词前插入了 |\hskip0pt|。除了在单词前插入一个（无形的）粘合剂之外，这没有任何效果，从而允许\TeX\ 连字符化第一个单词。由于Johannes不想在每个节点中添加 |\hskip0pt|，他使用 |execute at begin node| 选项，让\tikzname\ 在每个节点中插入这个文本。


%
\begin{codeexample}[
    preamble={\usetikzlibrary{mindmap}},
    render instead={
        \begin{tikzpicture}
          [mindmap,
           every node/.style={concept, execute at begin node=\hskip0pt},
           concept color=black!20,
           grow cyclic,
           level 1/.append style={level distance=4.5cm,sibling angle=90},
           level 2/.append style={level distance=3cm,sibling angle=45}]
          \clip (-1,2) rectangle ++ (-4,5);
          \node [root concept] {Computational Complexity} % root
            child { node {Computational Problems}
              child { node {Problem Measures} }
              child { node {Problem Aspects} }
              child { node {Problem Domains} }
              child { node {Key Problems} }
            }
            child { node {Computational Models}
              child { node {Turing Machines} }
              child { node {Random-Access Machines} }
              child { node {Circuits} }
              child { node {Binary Decision Diagrams} }
              child { node {Oracle Machines} }
              child { node {Programming in Logic} }
            }
            child { node {Measuring Complexity}
              child { node {Complexity Measures} }
              child { node {Classifying Complexity} }
              child { node {Comparing Complexity} }
              child { node {Describing Complexity} }
            }
            child { node {Solving Problems}
              child { node {Exact Algorithms} }
              child { node {Randomization} }
              child { node {Fixed-Parameter Algorithms} }
              child { node {Parallel Computation} }
              child { node {Partial Solutions} }
              child { node {Approximation} }
            };
        \end{tikzpicture}
    },
]
\begin{tikzpicture}
  [mindmap,
   every node/.style={concept, execute at begin node=\hskip0pt},
   concept color=black!20,
   grow cyclic,
   level 1/.append style={level distance=4.5cm,sibling angle=90},
   level 2/.append style={level distance=3cm,sibling angle=45}]
  \clip (-1,2) rectangle ++ (-4,5);
  \node [root concept] {Computational Complexity} % root
    child { node {Computational Problems}
      child { node {Problem Measures} }
      child { node {Problem Aspects} }
      ... % as before
\end{tikzpicture}
\end{codeexample}

In the above example a clipping was used to show only part of the lecture map,
in order to save space. The same will be done in the following examples, we
return to the complete lecture map at the end of this tutorial.

在上面的示例中，使用了剪裁来只显示讲座地图的一部分，以节省空间。在下面的示例中，我们将回到完整的讲座地图。

Johannes is now eager to colorize the map. The idea is to use different colors
for different parts of the map. He can then, during his lectures, talk about
the ``green'' or the ``red'' topics. This will make it easier for his students
to locate the topic he is talking about on the map. Since ``computational
problems'' somehow sounds ``problematic'', Johannes chooses red for them, while
he picks green for the ``solving problems''. The topics ``measuring
complexity'' and ``computational models'' get more neutral colors; Johannes
picks orange and blue.

Johannes现在渴望给地图上色。思路是对地图的不同部分使用不同的颜色。然后，在讲座期间，他可以谈论“绿色”或“红色”主题。这将使他的学生更容易在地图上找到他讲的主题。由于“计算问题”听起来有些“棘手”，Johannes选择了红色，而他选择了绿色来表示“解决问题”。主题“测量复杂度”和“计算模型”选择了更中性的颜色；Johannes选择了橙色和蓝色。

To set the colors, Johannes must use the |concept color| option, rather than
just, say, |node [fill=red]|. Setting just the fill color to |red| would,
indeed, make the node red, but it would \emph{just} make the node red and not
the bar connecting the concept to its parent and also not its children. By
comparison, the special |concept color| option will not only set the color of
the node and its children, but it will also (magically) create appropriate
shadings so that the color of a parent concept smoothly changes to the color of
a child concept.

为了设置颜色，Johannes必须使用 |concept color| 选项，而不仅仅是，比如，|node [fill=red]|。只设置填充颜色为 |red| 确实会使节点变红，但它仅仅让节点变红，而不会使连接概念与其父节点的线条以及其子节点也变色。相比之下，特殊的 |concept color| 选项不仅会设置节点和其子节点的颜色，而且（神奇地）会创建适当的渐变，使父节点的颜色平滑过渡到子节点的颜色。

For the root concept Johannes decides to do something special: He sets the
concept color to black, sets the line width to a large value, and sets the fill
color to white. The effect of this is that the root concept will be encircled
with a thick black line and the children are connected to the central concept
via bars.

对于根概念，Johannes决定做一些特殊处理：他将概念颜色设置为黑色，将线宽设置为较大的值，并将填充颜色设置为白色。这样做的效果是根概念将被厚黑线环绕，并且子节点通过条连接到中心概念。

%
\begin{codeexample}[
    preamble={\usetikzlibrary{mindmap}},
    render instead={
        \begin{tikzpicture}
          [mindmap,
           every node/.style={concept, execute at begin node=\hskip0pt},
           root concept/.append style={
             concept color=black,
             fill=white, line width=1ex,
             text=black},
           text=white,
           grow cyclic,
           level 1/.append style={level distance=4.5cm,sibling angle=90},
           level 2/.append style={level distance=3cm,sibling angle=45}]
          \clip (0,-1) rectangle ++(4,5);
          \node [root concept] {Computational Complexity} % root
            child [concept color=red] { node {Computational Problems}
              child { node {Problem Measures} }
              child { node {Problem Aspects} }
              child { node {Problem Domains} }
              child { node {Key Problems} }
            }
            child [concept color=blue] { node {Computational Models}
              child { node {Turing Machines} }
              child { node {Random-Access Machines} }
              child { node {Circuits} }
              child { node {Binary Decision Diagrams} }
              child { node {Oracle Machines} }
              child { node {Programming in Logic} }
            }
            child [concept color=orange] { node {Measuring Complexity}
              child { node {Complexity Measures} }
              child { node {Classifying Complexity} }
              child { node {Comparing Complexity} }
              child { node {Describing Complexity} }
            }
            child [concept color=green!50!black] { node {Solving Problems}
              child { node {Exact Algorithms} }
              child { node {Randomization} }
              child { node {Fixed-Parameter Algorithms} }
              child { node {Parallel Computation} }
              child { node {Partial Solutions} }
              child { node {Approximation} }
            };
        \end{tikzpicture}
    },
]
\begin{tikzpicture}
  [mindmap,
   every node/.style={concept, execute at begin node=\hskip0pt},
   root concept/.append style={
     concept color=black, fill=white, line width=1ex, text=black},
   text=white,
   grow cyclic,
   level 1/.append style={level distance=4.5cm,sibling angle=90},
   level 2/.append style={level distance=3cm,sibling angle=45}]
   \clip (0,-1) rectangle ++(4,5);
  \node [root concept] {Computational Complexity} % root
    child [concept color=red] { node {Computational Problems}
      child { node {Problem Measures} }
      ... % as before
    }
    child [concept color=blue] { node {Computational Models}
      child { node {Turing Machines} }
      ... % as before
    }
    child [concept color=orange] { node {Measuring Complexity}
      child { node {Complexity Measures} }
      ... % as before
    }
    child [concept color=green!50!black] { node {Solving Problems}
      child { node {Exact Algorithms} }
      ... % as before
    };
\end{tikzpicture}
\end{codeexample}

Johannes adds three finishing touches: First, he changes the font of the main
concepts to small caps. Second, he decides that some concepts should be
``faded'', namely those that are important in principle and belong on the map,
but which he will not talk about in his lecture. To achieve this, Johannes
defines four styles, one for each of the four main branches. These styles (a)
set up the correct concept color for the whole branch and (b) define the
|faded| style appropriately for this branch. Third, he adds a
|circular drop shadow|, defined in the |shadows| library, to the concepts, just
to make things look a bit more fancy.
%


Johannes添加了三个最后的修饰：首先，他将主要概念的字体更改为小型大写字母。其次，他决定某些概念应该“淡化”，即原则上它们在地图上很重要并且属于地图，但他在讲座中不会谈论它们。为了实现这一点，Johannes为每个主分支定义了四个样式，这些样式(a)为整个分支设置了正确的概念颜色，并且(b)适当地定义了 |faded| 样式。第三，他为概念添加了 |circular drop shadow|，定义在 |shadows| 库中，只是为了使事物看起来更加花哨。

\begin{codeexample}[
    preamble={\usetikzlibrary{mindmap,shadows}},
    render instead={
        \begin{tikzpicture}[mindmap]
          \begin{scope}[
           every node/.style={concept, circular drop shadow,execute at begin node=\hskip0pt},
           root concept/.append style={
             concept color=black,
             fill=white, line width=1ex,
             text=black, font=\large\scshape},
           text=white,
           computational problems/.style={concept color=red,faded/.style={concept color=red!50}},
           computational models/.style={concept color=blue,faded/.style={concept color=blue!50}},
           measuring complexity/.style={concept color=orange,faded/.style={concept color=orange!50}},
           solving problems/.style={concept color=green!50!black,faded/.style={concept color=green!50!black!50}},
           grow cyclic,
           level 1/.append style={level distance=4.5cm,sibling angle=90,font=\scshape},
           level 2/.append style={level distance=3cm,sibling angle=45,font=\scriptsize}]
          \node [root concept] {Computational Complexity} % root
            child [computational problems] { node {Computational Problems}
              child         { node {Problem Measures} }
              child         { node {Problem Aspects} }
              child [faded] { node {Problem Domains} }
              child         { node {Key Problems} }
            }
            child [computational models] { node {Computational Models}
              child         { node {Turing Machines} }
              child [faded] { node {Random-Access Machines} }
              child         { node {Circuits} }
              child [faded] { node {Binary Decision Diagrams} }
              child         { node {Oracle Machines} }
              child         { node {Programming in Logic} }
            }
            child [measuring complexity] { node {Measuring Complexity}
              child         { node {Complexity Measures} }
              child         { node {Classifying Complexity} }
              child         { node {Comparing Complexity} }
              child [faded] { node {Describing Complexity} }
            }
            child [solving problems] { node {Solving Problems}
              child         { node {Exact Algorithms} }
              child         { node {Randomization} }
              child         { node {Fixed-Parameter Algorithms} }
              child         { node {Parallel Computation} }
              child         { node {Partial Solutions} }
              child         { node {Approximation} }
            };
          \end{scope}
        \end{tikzpicture}
    },
]
\begin{tikzpicture}[mindmap]
  \begin{scope}[
    every node/.style={concept, circular drop shadow,execute at begin node=\hskip0pt},
    root concept/.append style={
      concept color=black, fill=white, line width=1ex, text=black, font=\large\scshape},
    text=white,
    computational problems/.style={concept color=red,faded/.style={concept color=red!50}},
    computational models/.style={concept color=blue,faded/.style={concept color=blue!50}},
    measuring complexity/.style={concept color=orange,faded/.style={concept color=orange!50}},
    solving problems/.style={concept color=green!50!black,faded/.style={concept color=green!50!black!50}},
    grow cyclic,
    level 1/.append style={level distance=4.5cm,sibling angle=90,font=\scshape},
    level 2/.append style={level distance=3cm,sibling angle=45,font=\scriptsize}]
    \node [root concept] {Computational Complexity} % root
      child [computational problems] { node {Computational Problems}
        child         { node {Problem Measures} }
        child         { node {Problem Aspects} }
        child [faded] { node {Problem Domains} }
        child         { node {Key Problems} }
      }
      child [computational models] { node {Computational Models}
        child         { node {Turing Machines} }
        child [faded] { node {Random-Access Machines} }
        ...
  \end{scope}
\end{tikzpicture}
\end{codeexample}


\subsection{Adding the Lecture Annotations\\添加讲座注释}

Johannes will give about a dozen lectures during the course ``computational
complexity''. For each lecture he has compiled a (short) list of learning
targets that state what knowledge and qualifications his students should
acquire during this particular lecture (note that learning targets are not the
same as the contents of a lecture). For each lecture he intends to put a little
rectangle on the map containing these learning targets and the name of the
lecture, each time somewhere near the topic of the lecture. Such ``little
rectangles'' are called ``annotations'' by the |mindmap| library.

Johannes将在“计算复杂性”课程中进行约十几次讲座。对于每次讲座，他已经编制了一个（简短的）学习目标清单，其中说明学生们在每次讲座中应该获得的知识和能力（请注意，学习目标并不等同于讲座的内容）。对于每次讲座，他打算在地图上放置一个包含这些学习目标和讲座名称的小矩形框，每次都放置在与讲座主题附近的某个位置。这些“小矩形框”被 |mindmap| 库称为“注释”。

In order to place the annotations next to the concepts, Johannes must assign
names to the nodes of the concepts. He could rely on \tikzname's automatic
naming of the nodes in a tree, where the children of a node named |root| are
named |root-1|, |root-2|, |root-3|, and so on. However, since Johannes is not
sure about the final order of the concepts in the tree, it seems better to
explicitly name all concepts of the tree in the following manner:

为了将注释放置在概念旁边，Johannes必须为概念的节点分配名称。他可以依赖于\tikzname 在树中自动命名节点的功能，其中一个名为 |root| 的节点的子节点将被命名为 |root-1|、|root-2|、|root-3| 等。然而，由于Johannes不确定树中概念的最终顺序，明确地为树的所有概念命名似乎更好，命名方式如下：
%
\begin{codeexample}[code only]
\node [root concept] (Computational Complexity) {Computational Complexity}
  child [computational problems] { node (Computational Problems) {Computational Problems}
    child         { node (Problem Measures) {Problem Measures} }
    child         { node (Problem Aspects) {Problem Aspects} }
    child [faded] { node (Problem Domains) {Problem Domains} }
    child         { node (Key Problems) {Key Problems} }
  }
...
\end{codeexample}

The |annotation| style of the |mindmap| library mainly sets up a rectangular
shape of appropriate size. Johannes configures the style by defining
|every annotation| appropriately.

|mindmap| 库的 |annotation| 样式主要设置了一个适当大小的矩形形状。Johannes通过适当地定义 |every annotation| 来配置样式。
%
\begin{codeexample}[
    preamble={\usetikzlibrary{mindmap,shadows}},
    render instead={
        \begin{tikzpicture}[mindmap]
          \clip (-5.25,-3) rectangle ++ (4,5);
          \begin{scope}[
            every node/.style={concept, circular drop shadow,execute at begin node=\hskip0pt},
            root concept/.append style={
              concept color=black,
              fill=white, line width=1ex,
              text=black, font=\large\scshape},
            text=white,
            computational problems/.style={concept color=red,faded/.style={concept color=red!50}},
            computational models/.style={concept color=blue,faded/.style={concept color=blue!50}},
            measuring complexity/.style={concept color=orange,faded/.style={concept color=orange!50}},
            solving problems/.style={concept color=green!50!black,faded/.style={concept color=green!50!black!50}},
            grow cyclic,
            level 1/.append style={level distance=4.5cm,sibling angle=90,font=\scshape},
            level 2/.append style={level distance=3cm,sibling angle=45,font=\scriptsize}]
            \node [root concept] (Computational Complexity) {Computational Complexity} % root
              child [computational problems] { node (Computational Problems) {Computational Problems}
                child         { node (Problem Measures) {Problem Measures} }
                child         { node (Problem Aspects) {Problem Aspects} }
                child [faded] { node (problem Domains) {Problem Domains} }
                child         { node (Key Problems) {Key Problems} }
              }
              child [computational models] { node (Computational Models) {Computational Models}
                child         { node (Turing Machines) {Turing Machines} }
                child [faded] { node (Random-Access Machines) {Random-Access Machines} }
                child         { node (Circuits) {Circuits} }
                child [faded] { node (Binary Decision Diagrams) {Binary Decision Diagrams} }
                child         { node (Oracle Machines) {Oracle Machines} }
                child         { node (Programming in Logic) {Programming in Logic} }
              }
              child [measuring complexity] { node (Measuring Complexity) {Measuring Complexity}
                child         { node (Complexity Measures) {Complexity Measures} }
                child         { node (Classifying Complexity) {Classifying Complexity} }
                child         { node (Comparing Complexity) {Comparing Complexity} }
                child [faded] { node (Describing Complexity) {Describing Complexity} }
              }
              child [solving problems] { node (Solving Problems) {Solving Problems}
                child         { node (Exact Algorithms) {Exact Algorithms} }
                child         { node (Randomization) {Randomization} }
                child         { node (Fixed-Parameter Algorithms) {Fixed-Parameter Algorithms} }
                child         { node (Parallel Computation) {Parallel Computation} }
                child         { node (Partial Solutions) {Partial Solutions} }
                child         { node (Approximation) {Approximation} }
              };
          \end{scope}
          \begin{scope}[every annotation/.style={fill=black!40}]
            \node [annotation, above] at (Computational Problems.north) {
              Lecture 1: Computational Problems
              \begin{itemize}
              \item Knowledge of several key problems
              \item Knowledge of problem encodings
              \item Being able to formalize problems
              \end{itemize}
            };
          \end{scope}
        \end{tikzpicture}
    },
]
\begin{tikzpicture}[mindmap]
  \clip (-5,-5) rectangle ++ (4,5);
  \begin{scope}[
     every node/.style={concept, circular drop shadow, ...}] % as before
    \node [root concept] (Computational Complexity)    ...   % as before
  \end{scope}

  \begin{scope}[every annotation/.style={fill=black!40}]
    \node [annotation, above] at (Computational Problems.north) {
      Lecture 1: Computational Problems
      \begin{itemize}
      \item Knowledge of several key problems
      \item Knowledge of problem encodings
      \item Being able to formalize problems
      \end{itemize}
    };
  \end{scope}
\end{tikzpicture}
\end{codeexample}

Well, that does not yet look quite perfect. The spacing or the |{itemize}| is
not really appropriate and the node is too large. Johannes can configure these
things ``by hand'', but it seems like a good idea to define a macro that will
take care of these things for him. The ``right'' way to do this is to define a
|\lecture| macro that takes a list of key--value pairs as argument and produces
the desired annotation. However, to keep things simple, Johannes' |\lecture|
macro simply takes a fixed number of arguments having the following meaning:
The first argument is the number of the lecture, the second is the name of the
lecture, the third are positioning options like |above|, the fourth is the
position where the node is placed, the fifth is the list of items to be shown,
and the sixth is a date when the lecture will be held (this parameter is not
yet needed, we will, however, need it later on).

好吧，这看起来还不太完美。|{itemize}| 的间距不太合适，节点太大。Johannes可以“手动”配置这些内容，但似乎定义一个宏来处理这些内容会是一个好主意。这是一个“正确”的方法，即定义一个 |\lecture| 宏，它接受一系列键值对作为参数，并生成所需的注释。然而，为了保持简单，Johannes的 |\lecture| 宏只是接受具有以下含义的固定数量的参数：第一个参数是讲座的编号，第二个参数是讲座的名称，第三个参数是定位选项（如 |above|），第四个参数是节点放置的位置，第五个参数是要显示的项目列表，第六个参数是讲座将举行的日期（此参数目前不需要，但稍后会用到）。
%
% TODOsp: codeexamples: redo `\lecture` definition*s* when `preamble` can be emptied
\begin{codeexample}[code only]
\def\lecture#1#2#3#4#5#6{
  \node [annotation, #3, scale=0.65, text width=4cm, inner sep=2mm] at (#4) {
    Lecture #1: \textcolor{orange}{\textbf{#2}}
    \list{--}{\topsep=2pt\itemsep=0pt\parsep=0pt
              \parskip=0pt\labelwidth=8pt\leftmargin=8pt
              \itemindent=0pt\labelsep=2pt}
    #5
    \endlist
  };
}
\end{codeexample}
% TODOsp: codeexamples: this definition can most likely be deleted,
%         because it is moved to the `pre` key in the `codeexamples`
\def\lecture#1#2#3#4#5#6{
  \node [annotation, #3, scale=0.65, text width=4cm, inner sep=2mm] at (#4) {
    Lecture #1: \textcolor{orange}{\textbf{#2}}
    \list{--}{\topsep=2pt\itemsep=0pt\parsep=0pt
              \parskip=0pt\labelwidth=8pt\leftmargin=8pt
              \itemindent=0pt\labelsep=2pt}
    #5
    \endlist
  };
}

\begin{codeexample}[
    preamble={\usetikzlibrary{mindmap,shadows}},
    pre={ % !!! replace all `##x` with `#x`
\def\lecture##1##2##3##4##5##6{
  \node [annotation, ##3, scale=0.65, text width=4cm, inner sep=2mm] at (##4) {
    Lecture ##1: \textcolor{orange}{\textbf{##2}}
    \list{--}{\topsep=2pt\itemsep=0pt\parsep=0pt
              \parskip=0pt\labelwidth=8pt\leftmargin=8pt
              \itemindent=0pt\labelsep=2pt}
    ##5
    \endlist
  };
}},
    render instead={
        \begin{tikzpicture}[mindmap,every annotation/.style={fill=white}]
          \clip (-5.25,-3) rectangle ++ (4,5);
          \begin{scope}[
            every node/.style={concept, circular drop shadow,execute at begin node=\hskip0pt},
            root concept/.append style={
              concept color=black,
              fill=white, line width=1ex,
              text=black, font=\large\scshape},
            text=white,
            computational problems/.style={concept color=red,faded/.style={concept color=red!50}},
            computational models/.style={concept color=blue,faded/.style={concept color=blue!50}},
            measuring complexity/.style={concept color=orange,faded/.style={concept color=orange!50}},
            solving problems/.style={concept color=green!50!black,faded/.style={concept color=green!50!black!50}},
            grow cyclic,
            level 1/.append style={level distance=4.5cm,sibling angle=90,font=\scshape},
            level 2/.append style={level distance=3cm,sibling angle=45,font=\scriptsize}]
            \node [root concept] (Computational Complexity) {Computational Complexity} % root
              child [computational problems] { node (Computational Problems) {Computational Problems}
                child         { node (Problem Measures) {Problem Measures} }
                child         { node (Problem Aspects) {Problem Aspects} }
                child [faded] { node (problem Domains) {Problem Domains} }
                child         { node (Key Problems) {Key Problems} }
              }
              child [computational models] { node (Computational Models) {Computational Models}
                child         { node (Turing Machines) {Turing Machines} }
                child [faded] { node (Random-Access Machines) {Random-Access Machines} }
                child         { node (Circuits) {Circuits} }
                child [faded] { node (Binary Decision Diagrams) {Binary Decision Diagrams} }
                child         { node (Oracle Machines) {Oracle Machines} }
                child         { node (Programming in Logic) {Programming in Logic} }
              }
              child [measuring complexity] { node (Measuring Complexity) {Measuring Complexity}
                child         { node (Complexity Measures) {Complexity Measures} }
                child         { node (Classifying Complexity) {Classifying Complexity} }
                child         { node (Comparing Complexity) {Comparing Complexity} }
                child [faded] { node (Describing Complexity) {Describing Complexity} }
              }
              child [solving problems] { node (Solving Problems) {Solving Problems}
                child         { node (Exact Algorithms) {Exact Algorithms} }
                child         { node (Randomization) {Randomization} }
                child         { node (Fixed-Parameter Algorithms) {Fixed-Parameter Algorithms} }
                child         { node (Parallel Computation) {Parallel Computation} }
                child         { node (Partial Solutions) {Partial Solutions} }
                child         { node (Approximation) {Approximation} }
              };
          \end{scope}
          \lecture{1}{Computational Problems}{above,xshift=-3mm}{Computational Problems.north}{
            \item Knowledge of several key problems
            \item Knowledge of problem encodings
            \item Being able to formalize problems
          }{2009-04-08}
        \end{tikzpicture}
    },
]
\begin{tikzpicture}[mindmap,every annotation/.style={fill=white}]
  \clip (-5,-5) rectangle ++ (4,5);
  \begin{scope}[
     every node/.style={concept, circular drop shadow, ... % as before
    \node [root concept] (Computational Complexity)    ... % as before
  \end{scope}

  \lecture{1}{Computational Problems}{above,xshift=-3mm}
  {Computational Problems.north}{
    \item Knowledge of several key problems
    \item Knowledge of problem encodings
    \item Being able to formalize problems
  }{2009-04-08}
\end{tikzpicture}
\end{codeexample}

In the same fashion Johannes can now add the other lecture annotations.
Obviously, Johannes will have some trouble fitting everything on a single
A4-sized page, but by adjusting the spacing and some experimentation he can
quickly arrange all the annotations as needed.

以同样的方式，约翰尼斯现在可以添加其他的讲座注释。显然，约翰尼斯会遇到一些麻烦，因为他需要将所有注释安排在一张A4纸上，但是通过调整间距和一些实验，他可以迅速按照需要安排所有的注释。

\subsection{Adding the Background\\添加背景}

Johannes has already used colors to organize his lecture map into four regions,
each having a different color. In order to emphasize these regions even more
strongly, he wishes to add a background coloring to each of these regions.

约翰尼斯已经使用颜色将他的讲座思维导图分为四个区域，每个区域都有不同的颜色。为了更强烈地强调这些区域，他希望为每个区域添加背景色。

Adding these background colors turns out to be more tricky than Johannes would
have thought. At first sight, what he needs is some sort of ``color wheel''
that is blue in the lower right direction and then changes smoothly to orange
in the upper right direction and then to green in the upper left direction and
so on. Unfortunately, there is no easy way of creating such a color wheel
shading (although it can be done, in principle, but only at a very high cost,
see page~\pageref{shading-color-wheel} for an example).

添加这些背景色比约翰尼斯想象的要棘手得多。乍一看，他所需要的是一种类似于“颜色轮”的东西，从右下方变为蓝色，然后平滑地变为右上方的橙色，然后变为左上方的绿色，依此类推。不幸的是，没有一种简单的方法来创建这样的颜色轮渐变（虽然原则上可以做到，但代价非常高，参见第~\pageref{shading-color-wheel}页的一个例子）。

Johannes decides to do something a bit more basic: He creates four large
rectangles, one for each of the four quadrants around the central concept, each
colored with a light version of the quadrant. Then, in order to ``smooth'' the
change between adjacent rectangles, he puts four shadings on top of them.

约翰尼斯决定做一些更基本的事情：他创建了四个大矩形，分别代表中心概念周围的四个象限，每个象限都用该象限的浅色进行着色。然后，为了“平滑”相邻矩形之间的过渡，他在它们上面放置了四个渐变。

Since these background rectangles should go ``behind'' everything else,
Johannes puts all his background stuff on the |background| layer.

由于这些背景矩形应该在其他所有元素的“后面”，约翰尼斯将所有的背景内容都放在|background|层上。

In the following code, only the central concept is shown to save some space:

下面的代码中，为了节省空间，只显示了中心概念：
%
\begin{codeexample}[preamble={\usetikzlibrary{backgrounds,mindmap,shadows}}]
\begin{tikzpicture}[
  mindmap,
  concept color=black,
  root concept/.append style={
    concept,
    circular drop shadow,
    fill=white, line width=1ex,
    text=black, font=\large\scshape}
  ]

  \clip (-1.5,-5) rectangle ++(4,10);

  \node [root concept] (Computational Complexity) {Computational Complexity};

  \begin{pgfonlayer}{background}
    \clip (-1.5,-5) rectangle ++(4,10);

    \colorlet{upperleft}{green!50!black!25}
    \colorlet{upperright}{orange!25}
    \colorlet{lowerleft}{red!25}
    \colorlet{lowerright}{blue!25}

     % The large rectangles:
    \fill [upperleft]  (Computational Complexity) rectangle ++(-20,20);
    \fill [upperright] (Computational Complexity) rectangle ++(20,20);
    \fill [lowerleft]  (Computational Complexity) rectangle ++(-20,-20);
    \fill [lowerright] (Computational Complexity) rectangle ++(20,-20);

    % The shadings:
    \shade [left color=upperleft,right color=upperright]
      ([xshift=-1cm]Computational Complexity) rectangle ++(2,20);
    \shade [left color=lowerleft,right color=lowerright]
      ([xshift=-1cm]Computational Complexity) rectangle ++(2,-20);
    \shade [top color=upperleft,bottom color=lowerleft]
      ([yshift=-1cm]Computational Complexity) rectangle ++(-20,2);
    \shade [top color=upperright,bottom color=lowerright]
      ([yshift=-1cm]Computational Complexity) rectangle ++(20,2);
  \end{pgfonlayer}
\end{tikzpicture}
\end{codeexample}


\subsection{Adding the Calendar\\添加日历}

Johannes intends to plan his lecture rather carefully. In particular, he
already knows when each of his lectures will be held during the course.
Naturally, this does not mean that Johannes will slavishly follow the plan and
he might need longer for some subjects than he anticipated, but nevertheless he
has a detailed plan of when which subject will be addressed.

约翰尼斯打算对他的讲座进行仔细计划。特别是，他已经知道课程中的每一堂课将在什么时间举行。当然，这并不意味着约翰尼斯会一丝不苟地按照计划行事，他可能需要比预期的更长时间来处理某些主题，但是无论如何，他对每个主题将在何时进行有着详细的计划。

Johannes intends to share this plan with his students by adding a calendar to
the lecture map. In addition to serving as a reference on which particular day
a certain  topic will be addressed, the calendar is also useful to show the
overall chronological order of the course.

约翰尼斯打算通过在讲座思维导图中添加一个日历来与学生分享这个计划。除了作为某个特定日期将讨论的主题的参考之外，日历还有助于显示课程的整体时间顺序。

In order to add a calendar to a \tikzname\ graphic, the |calendar| library is
most useful. The library provides the |\calendar| command, which takes a large
number of options and which can be configured in many ways to produce just
about any kind of calendar imaginable. For Johannes' purposes, a simple
|day list downward| will be a nice option since it produces a list of days that
go ``downward''.

为了在\tikzname\ 图形中添加日历，最有用的是|calendar|库。该库提供了|\calendar|命令，该命令接受许多选项，并且可以以许多方式进行配置，以产生几乎任何可想象的日历。对于约翰尼斯的目的，一个简单的|day list downward|选项将是一个不错的选择，因为它会产生一个“向下”进行的日期列表。
%
\begin{codeexample}[
    leave comments,
    preamble={\usetikzlibrary{calendar}},
]
\tiny
\begin{tikzpicture}
  \calendar [day list downward,
             name=cal,
             dates=2009-04-01 to 2009-04-14]
    if (weekend)
      [black!25];
\end{tikzpicture}
\end{codeexample}

Using the |name| option, we gave a name to the calendar, which will allow us to
reference the nodes that make up the individual days of the calendar later on.
For instance, the rectangular node containing the |1| that represents April
1st, 2009, can be referenced as |(cal-2009-04-01)|. The |dates| option is used
to specify an interval for which the calendar should be drawn. Johannes will
need several months in his calendar, but the above example only shows two weeks
to save some space.

使用|name|选项，我们为日历赋予了一个名称，这将允许我们稍后引用组成日历中各个日期的节点。例如，包含表示2009年4月1日的|1|的矩形节点可以引用为|(cal-2009-04-01)|。|dates|选项用于指定要绘制的日历的时间间隔。约翰尼斯的日历需要几个月，但上面的例子只显示了两周，以节省一些空间。

Note the |if (weekend)| construct. The |\calendar| command is followed by
options and then by |if|-statements. These |if|-statements are checked for each
day of the calendar and when a date passes this test, the options or the code
following the |if|-statement is executed. In the above example, we make weekend
days (Saturdays and Sundays, to be precise) lighter than normal days. (Use your
favorite calendar to check that, indeed, April 5th, 2009, is a Sunday.)

请注意|if (weekend)|的结构。|\calendar|命令后面跟着选项，然后是|if|语句。这些|if|语句会对日历的每一天进行检查，当日期通过测试时，执行该选项或|if|语句后面的代码。在上面的例子中，我们使周末（准确地说，是星期六和星期日）的颜色较浅。 （使用您喜欢的日历查看一下，确实，2009年4月5日是星期日。）

As mentioned above, Johannes can reference the nodes that are used to typeset
days. Recall that his |\lecture| macro already got passed a date, which we did
not use, yet. We can now use it to place the lecture's title next to the date
when the lecture will be held:

如上所述，约翰尼斯可以引用用于排版日期的节点。回想一下，他的|\lecture|宏已经传递了一个日期，我们尚未使用它。现在我们可以使用它来在将举行讲座的日期旁边放置讲座标题：
%
\begin{codeexample}[code only]
\def\lecture#1#2#3#4#5#6{
  % As before:
  \node [annotation, #3, scale=0.65, text width=4cm, inner sep=2mm] at (#4) {
    Lecture #1: \textcolor{orange}{\textbf{#2}}
    \list{--}{\topsep=2pt\itemsep=0pt\parsep=0pt
              \parskip=0pt\labelwidth=8pt\leftmargin=8pt
              \itemindent=0pt\labelsep=2pt}
    #5
    \endlist
  };
  % New:
  \node [anchor=base west] at (cal-#6.base east) {\textcolor{orange}{\textbf{#2}}};
}
\end{codeexample}
\def\lecture#1#2#3#4#5#6{
  \node [anchor=base west] at (cal-#6.base east) {\textcolor{orange}{\textbf{#2}}};
}

Johannes can now use this new |\lecture| command as follows (in the example,
only the new part of the definition is used):

现在，约翰尼斯可以使用这个新的|\lecture|命令，如下所示（在示例中，只使用了定义的新部分）：
%
\begin{codeexample}[
    preamble={\usetikzlibrary{calendar}},
    pre={ % !!! replace all `##x` with `#x`
\def\lecture##1##2##3##4##5##6{
  \node [anchor=base west] at (cal-##6.base east) {\textcolor{orange}{\textbf{##2}}};
}},
]
\tiny
\begin{tikzpicture}
  \calendar [day list downward,
             name=cal,
             dates=2009-04-01 to 2009-04-14]
    if (weekend)
      [black!25];

  % As before:
  \lecture{1}{Computational Problems}{above,xshift=-3mm}
  {Computational Problems.north}{
    \item Knowledge of several key problems
    \item Knowledge of problem encodings
    \item Being able to formalize problems
  }{2009-04-08}
\end{tikzpicture}
\end{codeexample}

As a final step, Johannes needs to add a few more options to the calendar
command: He uses the |month text| option to configure how the text of a month
is rendered (see Section~\ref{section-calender} for details) and then typesets
the month text at a special position at the beginning of each month.

最后一步，约翰尼斯需要对日历命令添加一些选项：他使用|month text|选项来配置月份的文本呈现方式（详细信息请参见第~\ref{section-calender}节），然后在每个月的开头特殊位置上排版月份文本。
%
\begin{codeexample}[
    leave comments,
    preamble={\usetikzlibrary{calendar}},
    pre={ % !!! replace all `##x` with `#x`
\def\lecture##1##2##3##4##5##6{
  \node [anchor=base west] at (cal-##6.base east) {\textcolor{orange}{\textbf{##2}}};
}},
]
\tiny
\begin{tikzpicture}
  \calendar [day list downward,
             month text=\%mt\ \%y0,
             month yshift=3.5em,
             name=cal,
             dates=2009-04-01 to 2009-05-01]
    if (weekend)
      [black!25]
    if (day of month=1) {
      \node at (0pt,1.5em) [anchor=base west] {\small\tikzmonthtext};
    };

  \lecture{1}{Computational Problems}{above,xshift=-3mm}
  {Computational Problems.north}{
    \item Knowledge of several key problems
    \item Knowledge of problem encodings
    \item Being able to formalize problems
  }{2009-04-08}

  \lecture{2}{Computational Models}{above,xshift=-3mm}
  {Computational Models.north}{
    \item Knowledge of Turing machines
    \item Being able to compare the computational power of different
      models
  }{2009-04-15}
\end{tikzpicture}
\end{codeexample}


\subsection{The Complete Code\\完整代码}

Putting it all together, Johannes gets the following code:

将所有内容整合在一起，约翰尼斯得到以下代码：

First comes the definition of the |\lecture| command:

首先是|\lecture|命令的定义：
%
\begin{codeexample}[code only]
\def\lecture#1#2#3#4#5#6{
  % As before:
  \node [annotation, #3, scale=0.65, text width=4cm, inner sep=2mm, fill=white] at (#4) {
    Lecture #1: \textcolor{orange}{\textbf{#2}}
    \list{--}{\topsep=2pt\itemsep=0pt\parsep=0pt
              \parskip=0pt\labelwidth=8pt\leftmargin=8pt
              \itemindent=0pt\labelsep=2pt}
    #5
    \endlist
  };
  % New:
  \node [anchor=base west] at (cal-#6.base east) {\textcolor{orange}{\textbf{#2}}};
}
\end{codeexample}

This is followed by the main mindmap setup\dots


然后是主要的思维导图设置\dots
%
\begin{codeexample}[code only]
\noindent
\begin{tikzpicture}
  \begin{scope}[
    mindmap,
    every node/.style={concept, circular drop shadow,execute at begin node=\hskip0pt},
    root concept/.append style={
      concept color=black,
      fill=white, line width=1ex,
      text=black, font=\large\scshape},
    text=white,
    computational problems/.style={concept color=red,faded/.style={concept color=red!50}},
    computational models/.style={concept color=blue,faded/.style={concept color=blue!50}},
    measuring complexity/.style={concept color=orange,faded/.style={concept color=orange!50}},
    solving problems/.style={concept color=green!50!black,faded/.style={concept color=green!50!black!50}},
    grow cyclic,
    level 1/.append style={level distance=4.5cm,sibling angle=90,font=\scshape},
    level 2/.append style={level distance=3cm,sibling angle=45,font=\scriptsize}]
\end{codeexample}
%
\dots and contents:

\dots 和内容：
%
\begin{codeexample}[code only]
  \node [root concept] (Computational Complexity) {Computational Complexity} % root
      child [computational problems] { node [yshift=-1cm] (Computational Problems) {Computational Problems}
        child         { node (Problem Measures) {Problem Measures} }
        child         { node (Problem Aspects) {Problem Aspects} }
        child [faded] { node (problem Domains) {Problem Domains} }
        child         { node (Key Problems) {Key Problems} }
      }
      child [computational models] { node [yshift=-1cm]  (Computational Models) {Computational Models}
        child         { node (Turing Machines) {Turing Machines} }
        child [faded] { node (Random-Access Machines) {Random-Access Machines} }
        child         { node (Circuits) {Circuits} }
        child [faded] { node (Binary Decision Diagrams) {Binary Decision Diagrams} }
        child         { node (Oracle Machines) {Oracle Machines} }
        child         { node (Programming in Logic) {Programming in Logic} }
      }
      child [measuring complexity] { node [yshift=1cm] (Measuring Complexity) {Measuring Complexity}
        child         { node (Complexity Measures) {Complexity Measures} }
        child         { node (Classifying Complexity) {Classifying Complexity} }
        child         { node (Comparing Complexity) {Comparing Complexity} }
        child [faded] { node (Describing Complexity) {Describing Complexity} }
      }
      child [solving problems] { node [yshift=1cm] (Solving Problems) {Solving Problems}
        child         { node (Exact Algorithms) {Exact Algorithms} }
        child         { node (Randomization) {Randomization} }
        child         { node (Fixed-Parameter Algorithms) {Fixed-Parameter Algorithms} }
        child         { node (Parallel Computation) {Parallel Computation} }
        child         { node (Partial Solutions) {Partial Solutions} }
        child         { node (Approximation) {Approximation} }
      };
  \end{scope}
\end{codeexample}
%
Now comes the calendar code:

现在是日历代码：
%
\begin{codeexample}[code only]
  \tiny
  \calendar [day list downward,
             month text=\%mt\ \%y0,
             month yshift=3.5em,
             name=cal,
             at={(-.5\textwidth-5mm,.5\textheight-1cm)},
             dates=2009-04-01 to 2009-06-last]
    if (weekend)
      [black!25]
    if (day of month=1) {
      \node at (0pt,1.5em) [anchor=base west] {\small\tikzmonthtext};
    };
\end{codeexample}
%
The lecture annotations:

讲座注释：
%
\begin{codeexample}[code only]
  \lecture{1}{Computational Problems}{above,xshift=-5mm,yshift=5mm}{Computational Problems.north}{
    \item Knowledge of several key problems
    \item Knowledge of problem encodings
    \item Being able to formalize problems
  }{2009-04-08}

  \lecture{2}{Computational Models}{above left}
  {Computational Models.west}{
    \item Knowledge of Turing machines
    \item Being able to compare the computational power of different
      models
  }{2009-04-15}
\end{codeexample}
%
Finally, the background:

最后，是背景：
%
\begin{codeexample}[code only]
  \begin{pgfonlayer}{background}
    \clip[xshift=-1cm] (-.5\textwidth,-.5\textheight) rectangle ++(\textwidth,\textheight);

    \colorlet{upperleft}{green!50!black!25}
    \colorlet{upperright}{orange!25}
    \colorlet{lowerleft}{red!25}
    \colorlet{lowerright}{blue!25}

     % The large rectangles:
    \fill [upperleft]  (Computational Complexity) rectangle ++(-20,20);
    \fill [upperright] (Computational Complexity) rectangle ++(20,20);
    \fill [lowerleft]  (Computational Complexity) rectangle ++(-20,-20);
    \fill [lowerright] (Computational Complexity) rectangle ++(20,-20);

    % The shadings:
    \shade [left color=upperleft,right color=upperright]
      ([xshift=-1cm]Computational Complexity) rectangle ++(2,20);
    \shade [left color=lowerleft,right color=lowerright]
      ([xshift=-1cm]Computational Complexity) rectangle ++(2,-20);
    \shade [top color=upperleft,bottom color=lowerleft]
      ([yshift=-1cm]Computational Complexity) rectangle ++(-20,2);
    \shade [top color=upperright,bottom color=lowerright]
      ([yshift=-1cm]Computational Complexity) rectangle ++(20,2);
  \end{pgfonlayer}
\end{tikzpicture}
\end{codeexample}

The next page shows the resulting lecture map in all its glory (it
would be somewhat more glorious, if there were more lecture
annotations, but you should get the idea).

下一页展示了最终的讲座思维导图，展现了它所有的辉煌（如果有更多的讲座注释，它将会更加辉煌，但你应该能够明白）。

\def\lecture#1#2#3#4#5#6{
  % As before:
  \node [annotation, #3, scale=0.65, text width=4cm, inner sep=2mm, fill=white] at (#4) {
    Lecture #1: \textcolor{orange}{\textbf{#2}}
    \list{--}{\topsep=2pt\itemsep=0pt\parsep=0pt
              \parskip=0pt\labelwidth=8pt\leftmargin=8pt
              \itemindent=0pt\labelsep=2pt}
    #5
    \endlist
  };
  % New:
  \node [anchor=base west] at (cal-#6.base east) {\textcolor{orange}{\textbf{#2}}};
}

\noindent
\begin{tikzpicture}
  \begin{scope}[
    mindmap,
    every node/.style={concept, circular drop shadow,execute at begin node=\hskip0pt},
    root concept/.append style={
      concept color=black,
      fill=white, line width=1ex,
      text=black, font=\large\scshape},
    text=white,
    computational problems/.style={concept color=red,faded/.style={concept color=red!50}},
    computational models/.style={concept color=blue,faded/.style={concept color=blue!50}},
    measuring complexity/.style={concept color=orange,faded/.style={concept color=orange!50}},
    solving problems/.style={concept color=green!50!black,faded/.style={concept color=green!50!black!50}},
    grow cyclic,
    level 1/.append style={level distance=4.5cm,sibling angle=90,font=\scshape},
    level 2/.append style={level distance=3cm,sibling angle=45,font=\scriptsize}]
    \node [root concept] (Computational Complexity) {Computational Complexity} % root
      child [computational problems] { node [yshift=-1cm] (Computational Problems) {Computational Problems}
        child         { node (Problem Measures) {Problem Measures} }
        child         { node (Problem Aspects) {Problem Aspects} }
        child [faded] { node (problem Domains) {Problem Domains} }
        child         { node (Key Problems) {Key Problems} }
      }
      child [computational models] { node [yshift=-1cm]  (Computational Models) {Computational Models}
        child         { node (Turing Machines) {Turing Machines} }
        child [faded] { node (Random-Access Machines) {Random-Access Machines} }
        child         { node (Circuits) {Circuits} }
        child [faded] { node (Binary Decision Diagrams) {Binary Decision Diagrams} }
        child         { node (Oracle Machines) {Oracle Machines} }
        child         { node (Programming in Logic) {Programming in Logic} }
      }
      child [measuring complexity] { node [yshift=1cm] (Measuring Complexity) {Measuring Complexity}
        child         { node (Complexity Measures) {Complexity Measures} }
        child         { node (Classifying Complexity) {Classifying Complexity} }
        child         { node (Comparing Complexity) {Comparing Complexity} }
        child [faded] { node (Describing Complexity) {Describing Complexity} }
      }
      child [solving problems] { node [yshift=1cm] (Solving Problems) {Solving Problems}
        child         { node (Exact Algorithms) {Exact Algorithms} }
        child         { node (Randomization) {Randomization} }
        child         { node (Fixed-Parameter Algorithms) {Fixed-Parameter Algorithms} }
        child         { node (Parallel Computation) {Parallel Computation} }
        child         { node (Partial Solutions) {Partial Solutions} }
        child         { node (Approximation) {Approximation} }
      };
  \end{scope}

  \tiny
  \calendar [day list downward,
             month text=\%mt\ \%y0,
             month yshift=3.5em,
             name=cal,
             at={(-.5\textwidth-5mm,.5\textheight-1cm)},
             dates=2009-04-01 to 2009-06-last]
    if (weekend)
      [black!25]
    if (day of month=1) {
      \node at (0pt,1.5em) [anchor=base west] {\small\tikzmonthtext};
    };

  \lecture{1}{Computational Problems}{above,xshift=-5mm,yshift=5mm}{Computational Problems.north}{
    \item Knowledge of several key problems
    \item Knowledge of problem encodings
    \item Being able to formalize problems
  }{2009-04-08}

  \lecture{2}{Computational Models}{above left}
  {Computational Models.west}{
    \item Knowledge of Turing machines
    \item Being able to compare the computational power of different
      models
  }{2009-04-15}

  \begin{pgfonlayer}{background}
    \clip[xshift=-1cm] (-.5\textwidth,-.5\textheight) rectangle ++(\textwidth,\textheight);

    \colorlet{upperleft}{green!50!black!25}
    \colorlet{upperright}{orange!25}
    \colorlet{lowerleft}{red!25}
    \colorlet{lowerright}{blue!25}

     % The large rectangles:
    \fill [upperleft]  (Computational Complexity) rectangle ++(-20,20);
    \fill [upperright] (Computational Complexity) rectangle ++(20,20);
    \fill [lowerleft]  (Computational Complexity) rectangle ++(-20,-20);
    \fill [lowerright] (Computational Complexity) rectangle ++(20,-20);

    % The shadings:
    \shade [left color=upperleft,right color=upperright]
      ([xshift=-1cm]Computational Complexity) rectangle ++(2,20);
    \shade [left color=lowerleft,right color=lowerright]
      ([xshift=-1cm]Computational Complexity) rectangle ++(2,-20);
    \shade [top color=upperleft,bottom color=lowerleft]
      ([yshift=-1cm]Computational Complexity) rectangle ++(-20,2);
    \shade [top color=upperright,bottom color=lowerright]
      ([yshift=-1cm]Computational Complexity) rectangle ++(20,2);
  \end{pgfonlayer}
\end{tikzpicture}
