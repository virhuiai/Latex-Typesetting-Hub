%%%%%%%%%%%%%%%{fontspec}%%%%%%%%%%%%%%%
%将no-math选项传递给fontspec宏包，该选项禁用了使用fontspec宏包中的数学字体功能。
\PassOptionsToPackage{no-math}{fontspec}
%%%%%%%%%%%%%%%{xeCJK}%%%%%%%%%%%%%%%
%将AutoFakeBold和AutoFakeSlant选项传递给xeCJK宏包，这两个选项让xeCJK宏包自动产生伪粗体和伪斜体效果。
\PassOptionsToPackage{AutoFakeBold=true,AutoFakeSlant=true}{xeCJK}

\documentclass[twoside]{article}
\usepackage[heading=true
,scheme=chinese%中文方案
,fontset=none%不使用默认的字体设置
,space=auto%自动调整中英文间距
]{ctex}
\setCJKmainfont{方正书宋_GBK}%方正书宋_GBK.TTF  设置文本的中文有衬线字体为“方正书宋_GBK”
\setCJKsansfont{方正黑体简体}%方正黑体_GBK.TTF  设置文本的中文无衬线字体为“方正黑体简体”
\setCJKmonofont{方正书宋简体}%方正仿宋_GBK.TTF  设置文本的中文等宽字体为“方正书宋简体”
\usepackage{pdfcolparcolumns}
\usepackage{cprotect}
\usepackage{libertinus-otf}
\setmonofont[Scale=MatchLowercase,FakeStretch=0.9]{AnonymousPro-Regular.ttf}
\newif\ifChangeBar \ChangeBarfalse
\usepackage{fancyvrb}
\usepackage{fancyvrb-ex}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead[RE,LO]{}
\fancyhead[RO]{\leftmark}

\usepackage{xurl}

\usepackage[colorlinks,linktocpage]{hyperref}
\parskip=3pt plus 1pt minus 1pt
%

\newcommand\FBoxPackage{`\textsf{fancybox}'}
\newcommand\FVrbPackage{`\textsf{fancyvrb}'}
\newcommand\cs[1]{\texttt{\textbackslash#1}}
%
%  From ltugboat.cls
%
%  Typeset the name of an environment
\providecommand\env[1]{\textsf{#1}}
\providecommand\clsname[1]{\textsf{#1}}
\providecommand\pkgname[1]{\textsf{#1}}
\providecommand\optname[1]{\textsf{#1}}
\providecommand\progname[1]{\textsf{#1}}
%
%  A list of options for a package/class
\newenvironment{optlist}{\begin{description}%
  \renewcommand\makelabel[1]{%
    \descriptionlabel{\mdseries\optname{##1}}}%
  \itemsep0.25\itemsep}%
 {\end{description}}
%
%  Utility macros
%
%  Special dashes

\makeatletter
\def\thinskip{\hskip 0.16667em\relax}
\def\endash{--}
\def\emdash{\endash-}
\def\d@sh#1#2{\unskip#1\thinskip#2\thinskip\ignorespaces}
\def\dash{\d@sh\nobreak\endash}
\def\Dash{\d@sh\nobreak\emdash}
\makeatother
\newif\ifPostScriptFonts \PostScriptFontstrue
%
\setlength{\columnseprule}{0.6pt}

\newcommand\verbatimTxt{抄录}
%
\newif\ifmulticols
%\IfFileExists{multicol.sty}{\multicolstrue}{}
\newif\ifpstricks
\pstrickstrue
%
\title{The `\textsf{fancyvrb}' package\\Fancy Verbatims in \LaTeX}
\author{Timothy Van Zandt\\Princeton University\\Princeton -- USA\\[5mm]
%        {\footnotesize \url{tvz@Princeton.EDU}}\\[5mm]
        {Packaging and documentation by}\\
        {\footnotesize Denis Girou (CNRS/IDRIS -- France),}\\[-2mm]
        {\footnotesize Sebastian Rahtz\dagger\ (Elsevier -- GB)}\\[-2mm]
        {\footnotesize and}\\[-2mm]
        {\footnotesize Herbert Voß\ (FU Berlin -- DE)}\\[-2mm]
        {\footnotesize 翻译:virhuiai@qq.com}
        }
\date{\today}

\fvset{frame=single,xrightmargin=0cm,numbers=left,numbersep=3pt,commentchar=Z}

\begin{document}
\parindent=0pt
\maketitle

\VerbatimFootnotes
%
\begin{abstract}
% \makebox[0pt]{}
% \addvspace{\parskip}
% \begin{parcolumns}[nofirstindent,colwidths={2=.52\linewidth}]{2}
% \colchunk{\textsf{fancyvrb}宏包提供了高度可配置的抄录环境。用户可以对抄录环境做的有：修改
% 字体、修改字号、为抄录内容加上行号、使用带边框的代码示例环境、高亮抄录的文本、 以及有条件的处理抄录文本等等。}
% \colchunk{
\hspace*{-\parindent}%
This package provides very sophisticated facilities for reading and
writing verbatim \TeX{} code. Users can perform common tasks like changing
font family and size, numbering lines, framing code examples, colouring
text and conditionally processing text.

% }
% \colchunk{
\hspace*{-\parindent}%
该软件包提供了非常复杂的工具，可以读取和编写逐字逐句的 \TeX{} 代码。用户可以执行常见的任务，如更改字体系列和大小、编号、给代码示例加框、着色文本和有条件地处理文本。

% }
% \end{parcolumns}
    
\end{abstract}

\begin{center}
Report bugs to \url{hvoss@tug.org}
\end{center}

\vfill
Thanks to 
Claudio Beccari,
Jean-François Burnol, 
Philippe Esperet, %\url{esperet@marie.polytechnique.fr}, 
Michael Friendly, %\url{friendly@hotspur.psych.yorku.ca}, 
Mario Hassler, %\url{HASSLER@ippnv2.ipp.kfa-juelich.de}, 
Ohad Kammar, % \url{ohad.kammar@ed.ac.uk},
Mikhail Kolodin, %\url{myke@morrigan.spb.su}, 
Andreas Matthias,
Frank Mittelbach,
Rolf Niepraschk, %\url{Rolf.Niepraschk@gmx.de}, 
Will Robertson,
Ulrich M. Schwarz, 
Thomas Siegel, % \url{siegel@aix520.informatik.uni-leipzig.de}, 
Clemens Steinke,
and 
Vladimir Volovich. %\url{vvv@vvv.vsu.ru}.
\clearpage
\tableofcontents
\clearpage
%\part{\texttt{fancyvrb} package by Timothy Van Zandt}


\part{Package \texttt{fancyvrb}}


\section{Introduction\\介绍}

\FVrbPackage{} is the development of the \emph{verbatim} macros of the
\FBoxPackage{} package,  Section 11 of \cite{FancyBox}. It offers six kinds
of extended functionality, compared to the standard \LaTeX{}
\textsf{verbatim} environment:
%

%   \FVrbPackage{} is the development of the \emph{verbatim} macros of the
% \FBoxPackage{} package,  Section 11 of \cite{FancyBox}. 同标准的 \LaTeX{}
% \textsf{verbatim} 环境相比， \FVrbPackage{} 提供了6种拓展功能,:

\FVrbPackage{} 是 \FBoxPackage{} 软件包中 \emph{verbatim} 宏的发展，详见 \cite{FancyBox} 的第11节。相较于标准的 \LaTeX{} \textsf{verbatim} 环境，它提供了六种扩展功能：

\begin{enumerate}
% \item {\em\verbatimTxt}命令可以在脚注中使用,
\item verbatim commands can be used in footnotes,\par
verbatim 命令可以用于脚注中，

\item several verbatim commands are enhanced, {\par}
一些verbatim命令被增强，
%   \item 一些{\verbatimTxt}命令得到了加强,

\item a variety of verbatim environments are provided, with many
parameters to change the way the contents are printed; it is also possible
to define new customized verbatim environments,{\par}
提供了多种verbatim环境，并提供许多参数以更改内容打印的方式；还可以定义新的自定义verbatim环境，
%   \item 宏包自带了一些{\verbatimTxt}环境, 配有许多参数来控制内容的输出格式;它也让你能够更方便的定义新的符合自身需求的{\verbatimTxt}环境,

\item a way is provided to save and restore verbatim text and environments,{\par}
提供了一种保存和恢复verbatim文本和环境的方法，
%   \item 提供了保存和取用{\verbatimTxt}文本和环境方法,

\item there are macros to write and read files in verbatim mode, with the
usual versatility,{\par}
提供宏以verbatim模式编写和读取文件，具有通常的多用途性，
%   \item 在{\verbatimTxt}模式提供了命令以便读写文件, 这是很有用的。

\item you can build \emph{example} environments (showing both result and
verbatim text), with the same versatility as normal verbatim.{\par}
您可以构建\emph{example}环境（显示结果和verbatim文本），具有与普通verbatim相同的多用途性。
%   \item 你可以 build \emph{example} 环境 (同时展示出排版的结果和所使用的排版的代码), 
\end{enumerate}

The package works by scanning a line at a time from an environment or a
file. This allows it to pre-process each line, rejecting it, removing
spaces, numbering it, etc, before going on to execute the body of the line
with the appropriate catcodes set.

该宏包通过从环境或文件中每次扫描一行来工作。这使它能够在执行该行的主体之前对每一行进行预处理，拒绝该行，删除空格，编号等，然后使用适当的类别码执行该行的主体。

% % 该软件包通过从环境或文件中一次扫描一行来工作。
% 该宏包对抄录环境或从文件中读取文本是，每次只扫描一行。 %
% 这样的方式允许它 to pre-process each line, rejecting it, 移除空格, numbering it, etc, 
% before going on to execute the body of the line with the appropriate catcodes set.


\section{Verbatim material in footnotes\\脚注中的抄录材料}

%   调用 \cs{VerbatimFootnotes} 宏声明之后 (在the preamble之后使用),
% 就可以将 verbatim 命令和环境
% (the \LaTeX{} or \FVrbPackage{} ones) 放到脚注中了, 而标准的
% \LaTeX 中是不允许这样做的:

After a \cs{VerbatimFootnotes} macro declaration (to use after the
preamble), it is possible to put verbatim commands and environments
(the \LaTeX{} or \FVrbPackage{} ones) in footnotes, unlike in standard
\LaTeX:

在导言区之后使用 \cs{VerbatimFootnotes} 宏声明后，可以将抄录命令和环境（\LaTeX{} 或 \FVrbPackage{} 中的命令和环境）放入脚注中，这与标准 \LaTeX{} 不同：

\begin{Example}
  \VerbatimFootnotes
  We can put verbatim\footnote{\verb+_Yes1!_+} text in footnotes.
  我们可以将抄录\footnote{\verb+_Yes2!_+} 文本放到脚注中了.
\end{Example}

\section{Improved verbatim commands\\改进的抄录命令}

The \cs{DefineShortVerb} macro allows us to define a special character as
an abbreviation to enclose verbatim text and the \cs{UndefineShortVerb}
macro suppresses the special meaning of the specified character (the same
functionalities are provided in the \LaTeX{} `\textsf{shortvrb}' package):

\cs{DefineShortVerb} 宏允许我们将一个特殊字符定义为一个缩写，用来包围抄录文本，而 \cs{UndefineShortVerb} 宏则取消指定字符的特殊含义（\LaTeX{} 的 \textsf{shortvrb} 宏包提供了相同的功能）：
%
% \cs{DefineShortVerb}命令让我们可以指定一个符号作为抄录命令的简化方式，这个符号包围住要{\verbatimTxt}的文本。命令 \cs{UndefineShortVerb} 
% 用来取消这个效果 (%
% 在 \LaTeX{} 的 `\textsf{shortvrb}' 宏包中也提供了这两个命令):

\fvset{xrightmargin=4.8cm}

\begin{SideBySideExample}
  \DefineShortVerb{\|}
  We can simply write \Verb+_verbatim_+
  material using a single |_delimiter_|
  \UndefineShortVerb{\|}
  \DefineShortVerb{\+}
  And we can +_change_+ the character.
\end{SideBySideExample}

To make matters more versatile, we can nominate \emph{escape} characters
in verbatim text (using the \cs{Verb} macro or with a `shortverb' character
defined), to perform formatting or similar tasks, using the
\texttt{commandchars} parameter as shown for environments in paragraph
\ref{sec:commandchars}.

% 更强大的(使排版效果多多样化)是, 我们可以指定在抄录文本中的 \emph{escape} （转义）字符%
%  (using the \cs{Verb} macro or with a `shortverb' character
% defined), 以执行类似格式化这样内容, 请使用在\ref{sec:commandchars} 中介绍的，抄录环境的\texttt{commandchars} 参数 .
为了使抄录更加灵活，我们可以在抄录文本中指定转义字符（使用 \cs{Verb} 宏或定义了“shortverb”字符），以执行格式化或类似任务，使用 \texttt{commandchars} 参数，就像第 \ref{sec:commandchars} 段中的环境一样。

\section{Verbatim environments\\Verbatim 抄录环境}
%\section{Verbatim 环境}

Several verbatim environments are available, each with a lot of
parameters to customize them. In the following examples we use the
\texttt{Verbatim} environment, which is the equivalent of the standard
\texttt{verbatim}. The parameters can be set globally using the \cs{fvset}
macro or in an optional argument after the start of the
environment\footnote{For clarification in this paper, note that we
generally indent each verbatim line with two
spaces.}$^,$\footnote{This mechanism uses the
`\textbf{keyval}' package from the standard \LaTeX{} graphics
distribution, written by David \textsc{Carlisle}.}.

有几个抄录环境可用，每个环境都有许多参数可供自定义。在以下示例中，我们使用 \texttt{Verbatim} 环境，它相当于标准的 \texttt{verbatim} 环境。参数可以在 \cs{fvset} 宏中全局设置，或在环境开始后的可选参数中设置\footnote{为了在本文中澄清，我们通常用两个空格缩进每行抄录。}$^,$\footnote{此机制使用了由David \textsc{Carlisle}编写的标准 \LaTeX{} 图形发行版的 `\textbf{keyval}' 宏包。}。
% 提供了不少的 {\verbatimTxt} 环境, 都有一堆的参数可以用来配置。
% 下面的例子我使用了 \texttt{Verbatim} 环境, 它相当于标准 \LaTeX{} 的 \texttt{verbatim} 环境。
% 配置参数可以使用 \cs{fvset} 命令全局设置，
% 也可以作为可选参数在环境的开始处指定\footnote{For clarification in this paper, note that we
% generally indent each verbatim line with two
% spaces.}$^,$\footnote{This mechanism uses the
% `\textbf{keyval}' package from the standard \LaTeX{} graphics
% distribution, written by David \textsc{Carlisle}.}.

\begin{SideBySideExample}
  \begin{Verbatim}
    First verbatim line.
    Second verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

\subsection{Customization of verbatim environments\\定制化verbatim环境}
% \subsection{{\verbatimTxt}环境的设置}

The appearance of verbatim environments can be changed in many and
varied ways; here we list the keys that can be set. 

可以通过多种方式改变verbatim环境的外观，以下列出可设置的参数。
% {\verbatimTxt}环境的输出效果，有不少是可以定制的; 下面列出我们可以设置的参数。


\subsubsection{Comments\\注释}


\begin{optlist}
  \item[commentchar (character)]: character to define comments in the
  verbatim code, so that lines starting with this character will not be
  printed (\emph{Default: empty}).
\\定义注释的字符，在以该字符开头的行将不会被打印 (\emph{默认值: 空}).
\end{optlist}

% \begin{optlist}
%   \item[commentchar (字符)]: 定义{\verbatimTxt}环境中的注释字符，
% 若某行以此字符开头，在输出中你整行都不会看到 (\emph{默认: empty})。
% \end{optlist}

\begin{SideBySideExample}
  \begin{Verbatim}[commentchar=!]
    A comment
    Verbatim line.！一
    ! 二、这行注释在输出中你是看不到的
  \end{Verbatim}
\end{SideBySideExample}

Take care to a special effect if the comment character is not the first
non blank one: it is because this character is in fact managed as the \TeX{}
comment one, that is to say that it gobble the newline character too. So, in
this case, the current line will be joined with the next one and, more, the
last one will be lost if it contain a comment, as \FVrbPackage{} print a
line only after finding it end character, which will never occured in this
case...

  % 要注意一种特殊的情况，当注释符不是第一个非空白字符时: 这是因为我们定义的这个注释符是被等同于 \TeX{} 的注释符了, 这意味着换行符也会被忽略. 因此，这种情况下, 当前行和下一行会合为一行了, 另外, 如果最后一行包含注释符，最后一行的内容也不会输出, 因为 \FVrbPackage{} 宏包的每一行的输出是在遇到结束符才执行的，而最后一行包含注释符这个情况下永远不会遇到结束符\ldots
注意，如果注释字符不是第一个非空字符，则会有特殊效果：这是因为该字符实际上被视为\TeX{}中的注释字符，也就是说它会吞掉换行符。所以，在这种情况下，当前行将与下一行连接起来，并且如果最后一行包含注释，则会丢失最后一行，因为\FVrbPackage{}只有在找到它的结束字符后才会打印一行，而这种情况永远不会发生...

\begin{SideBySideExample}
  \begin{Verbatim}[commentchar=\%]
    第一行. % First line
    第二行.
    第三行. % Third line lost...
  \end{Verbatim}
\end{SideBySideExample}

\begin{SideBySideExample}
  \begin{Verbatim}[commentchar=\%]
    第一行. 
    第二行. 
    最后一行包含注释符. % 不输出
  \end{Verbatim}
\end{SideBySideExample}

\subsubsection{Initial characters to suppress\\起初始字符的忽略}
% \subsubsection{忽略起始的字符数量}

\begin{optlist}
\item[gobble (integer)]: number of characters to suppress at the beginning
of each line (up to a maximum of 9), mainly useful when environments are
indented
(\emph{Default: empty} \Dash no character suppressed).

每行开头要忽略的字符数（最多9个），主要在内容起始缩进时有用（\emph{默认值：空} \Dash 没有被忽略的字符）。
\end{optlist}

% \begin{optlist}
%   \item[gobble (integer)]: 每行开始跳过的字符数 (最大值为9), 
% 这在包含有空格缩进的内容时很有用%
% (\emph{默认: empty} \Dash 没有字符被忽略)。
% \end{optlist}

\begin{SideBySideExample}
  \begin{Verbatim}
    Verbatim line.
  \end{Verbatim}

  \begin{Verbatim}[gobble=2]
    Verbatim line.
  \end{Verbatim}

  \begin{Verbatim}[gobble=8]
    Verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

\subsubsection{Customization of formatting\\自定义格式。}
% \subsubsection{指定修饰格式}


\begin{optlist}
  \item[formatcom (command)]: command to execute before printing verbatim
  text
  (\emph{Default: empty}).

在打印抄录文本之前执行的命令(\emph{默认值：空}).
\end{optlist}

% \begin{optlist}
%   \item[formatcom (命令)]: 指定输出 {\verbatimTxt} 文本之前运行的命令。
%   (\emph{默认: empty}).
% \end{optlist}

\begin{SideBySideExample}
  \begin{Verbatim}[formatcom=\color{red}]
    First verbatim line.
    Second verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

\subsubsection{Changing individual line formatting\\更改每行格式}
% \subsubsection{修改每行的格式化方式}

% \begin{parcolumns}[rulebetween=true,colwidths={1=.6\linewidth}]{2}
% \colchunk{\cs{FancyVerbFormatLine} 宏定义了每行的格式。默认值为}
% \colchunk{The macro \cs{FancyVerbFormatLine} defines the way each line is formatted.
% Its default value is}
% \end{parcolumns}

The macro \cs{FancyVerbFormatLine} defines the way each line is formatted.
Its default value is

\cs{FancyVerbFormatLine} 宏定义了每行的格式。默认值为

%TODO 用方框包围
\verb+\def\FancyVerbFormatLine#1{#1}+

but we can
redefine it at our convenience (\texttt{FancyVerbLine} is the name of the
line counter):

但我们可以按照需要重新定义它（\texttt{FancyVerbLine} 是行计数器的名称）。

% \cs{FancyVerbFormatLine}命令定义了每行的格式化方式。
% 默认值是\marginpar{\small 译注:原样输出}\\ \verb+\def\FancyVerbFormatLine#1{#1}+, 我们也可以
% 按我们的需要，重新定义它({\verbatimTxt}环境中，行号的计数器名是\texttt{FancyVerbLine}):

{\fvset{fontsize=\small}
\begin{SideBySideExample}
  Z\fvset{fontsize=\normalsize}
  \renewcommand{\FancyVerbFormatLine}[1]{%
    \makebox[0cm][l]{$\Rightarrow$}#1}
  \begin{Verbatim}
    First verbatim line.
    Second verbatim line.
    Third verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

\begin{SideBySideExample}
  \renewcommand{\FancyVerbFormatLine}[1]{%
    \ifodd\value{FancyVerbLine}%
      \MakeUppercase{#1}\else#1\fi}
  \begin{Verbatim}
    First verbatim line.
    Second verbatim line.
    Third verbatim line.
  \end{Verbatim}
\end{SideBySideExample}
}

\subsubsection{Fonts\\字体}

\begin{optlist}
  \item[fontfamily (family name)]: font family to use.
  \texttt{tt}, \texttt{courier} and \texttt{helvetica} are pre-defined
  (\emph{Default:~tt}).

所使用的字体族。%
\texttt{tt}、\texttt{courier} 和 \texttt{helvetica} 是预定义的
(\emph{默认：tt}).
\end{optlist}

% \begin{optlist}
%   \item[fontfamily (family name)]: 使用的字体。 预定义的有：
%   \texttt{tt}、 \texttt{courier} 和 \texttt{helvetica} 
%   (\emph{默认:~tt}).
% \end{optlist}

\ifPostScriptFonts  We can guess that PostScript fonts are available

% \ifPostScriptFonts  我们可以猜测，PostScript字体是可用的\marginpar{\small\tt{\textbackslash}ifPostScriptFonts}
我们可以猜测您的平台有PostScript字体
% \marginpar{\small\tt{\textbackslash}ifPostScriptFonts}

\begin{SideBySideExample}
  \begin{Verbatim}[fontfamily=helvetica]
    Verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

\else
\begin{quote}
    \textbf{\large Warning!} PostScript fonts seems not available on your
  platform (we are looking for the file \texttt{times.sty}, so we will
  not show the examplaes using such PostScript fonts.

\textbf{\large 警告!} 您的平台似乎没有可用的PostScript字体
(我们正在寻找文件\texttt{times.sty}，因此我们将不显示使用此类PostScript字体的示例。
\end{quote}
\fi

\begin{optlist}
  \item[fontsize (font size)]: size of the font to use
  (\emph{Default: auto} \Dash the same as the current font). If you use the
  `\textsf{relsize}' package too, you can require a change of the size
  proportional to the current one\footnote{for instance:
  \verb+fontsize=\relsize{-2}+}.

所使用字体的大小
(\emph{默认：auto} \Dash 与当前字体相同)。如果您也使用`\textsf{relsize}'宏包，您可以要求大小与当前大小成比例的变化\footnote{例如：\verb+fontsize=\relsize{-2}+}。
\end{optlist}

% \begin{optlist}
%   \item[fontsize (font size)]: 要使用的字体的大小
%   (\emph{默认: auto} \Dash 同当前字号一致). 如果你也使用了 `\textsf{relsize}' 宏包，
%   您可以将之改成与当前字体成比例的大小
%   (例如:
%   \verb+fontsize=\relsize{-2}+).
% \end{optlist}

\ifPostScriptFonts  We can guess that PostScript fonts are available

我们可以猜测，PostScript字体是可用的

\begin{SideBySideExample}
  \begin{Verbatim}[fontsize=\small]
    Verbatim line.
  \end{Verbatim}

  \begin{Verbatim}[fontfamily=courier,
                   fontsize=\large]
    Verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

\else
\begin{SideBySideExample}
  \begin{Verbatim}[fontsize=\small]
    Verbatim line.
  \end{Verbatim}
\end{SideBySideExample}
\fi

\begin{optlist}
  \item[fontshape (font shape)]: font shape to use
  (\emph{Default: auto} \Dash the same as the current font).

所使用字体的形状
(\emph{默认：auto} \Dash 与当前字体相同)。
\end{optlist}

% \begin{optlist}
%   \item[fontshape (字形)]: 使用的字形
%   (\emph{默认: auto} \Dash 同当前字形一致).
% \end{optlist}

\ifPostScriptFonts  We can guess that PostScript fonts are available

我们可以猜测，PostScript字体是可用的

\begin{SideBySideExample}
  \begin{Verbatim}[fontfamily=courier,
                   fontshape=it]
    Verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

\else

\begin{SideBySideExample}
  \begin{Verbatim}[fontshape=it]
    Verbatim line.
  \end{Verbatim}
\end{SideBySideExample}
\fi

\begin{optlist}
  \item[fontseries (series name)]: \LaTeX{} font `series' to use
  (\emph{Default: auto} \Dash the same as the current font).

\LaTeX{} 字体的 `系列’ 选择 (\emph{默认: auto} \Dash 和当前字体相同)。
\end{optlist}


% \begin{optlist}
%   \item[fontseries (series name)]: 使用的 \LaTeX{} 字体 `series'
%   (\emph{默认: auto} \Dash 同当前字体一致).
% \end{optlist}

\ifPostScriptFonts  We can guess that PostScript fonts are available

我们可以猜测，PostScript字体是可用的

\begin{SideBySideExample}
  \begin{Verbatim}[fontfamily=courier,
                   fontseries=b]
    Verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

\else
\begin{SideBySideExample}
  \begin{Verbatim}[fontseries=b]
    Verbatim line.
  \end{Verbatim}
\end{SideBySideExample}
\fi

\subsubsection{Types and characteristics of frames\\边框的类型和特征}
% \subsubsection{边框的类型和characteristics}

\begin{optlist}
  \item[frame 
  (none$\mid$leftline$\mid$topline$\mid$bottomline$\mid$lines$\mid$single)]:
  type of frame around the verbatim environment
  (\emph{Default: none} \Dash no frame). With \textsf{leftline} and
  \textsf{single} modes, a space of a length  given by the \LaTeX{}
  \cs{fboxsep} macro is added between the left vertical line and the text.

verbatim 环境周围的边框类型（\emph{默认值：none} \Dash 没有边框）。在 \textsf{leftline} 和 \textsf{single} 模式下，左垂直线和文本之间添加了一个长度由 \LaTeX{} 的 \cs{fboxsep} 宏给出的空间。
\end{optlist}

% \begin{optlist}
%   \item[frame 
%   (none$\mid$leftline$\mid$topline$\mid$bottomline$\mid$lines$\mid$single)]:
%   抄录文本的四周的边框类型
%   (\emph{默认: none} \Dash 无边框). 使用 \textsf{leftline} 和
%   \textsf{single} 模式时, \LaTeX{} 的
%   \cs{fboxsep} 命令指定的宽度的空白会被添加到左边的垂直线和文本之间。
% \end{optlist}

%  Problem at the top of a page...
\begin{SideBySideExample}
  \begin{Verbatim}[frame=leftline]
    抄录文本，leftline
  \end{Verbatim}
\end{SideBySideExample}

\begin{SideBySideExample}
  \begin{Verbatim}[frame=topline]
    抄录文本，topline
  \end{Verbatim}
\end{SideBySideExample}

\begin{SideBySideExample}
  \begin{Verbatim}[frame=bottomline]
    抄录文本，bottomline
  \end{Verbatim}
\end{SideBySideExample}

\begin{SideBySideExample}
  \begin{Verbatim}[frame=lines]
    抄录文本，lines
  \end{Verbatim}
\end{SideBySideExample}

\begin{SideBySideExample}
  \begin{Verbatim}[frame=single]
    抄录文本，single
  \end{Verbatim}
\end{SideBySideExample}

\begin{optlist}
  \item[framerule (dimension)]: width of the rule of the frame
  (\emph{Default: 0.4pt if framing specified}).

边框的宽度（\emph{默认值：0.4pt，如果指定了边框}）。
\end{optlist}

% \begin{optlist}
%   \item[framerule (dimension)]: 设置边框线的宽度
  
% \end{optlist}

\begin{SideBySideExample}
  \begin{Verbatim}[frame=single,
                   framerule=1mm]
    Verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

\begin{optlist}
  \item[framesep (dimension)]: width of the gap between the frame and
  the text (\emph{Default: \cs{fboxsep}}).

边框和文本之间的间隙宽度（\emph{默认值：\cs{fboxsep}}）。
\end{optlist}

% \begin{optlist}
%   \item[framesep (dimension)]:设置抄录文本与边框的距离 (\emph{默认: \cs{fboxsep}}).
% \end{optlist}

\begin{SideBySideExample}
  \begin{Verbatim}[frame=single,
                   framesep=5mm]
    Verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

\begin{optlist}
  \item[rulecolor (color command)]: color of the frame rule, expressed
  in the standard \LaTeX{} way
  (\emph{Default: black}).\\
边框线的颜色，用标准的 \LaTeX{} 方式表示
（\emph{默认为黑色}）。
\end{optlist}
% \begin{optlist}
%   \item[rulecolor (color command)]: 设置边框的颜色, 标准的 \LaTeX{} 描述方式
%   (\emph{默认: black})。
% \end{optlist}

\begin{SideBySideExample}
  \begin{Verbatim}[frame=single,
                   rulecolor=\color{red}]
    Verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

\begin{optlist}
  \item[fillcolor (color command)]: color used to fill the space
  between the frame and the text (its thickness is given by
  \texttt{framesep})
  (\emph{Default: none} \Dash no color).\\
  用于填充边框与文字之间空白部分的颜色
  （其厚度由 \texttt{framesep} 参数给定）
  （\emph{默认为无颜色}）。
\end{optlist}

% \begin{optlist}
%   \item[fillcolor (color command)]: 设置抄录文本与边线之间空白的颜色 (宽度为前面介绍的
%   \texttt{framesep}的值)
%   (\emph{默认: none} \Dash no color).
% \end{optlist}

\begin{SideBySideExample}
  \begin{Verbatim}[frame=single,
         framerule=1mm,framesep=3mm,
         rulecolor=\color{red},
         fillcolor=\color{yellow}]
    Verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

\subsubsection{Label for the environment\\环境标签}

% \subsubsection{Label for the环境}

\begingroup
\newcommand\Vitem{\SaveVerb[aftersave={\item[\UseVerb{Vitem}]}]{Vitem}}
\DefineShortVerb{\|}

\begin{optlist}
\Vitem|label ({[string]string})|: label(s) to print on top, bottom or
both frame lines of the environment to describe it content
(\emph{Default: empty} \Dash no label). 
If the label(s) contains special characters, as a comma or an equal sign,
it must be put inside a group. If only one string is given, it will be
used for both top and bottom lines (if the two are printed), but if an
optional first label is given too, this one will be used for the top line 
and the second  one for the bottom line. Note also that, if another value
than \textsf{topline}, \textsf{bottomline}, \textsf{lines} or
\textsf{single} is used for the \textsf{frame} parameter, the label(s)
will not be printed.

用于描述环境内容的标签，可打印在环境顶部、底部或两者边框线上
（\emph{默认为空}）。如果标签中包含逗号或等号等特殊字符，必须将其放在一组中。如果只给出一个字符串，则将用于顶部和底部行（如果两者都打印），但如果也给出可选的第一个标签，则将用于顶部行，第二个标签将用于底部行。请注意，如果 \textsf{frame} 参数使用的值不是 \textsf{topline}、\textsf{bottomline}、\textsf{lines} 或 \textsf{single}，则标签将不会被打印。
\end{optlist}

% \begin{optlist}
%   \Vitem|label ({[string]string})|: 指定顶部的标签、底部的标签，或同时指定顶部和底部的标签，用于描述抄录的内容
%   (\emph{默认: empty} \Dash no label)。
%   如果标签文字包含特殊字符, 比如逗号、等号,
%   那就必须放到组里%(\verb|label={含特殊字符的标签}|)
%   。
%   如果只指定了一个标签字符串, 各种情况下使用的标签内容是一致的。
%   但如果可选的标签也给出了（2个标签字符串）, 可选的标签文字会用到顶部，第二个用到底部。 
%   要注意的是，如果frame参数使用了topline、bottomline、lines或single以外的其他值，则不会打印标签。
% %  Note also that, if another value
% %  than \textsf{topline}, \textsf{bottomline}, \textsf{lines} or
% %  \textsf{single} is used for the \textsf{frame} parameter, the label(s)
% %  will not be printed.
% \end{optlist}
\endgroup

%  Problem at the top of a page...

\begin{SideBySideExample}
  \fvset{gobble=2}
  \begin{Verbatim}[frame=single,
                   label=My text]
    First verbatim line.
    Second verbatim line.
  \end{Verbatim}

  \begin{Verbatim}[frame=topline,
      framesep=4mm,
      label=\fbox{\Large\emph{The code}}]
    First verbatim line.
    Second verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

\begin{optlist}
  \item[labelposition (none$\mid$topline$\mid$bottomline$\mid$all)]:
  position where to print the label if one is defined, which must be
  coherent with the kind of frame chosen
  (\emph{Default: none if the label is empty, topline if one label is
  defined and all if two are defined}).
  Of course, some incompatible options (like
  \textsf{frame=topline,labelposition=bottomline}) will not print the
  label.

  如果定义了标签，则指定在哪个位置打印标签，位置必须与所选的边框类型一致
（\emph{默认值：如果标签为空，则不打印标签；如果定义了一个标签，则为topline；如果定义了两个标签，则为all}）。
当然，一些不兼容的选项（如\textsf{frame=topline,labelposition=bottomline}）将不会打印标签。
\end{optlist}

% \begin{optlist}
%   \item[labelposition (none$\mid$topline$\mid$bottomline$\mid$all)]:
%   设置标签的位置，如果设置了标签文字的话，which must be
%   coherent with the kind of frame chosen
%   (\emph{默认: none if the label is empty, topline if one label is
%   defined and all if two are defined}).
%   当然, 如果配置成冲突的了 (比如
%   \textsf{frame=topline,labelposition=bottomline}) 将不显示标签.
% \end{optlist}

%  Problem at the top of a page...

\begin{SideBySideExample}
  \fvset{gobble=2}
  \begin{Verbatim}[frame=single,
         framesep=2mm,
         label=Text,labelposition=all]
    frame=single,
    label=Text,
    labelposition=all
  \end{Verbatim}
\end{SideBySideExample}

\begin{SideBySideExample}
  \fvset{gobble=2}
  \begin{Verbatim}[frame=lines,
         label=Text,labelposition=topline]
    First verbatim line.
    Second verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

\begin{SideBySideExample}
  \begin{Verbatim}[frame=bottomline,
         framesep=3mm,
         label=\textit{Code included},
         labelposition=bottomline]
    First verbatim line.
    Second verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

\begin{SideBySideExample}
  \begin{Verbatim}[frame=lines,
                   framesep=3mm,
   label={[Beginning of code]End of code}]
    First verbatim line.
    Second verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

\subsubsection{Line numbering\\行号}

% \subsubsection{}

\begin{optlist}
  \item[numbers (none$\mid$left$\mid$right)]: numbering of the verbatim lines
  (\emph{Default: none} \Dash no numbering). If requested, this numbering is
  done \emph{outside} the verbatim environment.

对verbatim行进行编号
(\emph{默认值: none} \Dash 不编号)。如果需要编号，则行号会显示在verbatim环境的\emph{外部}。
\end{optlist}

% \begin{optlist}
%   \item[numbers (none$\mid$left$\mid$right)]: 抄录的文本行的行号
%   (\emph{默认: none} \Dash no numbering). 如果启用, 行号放在抄录环境的边框之\emph{外}。
% \end{optlist}

\begin{SideBySideExample}
  \begin{Verbatim}[gobble=2,numbers=left]
    左:numbers=left
  \end{Verbatim}
\end{SideBySideExample}

\begin{SideBySideExample}
  \begin{Verbatim}[gobble=2,
         numbers=right,numbersep=0pt]
    右:numbers=right
  \end{Verbatim}
\end{SideBySideExample}

\begin{optlist}
  \item[numbersep (dimension)]: gap between numbers and verbatim lines
  (\emph{Default: 12pt}).

  行号和verbatim行之间的间距
(\emph{默认值: 12pt})。
\end{optlist}

% \begin{optlist}
%   \item[numbersep (dimension)]: 行号和{\verbatimTxt}文本行间的距离
%   (\emph{默认: 12pt}).
% \end{optlist}

\begin{SideBySideExample}
  \begin{Verbatim}[gobble=2,
         numbers=left,numbersep=2pt]
    First verbatim line.
    Second verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

\begin{optlist}
  \item[firstnumber (auto$\mid$last$\mid$integer)]: number of the first line
  (\emph{Default: auto} \Dash numbering starts from 1). \textsf{last} means
  that the numbering is continued from the previous verbatim environment. If
  an integer is given, its value will be used to start the numbering.

第一行的编号
(\emph{默认值: auto} \Dash 编号从1开始)。\textsf{last}表示行号从前一个verbatim环境继续编号。如果给出一个整数，其值将用于开始编号。
\end{optlist}


% \begin{optlist}
%   \item[firstnumber (auto$\mid$last$\mid$数字)]: 指定行号的起始数字
%   (\emph{默认: auto} \Dash 从1开始). \textsf{last} 指定行号续着上一个
%   {\verbatimTxt}环境的行号。 如果指定的是一个数字, 行号就从这个数字开始增加。
% \end{optlist}

\begin{SideBySideExample}
  \fvset{gobble=2,
         numbers=left,numbersep=3pt}
  \begin{Verbatim}
    Verbatim line.
  \end{Verbatim}

  \begin{Verbatim}[firstnumber=last]
    Verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

\begin{SideBySideExample}
  \fvset{gobble=2,
         numbers=left,numbersep=3pt}
  \begin{Verbatim}[firstnumber=100]
    Verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

\begin{optlist}
  \item[stepnumber (integer)]: interval at which line numbers are printed
  (\emph{Default:~1} \Dash all lines are numbered).

打印行号的间隔
(\emph{默认值:~1} \Dash 所有行都编号)。
\end{optlist}

% \begin{optlist}
%   \item[stepnumber (数字)]: 每多少行显示行号
%   (\emph{默认:~1} \Dash 在设置了行号的情况下，所有行的行号都会显示出来)。
% \end{optlist}

\begin{SideBySideExample}
  \begin{Verbatim}[gobble=2,numbers=left,
         numbersep=3pt,stepnumber=2]
    First verbatim line.
    Second verbatim line.
    Third verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

The macro \cs{theFancyVerbLine} defines the typesetting style of the
numbering, and the counter used is \texttt{FancyVerbLine}:

\cs{theFancyVerbLine}命令定义了行号的排版格式,
行号使用的计数器的名称是 \texttt{FancyVerbLine}:

\begin{SideBySideExample}
  \renewcommand{\theFancyVerbLine}{%
    \textcolor{red}{\small
      8.\alph{FancyVerbLine}}}
  \begin{Verbatim}[gobble=2,
         numbers=left,numbersep=2pt]
    First verbatim line.
    Second verbatim line.
    Third verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

\ifChangeBar\begin{changebar}\fi

\begin{optlist}
\item[numberblanklines (boolean)]: to number or not the empty lines
(really empty or containing blank characters only)
(\emph{Default: true} \Dash all lines are numbered).

对空行（真正为空或仅包含空白字符的行）进行编号或不进行编号（\emph{默认值：true} \Dash 所有行都进行编号）。
\end{optlist}

% \begin{optlist}
%   \item[numberblanklines (boolean)]: 是否对空行编号
%   (全空的行，或只包含空白字符的行)
%   (\emph{默认: true} \Dash 所有行都会被编号).
% \end{optlist}

\begin{SideBySideExample}
  \begin{Verbatim}[gobble=2,numbers=left,
         numbersep=3pt,
         numberblanklines=false]
    First verbatim line.


    Second verbatim line.
  \end{Verbatim}
\end{SideBySideExample}
\ifChangeBar\end{changebar}\fi
%
\subsubsection{Selection of lines to print\\选择要打印的行}
% \subsubsection{选择要排版的起始行和终止的行}

\begin{optlist}
  \item[firstline (integer)]: first line to print
  (\emph{Default: empty} \Dash all lines from the first are printed).
\\要打印的第一行（\emph{默认值：empty} \Dash 从第一行开始打印所有行）。
  \item[lastline (integer)]: last line to print
  (\emph{Default: empty} \Dash all lines until the last one are printed).
\\  要打印的最后一行
（默认：空）\Dash 打印直到最后一行的所有行。
\end{optlist}

% \begin{optlist}
%   \item[firstline (integer)]: 要排版的起始行号
%   (\emph{默认: empty} \Dash 从第一行开始).
%   \item[lastline (integer)]: 要排版的终止行号
%   (\emph{默认: empty} \Dash 一直到最后一行).
% \end{optlist}


\begin{SideBySideExample}
  \begin{Verbatim}[gobble=2,
         firstline,lastline,
         numbers=left,numbersep=2pt]
    First verbatim line.
    Second verbatim line.
    Third verbatim line.
  \end{Verbatim}
\end{SideBySideExample}



\begin{SideBySideExample}
  \begin{Verbatim}[gobble=2,firstline=2,
         numbers=left,numbersep=2pt]
    First verbatim line.
    Second verbatim line.
    Third verbatim line.
  \end{Verbatim}
\end{SideBySideExample}


\begin{SideBySideExample}
  \begin{Verbatim}[gobble=2,lastline=1,
         numbers=left,numbersep=2pt]
    First verbatim line.
    Second verbatim line.
    Third verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

Instead of specifying a firstline at which to start printing a range
of lines, you can define a start string; the start of the range is
the first line that exactly equals the string.  (The comparison is made
before any characters are gobbled off the front of the line.) Similarly for a stop
string. You can mix line-numbers and strings, e.g.\ start at
firstline, and end at a stop string.  Specifying the strings is a
bit klunky.  Initially you must define the strings with
\cs{newcommand*} as in:

除了指定要开始打印一系列行的第一行，您可以定义一个起始字符串；范围的开始是恰好等于该字符串的第一行。（比较是在任何字符被吞掉之前进行的。）停止字符串也是同样的。您可以混合使用行号和字符串，例如从firstline开始，然后在stop字符串结束。指定字符串有点笨重。最初，您必须使用\cs{newcommand*}定义字符串，如下所示：

% 除了指定 firstline 参数来控制开始的行号范围, 你也可以指定一个{\em 开始字符串}; 开始的第一行就是第一个完全匹配这个字符串的那一行.  (当指定了忽略的起始字符数时，是会有区别的) {\em 结束字符串}也是类似的. 
% 你可以混合使用指定行号和指定字符串这两种方式, e.g.\ 用 firstline 指定开始的行号, 用 {\em 结束字符串} 来指定结束的位置。%
% 指定字符串有点笨拙%  Specifying the strings is a bit klunky
% 。首先你需要用以下的 \cs{newcommand*} 命令定义相应的字符串:

\begin{SideBySideExample}[gobble=2]
  \newcommand*\FancyVerbStartString{FROM}
  \newcommand*\FancyVerbStopString{TO}
  \begin{Verbatim}
    First verbatim line.
  FROM
    Second verbatim line.
  TO
    Third verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

\noindent To redefine the strings, you must use \cs{renewcommand*}.

\noindent 要重新定义字符串，必须使用\cs{renewcommand*}。
% \noindent 在重新定义{\em 开始字符串}、{\em 结束字符串}时，你要使用 \cs{renewcommand*} 命令重新定义。

With the setting \texttt{lastline=} or \texttt{lastline=0} nothing will be printed.

若设置了\texttt{lastline=}或\texttt{lastline=0}将不会打印任何内容。

\begin{SideBySideExample}[gobble=2]
  foo
  \begin{Verbatim}[frame=none,lastline=]
    First verbatim line.
    Second verbatim line.
    Third verbatim line.
  \end{Verbatim}
  bar
\end{SideBySideExample}

\subsubsection{Spaces and tab characters\\空格和制表符}
% \subsubsection{空格和 tab characters}

\begin{optlist}
  \item[showspaces (boolean)]: print a special character representing each
  space
  (\emph{Default: false} \Dash spaces not shown).
\\打印表示每个空格的特殊字符
（默认值：false）\Dash 不显示空格。
\end{optlist}

% \begin{optlist}
%   \item[showspaces (boolean)]: 是否将每个空格用可视的字符展示出来。
%   (\emph{默认: false}).
% \end{optlist}

\begin{SideBySideExample}[gobble=0]
\begin{Verbatim}[showspaces=true]
  Verbatim line.
\end{Verbatim}
\end{SideBySideExample}

  In practice, all verbatim environments have a~\texttt{*} variant, which
sets \texttt{showspaces=true}:

实际上，所有抄录环境都有一个\texttt{*}变体，它将\texttt{showspaces=true}设置为真：
  % In practice, 所有的 verbatim 环境有相应的带~\texttt{*} 变体, 设置了 \texttt{showspaces=true}:

\begin{SideBySideExample}[gobble=0]
  \begin{Verbatim*}
    Verbatim line.
  \end{Verbatim*}
\end{SideBySideExample}

  There are also some parameters to determine the way tab characters are
interpreted (using tabs is in fact a rather old-fashioned style of coding):

还有一些参数用于确定如何解释制表符（实际上，使用制表符是一种相当老式的编码样式）：
% 还有一些参数用来配置制表符的输出方式 (使用{\em 制表符}实际上是相当过时的编程风格了):
\begin{optlist}
  \item[showtabs (boolean)]: explicitly show tab characters
  (\emph{Default: false} \Dash tab characters not shown).
\\显式显示制表符
（默认值：false）\Dash 不显示制表符。
\end{optlist}


% \begin{optlist}
%   \item[showtabs (boolean)]: 显式显示制表符
%   (\emph{默认: false} \Dash 不显示制表符).
% \end{optlist}

\begin{optlist}
  \item[obeytabs (boolean)]: position characters according to the tabs
  (\emph{Default: false} \Dash tab characters are added to the current
  position).
\\根据制表符位置字符
（默认值：false）\Dash 制表符添加到当前位置。
\end{optlist}

% \begin{optlist}
%   \item[obeytabs (boolean)]: %是否将tabs仅作为tab而不转换为空格。
% 根据制表符定位字符
%   (\emph{默认: false} \Dash tab characters are added to the current position).
% \end{optlist}

\begin{optlist}
  \item[tabsize (integer)]: number of spaces given by a tab character
  (\emph{Default:~8}).
\\由制表符给出的空格数
（默认值：8）。
\end{optlist}

% \begin{optlist}
%   \item[tabsize (integer)]: 一个制表符对应的空格数
%   (\emph{默认:~8}).
% \end{optlist}


\subsubsection{Space between lines\\行之间的距离}
% \subsubsection{行间距}


\begin{optlist}
  \item[baselinestretch (auto$\mid$dimension)]: value to give to the usual
  `baselinestretch' \LaTeX{} parameter
  (\emph{Default: auto} \Dash its current value just before the verbatim
  command).
\\要给出的值通常为“baselinestretch”的\LaTeX{}参数
（默认值：auto）\Dash 它在抄录命令之前的当前值。
\end{optlist}

% \begin{optlist}
%   \item[baselinestretch (auto$\mid$dimension)]: 设置抄录环境中，\LaTeX{}的  `baselinestretch'  参数的值。
%   (\emph{默认: auto} \Dash 它在抄录命令之前的当前值).
% \end{optlist}

\begin{SideBySideExample}
  \begin{Verbatim}[baselinestretch=2]
    First verbatim line.
    Second verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

\subsubsection{Escape characters for inserting commands\\用于插入命令的转义字符}
% \subsubsection{用于插入命令的转义字符}


\begin{optlist}
  \item[commandchars (three characters)]: characters which define the
  character which starts a macro and marks the beginning and end of a group;
  thus lets us introduce \emph{escape} sequences in verbatim code. Of
  course, it is better to choose special characters which are not used in
  the verbatim text! (\emph{Default: empty}).
\\定义宏开始的字符以及组的开头和结尾的字符的字符；
因此，让我们在抄录代码中引入\emph{转义}序列。当然，最好选择在抄录文本中未使用的特殊字符！（默认值：empty）。
  \label{sec:commandchars}
\end{optlist}
% \begin{optlist}
%   \item[commandchars (指定三个字符)]: 指定开始命令的字符、命令参数的组的开始和结束符号\cprotect\marginpar{\small 译注：通常三个符号为\verb|\\\{\}|};
%   我们介绍下在抄录代码中使用 \emph{转义} 序列 . 
%   当然,最好是选择抄录文本中未出现的字符来使用! (\emph{默认: empty}).
%   \label{sec:commandchars}
% \end{optlist}

\begin{SideBySideExample}
  \begin{Verbatim}[commandchars=\\\{\}]
    \textit{This is a comment}
    First verbatim line.
    \fbox{Second} verbatim line.
    \textcolor{red}{Third} verbatim line.
  \end{Verbatim}

  \begin{Verbatim}[commandchars=+\[\]]
    +textit[\textbf{Verbatim} line].
  \end{Verbatim}
\end{SideBySideExample}

\ifChangeBar\begin{changebar}\fi

Using this way, it is also possible to put labels to be able, later, to
make reference to some lines of the verbatim environments:

使用这种方法，还可以放置标签，以便稍后参考抄录环境的某些行：
  % 这样，指定了commandchars后，就可以放置{\em 标签}了, \verb|\ref|{\em  引用}的时候，显示的是在{\verbatimTxt}环境中的{\em 行号}:

\begin{SideBySideExample}
  \begin{Verbatim}[commandchars=\\\{\},
         numbers=left,numbersep=2pt]
    First verbatim line.
    Second line.\label{vrb:Important}
    Third verbatim line.
  \end{Verbatim}

    As I previously shown
  line~\ref{vrb:Important}, it is...
\end{SideBySideExample}
\ifChangeBar\end{changebar}\fi

\subsubsection{Margins\\边距}


\begin{optlist}
  \item[xleftmargin (dimension)]: indentation to add at the start of each
  line
  (\emph{Default:~0pt} \Dash no left margin).
\\在每行开头添加的缩进量（\emph{默认值：0pt} \Dash 无左边距）。\footnote{译注：可以看到，是在边框的左边添加的！}
\end{optlist}
% \begin{optlist}
%   \item[xleftmargin (长度)]: 每行的开头添加的缩进
%   (\emph{默认:~0pt}).
% \end{optlist}

\begin{SideBySideExample}
  \begin{Verbatim}[frame=single]
    无左边距
  \end{Verbatim}
\end{SideBySideExample}

\begin{SideBySideExample}
  \begin{Verbatim}[frame=single,
                   xleftmargin=5mm]
    Verbatim line.
  \end{Verbatim}
\end{SideBySideExample}


\begin{optlist}
  \item[xrightmargin (dimension)]: right margin to add after each line
  (\emph{Default:~0pt} \Dash no right margin).
\\在每行后面添加的右边距（\emph{默认值：0pt} \Dash 无右边距）。
\end{optlist}
% \begin{optlist}
%   \item[xrightmargin (dimension)]: 在每行之后添加的右边距
%   (\emph{默认:~0pt} \Dash).
% \end{optlist}

\begin{SideBySideExample}
  \begin{Verbatim}[frame=single,
                   xrightmargin=1cm]
    Verbatim line.
  \end{Verbatim}
\end{SideBySideExample}

\begin{optlist}
  \item[resetmargins (boolean)]: reset the left margin, which is useful if
  we are inside other indented environments (\emph{Default: false} \Dash no
  reset of the margin).
\\重置左边距，这在我们{\bf 处于其他缩进环境中时非常有用}（\emph{默认值：false} \Dash 不重置边距）。
\end{optlist}
% \begin{optlist}
%   \item[resetmargins (boolean)]: 重置 left margin,   
%   当在其他的带有缩进的环境中时，这很有用(\emph{默认: false} \Dash no
%   reset of the margin).
% \end{optlist}

{%
\DefineVerbatimEnvironment{Verbatim}{Verbatim}{gobble=0,numbers=none}
\begin{SideBySideExample}
  \begin{itemize}
    \item First item
    \begin{Verbatim}[frame=single]
  Verbatim line.
    \end{Verbatim}
    \item Second item
    \begin{Verbatim}[frame=single,
                     resetmargins=true]
  Verbatim line.
    \end{Verbatim}
  \end{itemize}
\end{SideBySideExample}
}

\subsubsection{Overfull box messages\\过长的盒子消息}
% \subsubsection{溢出盒子信息}

\begin{optlist}
  \item[hfuzz (dimension)]: value to give to the \TeX{} \cs{hfuzz} dimension
  for text to format. This can be used to avoid seeing some unimportant
  \emph{Overfull box} messages (\emph{Default:~2pt}).
\\为要格式化的文本提供给 \TeX{} 的 \cs{hfuzz} 尺寸。这可用于避免看到一些不重要的\emph{过长的盒子}消息（\emph{默认值：2pt}）。
\end{optlist}
% \begin{optlist}
%   \item[hfuzz (dimension)]: value to give to the \TeX{} \cs{hfuzz} dimension
%   for text to format. 这可以避免显示一些不重要的
%   \emph{Overfull box} 信息 (\emph{默认:~2pt}).
% \end{optlist}

\subsubsection{Page breaks\\分页}
% \subsubsection{跨页}

\begin{optlist}
  \item[samepage (boolean)]: in very special circumstances, we may want to
  make sure that a verbatim environment is not broken, even if it does not
  fit on the current page. To avoid a page break, we can set the
  \texttt{samepage} parameter to \emph{true} (\emph{Default: false}).
\\在非常特殊的情况下，我们可能希望确保 verbatim 环境不会被打断，即使它不适合当前页面。为了避免分页，我们可以将 \texttt{samepage} 参数设置为 \emph{true}（\emph{默认值：false}）。
\end{optlist}
% \begin{optlist}
%   \item[samepage (boolean)]: 在非常特殊的情况下， 
%   我们希望，{\verbatimTxt}环境中的内容不要分到不同的页面, even if it does not fit on the current page. 要避免跨页, 可以将
%   \texttt{samepage} 设置为 \emph{true} (\emph{默认: false}).
% \end{optlist}

\subsubsection{Catcode characters\\Catcode 字符}


\begin{optlist}
  \item[codes (macro)]: to specify \emph{catcode} changes (\emph{Default:
  empty}).
\\用于指定\emph{catcode}更改（\emph{默认值：empty}）。
\end{optlist}
% \begin{optlist}
%   \item[codes (macro)]: 指定 \emph{catcode} 变更 (\emph{默认:
%   empty}).
% \end{optlist}

  For instance, this allows us to include formatted mathematics in verbatim
text:

% 例如，这允许我们在 verbatim 文本中包含格式化的数学公式：
例如，下面这样设置后，我们就可以在抄录文本中包含数学公式了:

{\fvset{fontsize=\small}
\begin{SideBySideExample}
  Z\fvset{fontsize=\normalsize}
  \begin{Verbatim}[commandchars=\\\{\},
         codes={\catcode`$=3\catcode`^=7}]
    x=1/sqrt(z**2) ! $\frac{1}{\sqrt{z^2}}$
  \end{Verbatim}
\end{SideBySideExample}
}  %$


\subsubsection{Active characters\\活动字符}


\begin{optlist}
  \item[defineactive (macro)]: to define the effect of \emph{active}
  characters
  (\emph{Default: empty}).
\\定义\emph{active}字符的效果（\emph{默认值：empty}）。
\end{optlist}

% \begin{optlist}
%   \item[defineactive (macro)]: to define the effect of \emph{active}
%   characters
%   (\emph{默认: empty}).
% \end{optlist}

  This allows us to do some devious tricks: see the example in Section
\ref{sec:VerbatimInclude} on page~\pageref{sec:VerbatimInclude}.

这允许我们进行一些诡计：请参见第 \ref{sec:VerbatimInclude} 节中页面 \pageref{sec:VerbatimInclude} 的示例。


\subsubsection{Reference label\\参考标签}
% \subsubsection{引用标签}

\begin{optlist}
  \item[reflabel (<label>)]: A  label for use of \verb|\pageref|.
\\用于 \verb|\pageref| 的标签。
\end{optlist}
% \begin{optlist}
%   \item[reflabel (<标签>)]:设置标签，以便 \verb|\pageref| 引用命令显示页数。
% \end{optlist}

\begin{SideBySideExample}
  \begin{Verbatim}[reflabel=verb0]
    First verbatim line.
    Second verbatim line.
  \end{Verbatim}
  See the verbatim on 
  page~\pageref{verb0}.
\end{SideBySideExample}



\subsection{Different kinds of verbatim environments\\不同类型的verbatim环境}
% \subsection{不同类型的{\verbatimTxt}环境}

\subsubsection{Verbatim environment\\Verbatim 环境}


This is the `normal' verbatim environment which we have been using up to
now.

这是我们迄今为止一直使用的“正常”的verbatim环境。
  % 这是我们上面已经用过的`normal' {\verbatimTxt}环境.

\subsubsection{BVerbatim environment\\BVerbatim 环境}
% \subsubsection{BVerbatim 环境}


This environment puts the verbatim material in a \TeX{} box. Some
parameters do not work inside this environment (notably the framing ones),
but two new ones are available:

这个环境将verbatim材料放在一个 \TeX{} 盒子中。一些参数在这个环境内不起作用（尤其是边框参数），但是有两个新的参数可用：
%   这个环境将{\verbatimTxt}内容放到一个 \TeX{} 盒子中。 有些前面介绍过的参数在这个环境是不存在的 (尤其是和边框相关的参数),
% 不过，也有两个新的参数可用于配置:

\begin{optlist}
  \item[boxwidth (auto$\mid$dimension)]: size of the box used
  (\emph{Default: auto} \Dash the width of the longest line is used).
\\盒子的尺寸（\emph{默认值：auto} \Dash 使用最长行的宽度）。
\end{optlist}
% \begin{optlist}
%   \item[boxwidth (auto$\mid$dimension)]: 使用的盒子的宽度
%   (\emph{默认: auto} \Dash the width of the longest line is used).
% \end{optlist}

\begin{optlist}
  \item[baseline (b$\mid$c$\mid$t)]: position of the baseline (on the
  \texttt{baseline}, the \texttt{center} or the \texttt{top} of the box)
  (\emph{Default: b}).
\\基线的位置（在盒子的\texttt{baseline}，\texttt{center}或\texttt{top}处）（\emph{默认值：b}）。
\end{optlist}
% \begin{optlist}
%   \item[baseline (b$\mid$c$\mid$t)]: 对齐用的基线位置
%    (on the
%   \texttt{baseline}, the \texttt{center} or the \texttt{top} of the box)
%   (\emph{默认: b}).
% \end{optlist}

\begin{SideBySideExample}
  \fvset{gobble=2}
  \begin{BVerbatim}
    First
    Second
  \end{BVerbatim}
  \begin{BVerbatim}[baseline=c]
    First
    Second
  \end{BVerbatim}
\end{SideBySideExample}

\begin{SideBySideExample}
  \begin{BVerbatim}[boxwidth=2cm]
    First
    Second
  \end{BVerbatim}
  \begin{BVerbatim}[boxwidth=2cm,
                    baseline=t]
    First
    Second
  \end{BVerbatim}
\end{SideBySideExample}

\subsubsection{LVerbatim environment\\LVerbatim 环境}


This environment puts verbatim material into \LaTeX{} `LR' mode (the
so-called \emph{left-to-right} mode, which in fact is the same thing that
\TeX{} itself calls \emph{restricted horizontal mode}).

这个环境将verbatim材料放入\LaTeX{}的“LR”模式（也称为\emph{从左到右}模式，实际上与\TeX{}本身称为\emph{受限水平模式}相同）。

%   这个环境将抄录内容放到\LaTeX{} 左右模式 (实际上这在
% \TeX{} 里也叫 \emph{受限水平模式}).


\subsubsection{Personalized environments\\个性化环境}
% \subsubsection{自定义{\verbatimTxt}环境}

\ifChangeBar\begin{changebar}\fi
\VerbatimFootnotes
  It is easy to define personal customized environments. You can redefine
the existing ones using the \cs{RecustomVerbatimEnvironment} macro or create
your own ones, using the \cs{DefineVerbatimEnvironment} macro\footnote{%
\ifChangeBar\begin{changebar}\fi
For verbatim commands, the \cs{CustomVerbatimCommand} and
\cs{RecustomVerbatimCommand} macros also exist; for instance:
\\\noindent
\verb+\RecustomVerbatimCommand{\VerbatimInput}{VerbatimInput}{frame=lines}+
\ifChangeBar\end{changebar}\fi}.

定义个人自定义环境很容易。您可以使用 \cs{RecustomVerbatimEnvironment} 宏重新定义现有的环境，也可以使用 \cs{DefineVerbatimEnvironment} 宏创建自己的环境\footnote{%
\ifChangeBar\begin{changebar}\fi
  对于抄录命令，还存在 \cs{CustomVerbatimCommand} 和 \cs{RecustomVerbatimCommand} 宏；例如：
\\\noindent
\verb+\RecustomVerbatimCommand{\VerbatimInput}{VerbatimInput}{frame=lines}+
\ifChangeBar\end{changebar}\fi}。


In each case, you specify the name of the new environment, the type of
environment on which it is based, and a set of initial option values. The
options can be overridden with an optional argument in the normal way:

在每种情况下，您都需要指定新环境的名称、基于的环境类型以及一组初始选项值。选项可以按照正常方式使用可选参数进行覆盖：
\ifChangeBar\end{changebar}\fi

% \begin{SideBySideExample}
%   \RecustomVerbatimEnvironment
%     {Verbatim}{Verbatim}
%     {gobble=2,frame=single}
%   \begin{Verbatim}
%     First verbatim line.
%     Second verbatim line.
%   \end{Verbatim}
% \end{SideBySideExample}
% \ifChangeBar\end{changebar}\fi

% \begin{SideBySideExample}
%   \DefineVerbatimEnvironment%
%     {MyVerbatim}{Verbatim}
%     {gobble=2,numbers=left,numbersep=2mm,
%      frame=lines,framerule=0.8mm}
%   \begin{MyVerbatim}
%     First verbatim line.
%     Second verbatim line.
%   \end{MyVerbatim}

%   \begin{MyVerbatim}[numbers=none,
%                      framerule=1pt]
%     First verbatim line.
%     Second verbatim line.
%   \end{MyVerbatim}
% \end{SideBySideExample}

\section{Saving and restoring verbatim text and environments
% \\保存和取用verbatim文本和环境
\\保存和恢复抄录文本和环境
}
% \section{保存和取用{\verbatimTxt}文本和环境}


The \cs{SaveVerb} and \cs{UseVerb} macros allow us to save and restore
verbatim material. \cs{UseVerb} itself is robust:

\cs{SaveVerb} 和 \cs{UseVerb} 宏使我们能够保存和恢复抄录材料。 \cs{UseVerb} 本身是健壮的：

% \cs{SaveVerb} 和 \cs{UseVerb} 宏允许我们保存和恢复原样材料。\cs{UseVerb} 本身是稳健的：

% \cs{SaveVerb} 和 \cs{UseVerb} 命令让我们可以保存和取用
% {\verbatimTxt}内容。 \cs{UseVerb}是robust的:

%  \DefineShortVerb{\|}
%  \SaveVerb{Verb}|_verbatim_|
\begin{SideBySideExample}
  \DefineShortVerb{\|}
  \SaveVerb{Verb}|_verbatim_|
  I have saved \UseVerb{Verb} and reuse 
  it later as many times as I want
  \subsection*{Using \UseVerb{Verb}}
  \UseVerb{Verb}.
\end{SideBySideExample}


This also provides a solution to putting verbatim text inside \LaTeX{}
commands which do not normally permit it: % (used package \texttt{marginnote}):

这也提供了一个解决方案，将抄录文本放置在通常不允许的 \LaTeX{} 命令内部：%(使用 \texttt{marginnote} 包)：

% 这也为，向那些通常不允许放置抄录命令的\LaTeX{}命令中放置抄录文本提供了一种方案: % (used package \texttt{marginnote}):

{\fvset{frame=single,xrightmargin=0cm}
\begin{Example}
  \DefineShortVerb{\|}\SaveVerb{Verb}|_OK^| \marginpar{\UseVerb{Verb}}
\end{Example}
}

There is a useful ability to use verbatim text as the item text in a
description list (something not normally permitted in \LaTeX), using the
\texttt{aftersave} parameter:

有一个有用的能力，使用抄录文本作为描述列表中的项目文本（在 \LaTeX{} 中通常不允许），使用 \texttt{aftersave} 参数：

% 有个很有用的情况是：在描述列表中，使用抄录文本作为条目文本
%  (\LaTeX 里，这通常是不允许放置抄录命令的), 使用
% \texttt{aftersave}参数:

\begin{optlist}
  \item[aftersave (macro)]: macro to dynamically save some verbatim material
  (\emph{Default: empty}).
\\动态保存一些抄录材料的宏（\emph{默认值：空}）。
\end{optlist}

% \begin{optlist}
%   \item[aftersave (macro)]: 用来动态保存一些抄录文本的命令
%   (\emph{默认: empty}).
% \end{optlist}

\begin{SideBySideExample}
  \newcommand{\Vitem}{%
    \SaveVerb[aftersave={%
      \item[\UseVerb{Vitem}]}]{Vitem}}
  \DefineShortVerb{\|}
  \begin{description}
    \Vitem|\MyCommand|: my command
  \end{description}
\end{SideBySideExample}

%todo 使用tcolorbox
\begin{quotation}
译者注：
\begin{description}
  \item[1] 保存 \verb|\MyCommand| 到 Vitem
  \item[2] 继续执行aftersave指定的 \verb|\item[\UseVerb{Vitem}]|， 以及后续的 \verb|: my command|
\end{description}
\end{quotation}

In the same way, we can use and restore (in normal, boxed and LR mode,
using \cs{UseVerbatim}, \cs{BUseVerbatim} and \cs{LUseVerbatim} respectively)
entire verbatim environments:

同样，我们可以使用和恢复整个抄录环境（在正常、盒子和 LR 模式中，分别使用 \cs{UseVerbatim}、\cs{BUseVerbatim} 和 \cs{LUseVerbatim}）：
%   同样的, 我们可以保存和取用(盒模式使用\cs{UseVerbatim}, \cs{BUseVerbatim}，\cs{LUseVerbatim}使用左右模式)
% 整个的抄录环境:

\begin{SideBySideExample}
  \fvset{gobble=0,numbers=none}
  \begin{SaveVerbatim}{抄录保存名}
    Verbatim line.
  \end{SaveVerbatim}
  \UseVerbatim{抄录保存名}
  and \UseVerbatim{抄录保存名}
\end{SideBySideExample}

\begin{SideBySideExample}
  \fvset{gobble=0,numbers=none}
  \begin{SaveVerbatim}[gobble=5]%
    {VerbEnv}
1234First
    Second
  \end{SaveVerbatim}

  \fbox{\BUseVerbatim{VerbEnv}}
  and \BUseVerbatim{VerbEnv}.

  \LUseVerbatim{VerbEnv} and
  \LUseVerbatim{VerbEnv}
\end{SideBySideExample}


\begin{SideBySideExample}
\begin{SaveVerbatim}{FOO}
然而,如果我使用
SaveVerbatim
定义了一个可复用的
Verbatim,
开启了行号。
\end{SaveVerbatim}

\begin{Verbatim}[numbers=left]
This works.
我直接使用
Verbatim环境.
\end{Verbatim}

\UseVerbatim[numbers=left]{FOO}
\end{SideBySideExample}


\clearpage

\section{Writing and reading verbatim files\\写入和读取抄录文件}
% \section{从文件读写抄录}
\label{sec:VerbatimInclude}


The command \cs{VerbatimInput} (the variants \cs{BVerbatimInput} and
\cs{LVerbatimInput} also exist) allows inclusion of the contents of a file
with verbatim formatting. Of course, the various parameters which we have
described for customizing can still be used:

命令 \cs{VerbatimInput}（也存在 \cs{BVerbatimInput} 和 \cs{LVerbatimInput} 变体）允许包含具有抄录格式的文件内容。当然，我们已经描述的各种自定义参数仍然可以使用：

%   \cs{VerbatimInput}命令 (变种 \cs{BVerbatimInput}、
% \cs{LVerbatimInput} 也) 让我们可以从文件中读取内容并以{\verbatimTxt}处理输出。当然, 我们前面介绍过的那些配置参数也还可以使用:

%The file we will use for \VerbatimInput

\typeout{*************************************}
\typeout{* Created files: hello.f90, file.txt}
\typeout{* See fancyhdr.dvi for an explanation}
\typeout{*************************************}

\begin{VerbatimOut}{hello.f90}
  ! A "hello" program

  program hello
    print *,"Hello world"
  end program hello
\end{VerbatimOut}

\begin{SideBySideExample}
  \RecustomVerbatimCommand{\VerbatimInput}
  {VerbatimInput}{gobble=4}
  \fvset{fontsize=\small}
  \VerbatimInput{hello.f90}

  \fvset{frame=single,numbers=left,
         numbersep=3pt}
  \VerbatimInput{hello.f90}

  \VerbatimInput[firstline=3,
      rulecolor=\color{green}]
    {hello.f90}

  \VerbatimInput[frame=lines,
      fontshape=sl,fontsize=\footnotesize]
    {hello.f90}
\end{SideBySideExample}

We can make use of the `defineactive' parameter to set the comment lines
in the program text in a different style:

我们可以利用“defineactive”参数来以不同的风格设置程序文本中的注释行：

% 我们可以用 `defineactive' 参数将程序文本中的注释行设置为不同的样式:

\begin{SideBySideExample}
  \RecustomVerbatimCommand{\VerbatimInput}
  {VerbatimInput}{gobble=4}
  \def\ExclamationPoint{\char33}
  \catcode`!=\active
  \VerbatimInput%
    [defineactive=%
      \def!{\color{cyan}\itshape
        \ExclamationPoint}]
    {hello.f90}
\end{SideBySideExample}

It is important to note that if the contents of the file does not fit on
the page, it will be automatically broken across pages as needed (unless the
\texttt{samepage} parameter has been set to \texttt{true}).

重要的是要注意，如果文件内容不适合页面，则将根据需要自动跨页面分割它（除非将 \texttt{samepage} 参数设置为 \texttt{true}）。
  % 要注意的是，如果文件内容在当前面放不下了, 它将根据需要，自动分解跨页 (除非 \texttt{samepage} 参数被设置为 \texttt{true} 了).

There is also a \verb+VerbatimOut+ environment to write verbatim text to an
output file, in the same way:

还有一个 \verb+VerbatimOut+ 环境，以相同的方式将抄录文本写入输出文件：

  % 类似的，\verb+VerbatimOut+ 环境则用用来将{\verbatimTxt}内容写入到外部的文件中, in the same way:

\begin{SideBySideExample}
  \begin{VerbatimOut}{file.txt}
    I write that.
    And that too.
  \end{VerbatimOut}

  \VerbatimInput[frame=single,
    numbers=left,numbersep=6pt]{file.txt}
\end{SideBySideExample}

\ifChangeBar\begin{changebar}\fi

\section{Automatic pretty printing\\自动输出美化的代码}
% \section{自动高亮排版}

Obviously, automatic \emph{pretty printing} is outside the scope of this
package. Nevertheless, this is specially interesting for verbatim
inclusion of programming code files or fragments. In the \LaTeX{} world
(not speaking of the \emph{literate programming} way), there are software
for some special languages, as the `\textsf{C++2LaTeX}' package from Norbert
\textsc{Kiesel}, but mainly two generic ones, which use completely different 
modes (an external preprocessor written in C and a \TeX{} based solution):
the `\textsf{LGrind}'~\cite{LGrind} system, currently maintened by Michael
\textsc{Piefel}, and the `\textsf{listings}'~\cite{Listings} package from
Carsten \textsc{Heinz}.

很明显，自动美化是本套件的范畴之外。然而，这对于编程代码文件或片段的逐字包含是特别有趣的。在 \LaTeX{} 世界中（不谈 \emph{文学编程} 方式），有一些针对特定语言的软件，例如来自 Norbert \textsc{Kiesel} 的 \textsf{C++2LaTeX}' 套件，但主要有两个通用的，使用完全不同的模式（一个基于 C 语言编写的外部预处理器和一个基于 \TeX{} 的解决方案）：\textsf{LGrind}'\cite{LGrind} 系统，目前由 Michael \textsc{Piefel} 维护，以及来自 Carsten \textsc{Heinz} 的 `\textsf{listings}'\cite{Listings} 套件。


Future versions of \FVrbPackage{} and `\textsf{listings}' packages are
planned to cooperate, which will offer great advantages to both users of the
two actual packages, and will allow \FVrbPackage{} users to have automatic
pretty printing of programming codes.

\FVrbPackage{} 和 `\textsf{listings}' 套件的未来版本计划合作，这将为两个现有套件的用户带来巨大优势，并允许 \FVrbPackage{} 用户自动美化编程代码。



% 显然, 自动 \emph{高亮排版}不在此包的范围内。
% 尽管如此, this is specially interesting for verbatim
% inclusion of programming 代码文件或片段. 在\LaTeX{}世界
% (not speaking of the \emph{literate programming} way), there are software for some special languages, as the `\textsf{C++2LaTeX}' package from Norbert
% \textsc{Kiesel}, but mainly two generic ones, which use completely different 
% modes (an external preprocessor written in C and a \TeX{} based solution):
% the `\textsf{LGrind}'~\cite{LGrind} system, currently maintened by Michael
% \textsc{Piefel}, and the `\textsf{listings}'~\cite{Listings} package from
% Carsten \textsc{Heinz}.

%    \FVrbPackage{} 和 `\textsf{listings}' 包未来版本有计划进行合作, 
%    which will offer great advantages to both users of the
% two actual packages, and will 允许 \FVrbPackage{} 的用户拥有自动漂亮排版编程语言代码。

\section{Known problems\\已知问题}
% \section{已知的问题}
  
\begin{itemize}
  \item Vladimir \textsc{Volovich} \verb+<vvv@vvv.vsu.ru>+ reported that the
  special character \verb+\th+, available with T1 encoding, can't be
  included as verbatim with \FVrbPackage. It can be true for other special
  characters too.
\\Vladimir \textsc{Volovich} \verb+vvv@vvv.vsu.ru+ 报告称，在 T1 编码下可用的特殊字符 \verb+\th+ 无法作为逐字文字与 \FVrbPackage{} 一起使用。这可能也适用于其他特殊字符。
\end{itemize}  
  
% \begin{itemize}
%   \item Vladimir \textsc{Volovich} \verb+<vvv@vvv.vsu.ru>+ 有上报提到 the
%   special character \verb+\th+, 在 T1 编码是可用的, 但在 \FVrbPackage 宏包的作为抄录内容时却不可用。It can be true for other special
%   characters too.
% \end{itemize}

\iffalse

\section{Thanks\\致谢}

For interesting comments and suggestions, we would like to thank specially
(alphabetic order): Philippe \textsc{Esperet}
\url{esperet@marie.polytechnique.fr}, Michael \textsc{Friendly}
\url{friendly@hotspur.psych.yorku.ca}, Rolf \textsc{Niepraschk}
\url{niepraschk@gmx.de} and for bug reports Mario \textsc{Hassler}
\relax\unskip\break
\url{HASSLER@ippnv2.ipp.kfa-juelich.de}, Mikhail \textsc{Kolodin}
\relax\unskip\break
\url{myke@morrigan.spb.su}, Andreas Matthias, Ulrich M. Schwarz, and Vladimir \textsc{Volovich}
\verb+<vvv@vvv.vsu.ru>+.

我们要特别感谢 Philippe \textsc{Esperet} \url{esperet@marie.polytechnique.fr}、Michael \textsc{Friendly} \url{friendly@hotspur.psych.yorku.ca}、Rolf \textsc{Niepraschk} \url{niepraschk@gmx.de} 等人对此的有趣评论和建议，以及对错误报告的 Mario \textsc{Hassler} \relax\unskip\break
\url{HASSLER@ippnv2.ipp.kfa-juelich.de}、Mikhail \textsc{Kolodin} \relax\unskip\break
\url{myke@morrigan.spb.su}、Andreas Matthias、Ulrich M. Schwarz 和 Vladimir \textsc{Volovich} \verb+vvv@vvv.vsu.ru+。

\fi

\section{Conclusion\\小结}

There are a few other possibilities that we have not described here.
Note specially that it is possible to define a customization file
(\texttt{fancyvrb.cfg}) loaded at the end of the package, to store
definitions of your customized commands and environments and to redefine
the attributes of existing ones.

  There are a few other possibilities that 我们在这没介绍到.
  特别注意，我们可以定义一些自定义的内容到
(\texttt{fancyvrb.cfg})文件，宏包会在最后时加载这个文件（如果有）, 
保存你自定义的命令和环境以及重定义一些已有的属性。


\clearpage

\part{Package \texttt{fancyvrb-ex}}
This package defines some example environments which can write input code
and output side by side or on top of each other. They are all used for this documentation of \texttt{fancyvrb}.


\part{\texttt{fancyvrb-ex}包}
这个宏包定义了一些 example 环境，可以将源码和排版效果并排或上下输出。它们在这个\texttt{fancyvrb}文档中也被运用到。

\section{\texttt{Example} environment}

\section{\texttt{Example}环境}

\begin{Verbatim}[gobble=2]
  \begin{Example}
    First verbatim line.
    Second verbatim line.
    Third verbatim line.
  \end{Example}
\end{Verbatim}

\begin{Example}
  First verbatim line.
  Second verbatim line.
  Third verbatim line.
\end{Example}

\begin{Verbatim}[gobble=2]
  \begin{Example}[frame=lines,framerule=1mm,
          numbers=left]
    First verbatim line.
    Second verbatim line.
    Third verbatim line.
  \end{Example}
\end{Verbatim}

\begin{Example}[frame=lines,framerule=1mm,numbers=left]
  First verbatim line.
  Second verbatim line.
  Third verbatim line.
\end{Example}

\newpage

\section{\texttt{CenterExample} environment}
\section{\texttt{CenterExample}环境}

\begin{Verbatim}[gobble=2]
  \begin{CenterExample}[frame=single,
       numbers=right]
    First verbatim line.
    Second verbatim line.
    居中示例
  \end{CenterExample}
\end{Verbatim}

\begin{CenterExample}[frame=single,numbers=right]
  First verbatim line.
  Second verbatim line.
  居中示例
\end{CenterExample}


\section{\texttt{SideBySideExample} environment}
\section{\texttt{SideBySideExample}环境}

\begin{Verbatim}[gobble=2]
  \begin{SideBySideExample}[
      xrightmargin=5cm,
      frame=lines, numbers=left]
    First verbatim line.
    Second verbatim line.
    Third verbatim line.
    并排示例
  \end{SideBySideExample}
\end{Verbatim}

\begin{SideBySideExample}[xrightmargin=5cm,frame=single,numbers=left]
  First verbatim line.
  Second verbatim line.
  并排示例
\end{SideBySideExample}



\iffalse


\section{\texttt{PCenterExample} environment}
\section{\texttt{PCenterExample}环境}

\begin{Verbatim}
  \fvset{frame=lines,framerule=0.5mm,numbers=left}

  \begin{PCenterExample}(-0.5,-0.5)(0.5,0.5)
    \setlength{\unitlength}{1cm}
    \put(0,0){\circle{1}}
  \end{PCenterExample}

  \showgrid
  \begin{PCenterExample}(-1,-1)(1,1)
    \setlength{\unitlength}{1cm}
    \put(0,0){\circle{1}}
  \end{PCenterExample}
\end{Verbatim}

{\fvset{frame=lines,framerule=0.5mm,numbers=left}
\begin{PCenterExample}(-0.5,-0.5)(0.5,0.5)
  \setlength{\unitlength}{1cm}
  \put(0,0){\circle{1}}
\end{PCenterExample}
\showgrid
\begin{PCenterExample}(-1,-1)(1,1)
   \setlength{\unitlength}{1cm}
   \put(0,0){\circle{1}}
\end{PCenterExample}
}

\section{\texttt{PSideBySideExample} environment}
\section{\texttt{PSideBySideExample}环境}

\begin{Verbatim}[gobble=2]
  \fvset{frame=single,xrightmargin=5cm}
  \begin{PSideBySideExample}(-2,-1)(2,1)
    \psellipse*[linecolor=yellow](2,1)
  \end{PSideBySideExample}
  \showgrid
  \begin{PSideBySideExample}(-2,-1)(2,1)
    \psellipse[linestyle=dashed](2,1)
  \end{PSideBySideExample}
\end{Verbatim}

{\fvset{frame=single,xrightmargin=5cm}
\begin{PSideBySideExample}(-2,-1)(2,1)
  \psellipse*[linecolor=yellow](2,1)
\end{PSideBySideExample}

\showgrid
\begin{PSideBySideExample}(-2,-1)(2,1)
  \psellipse[linestyle=dashed](2,1)
\end{PSideBySideExample}
}

\begin{Verbatim}[gobble=2]
  \fvset{frame=single,xrightmargin=5cm}
  \begin{PSideBySideExample}(-2,-1)(2,1)
    \psellipse[linestyle=dashed](2,1)
  \end{PSideBySideExample}
  \begin{PSideBySideExample}[numbers=right](-2,-1)(2,1)
    \psellipse[linestyle=dotted](2,1)
  \end{PSideBySideExample}
\end{Verbatim}

{\fvset{frame=single,xrightmargin=5cm}
\begin{PSideBySideExample}(-2,-1)(2,1)
  \psellipse[linestyle=dashed](2,1)
\end{PSideBySideExample}

\begin{PSideBySideExample}[numbers=right](-2,-1)(2,1)
  \psellipse[linestyle=dotted](2,1)
\end{PSideBySideExample}
}


\fi




\begin{thebibliography}{1}
  \bibitem{FancyBox} Timothy \textsc{van Zandt},
  \textit{Documentation for `fancybox': Box tips and tricks for \LaTeX}.
  Available from \url{CTAN: macros/latex/contrib/supported/fancybox}, 1993.

  \bibitem{FancyVrb} Timothy \textsc{van Zandt},
  \textit{`fancyvrb': Fancy Verbatims in \LaTeX}.
  Available from \url{CTAN: macros/latex/contrib/supported/fancyvrb}, 1998.

  \bibitem{LGrind} Various authors (current maintainer: Michael
  \textsc{Piefel}),
  \textit{The `LGrind' package}.
  Available from \url{CTAN: support/lgrind}, 1998.

  \bibitem{Listings} Carsten \textsc{Heinz},
  \textit{The `Listings' package}.
  Available from \url{CTAN: macros/latex/contrib/supported/listings}, 1996-1997.
\end{thebibliography}








\end{document}
