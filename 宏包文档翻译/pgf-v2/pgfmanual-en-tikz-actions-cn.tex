\setcounter{section}{14}
\setcounter{subsection}{22}
\setcounter{subsubsection}{0} 
% Copyright 2019 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Free Documentation License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.


\section{Actions on Paths\\路径上的操作}

\subsection{Overview\\概述}

Once a path has been constructed, different things can be done with it. It can
be drawn (or stroked) with a ``pen'', it can be filled with a color or shading,
it can be used for clipping subsequent drawing, it can be used to specify the
extend of the picture -- or any combination of these actions at the same time.

一旦构建了路径，可以对其执行不同的操作。可以使用“笔”来绘制（或描边）路径，可以使用颜色或渐变填充路径，可以将其用于剪切后续绘图，可以用它来指定图片的范围，或者同时进行这些操作的任意组合。

To decide what is to be done with a path, two methods can be used. First, you
can use a special-purpose command like |\draw| to indicate that the path should
be drawn. However, commands like |\draw| and |\fill| are just abbreviations for
special cases of the more general method: Here, the |\path| command is used to
specify the path. Then, options encountered on the path indicate what should be
done with the path.

为了决定如何处理路径，可以使用两种方法。首先，可以使用特定目的的命令，如 |\draw|，指示应该绘制路径。然而，像 |\draw| 和 |\fill| 这样的命令只是更通用方法的缩写：在这里，|\path| 命令用于指定路径。然后，在路径上遇到的选项指示应该对路径执行什么操作。

For example, |\path (0,0) circle (1cm);| means: ``This is a path consisting of
a circle around the origin. Do not do anything with it (throw it away).''
However, if the option |draw| is encountered anywhere on the path, the circle
will be drawn. ``Anywhere'' is any point on the path where an option can be
given, which is everywhere where a path command like |circle (1cm)| or
|rectangle (1,1)| or even just |(0,0)| would also be allowed. Thus, the
following commands all draw the same circle:

例如，|\path (0,0) circle (1cm);| 的意思是：“这是一个由原点周围的一个圆组成的路径。不要对它执行任何操作（丢弃它）。”然而，如果路径上的选项 |draw| 在任何地方被遇到，圆将被绘制出来。“任何地方”是指可以给出选项的路径上的任意一点，这个点可以是任何一个路径命令像 |circle (1cm)| 或 |rectangle (1,1)|，甚至只是一个 |(0,0)| 允许的地方。因此，以下命令都绘制相同的圆形：

%
\begin{codeexample}[code only]
\path [draw] (0,0) circle (1cm);
\path (0,0) [draw] circle (1cm);
\path (0,0) circle (1cm) [draw];
\end{codeexample}
%
Finally, |\draw (0,0) circle (1cm);| also draws a path, because |\draw| is an
abbreviation for |\path [draw]| and thus the command expands to the first line
of the above example.

最后，|\draw (0,0) circle (1cm);| 也会绘制一个路径，因为 |\draw| 是 |\path [draw]| 的缩写，因此该命令展开为上面示例的第一行。

Similarly, |\fill| is an abbreviation for |\path[fill]| and |\filldraw| is an
abbreviation for the command |\path[fill,draw]|. Since options accumulate, the
following commands all have the same effect:

类似地，|\fill| 是 |\path[fill]| 的缩写，|\filldraw| 是 |\path[fill,draw]| 的缩写。由于选项是累积的，以下命令都具有相同的效果：

%
\begin{codeexample}[code only]
\path [draw,fill]   (0,0) circle (1cm);
\path [draw] [fill] (0,0) circle (1cm);
\path [fill] (0,0) circle (1cm) [draw];
\draw [fill] (0,0) circle (1cm);
\fill (0,0) [draw] circle (1cm);
\filldraw (0,0) circle (1cm);
\end{codeexample}

In the following subsection the different actions that can be performed on a
path are explained. The following commands are abbreviations for certain sets
of actions, but for many useful combinations there are no abbreviations:

在下一小节中，将解释可以对路径执行的不同操作。以下命令是某些操作集的缩写，但对于许多有用的组合，没有缩写：

\begin{command}{\draw}
    Inside |{tikzpicture}| this is an abbreviation for |\path[draw]|.

    在 |{tikzpicture}| 环境中，这是 |\path[draw]| 的缩写。
\end{command}

\begin{command}{\fill}
    Inside |{tikzpicture}| this is an abbreviation for |\path[fill]|.

    在 |{tikzpicture}| 环境中，这是 |\path[fill]| 的缩写。
\end{command}

\begin{command}{\filldraw}
    Inside |{tikzpicture}| this is an abbreviation for |\path[fill,draw]|.

    在 |{tikzpicture}| 环境中，这是 |\path[fill,draw]| 的缩写。
\end{command}

\begin{command}{\pattern}
    Inside |{tikzpicture}| this is an abbreviation for |\path[pattern]|.

    在 |{tikzpicture}| 环境中，这是 |\path[pattern]| 的缩写。
\end{command}

\begin{command}{\shade}
    Inside |{tikzpicture}| this is an abbreviation for |\path[shade]|.

    在 |{tikzpicture}| 环境中，这是 |\path[shade]| 的缩写。
\end{command}

\begin{command}{\shadedraw}
 
    Inside |{tikzpicture}| this is an abbreviation for |\path[shade,draw]|.

    在 |{tikzpicture}| 环境中，这是 |\path[shade,draw]| 的缩写。
\end{command}

\begin{command}{\clip}
    Inside |{tikzpicture}| this is an abbreviation for |\path[clip]|.


    在 |{tikzpicture}| 环境中，这是 |\path[clip]| 的缩写。
\end{command}

\begin{command}{\useasboundingbox}
    Inside |{tikzpicture}| this is an abbreviation for |\path[use as bounding box]|.

    在 |{tikzpicture}| 环境中，这是 |\path[use as bounding box]| 的缩写。
\end{command}


\subsection{Specifying a Color\\指定颜色}

The most unspecific option for setting colors is the following:

用于设置颜色的最常见选项是以下内容：
%
\begin{key}{/tikz/color=\meta{color name}}
        \indexoption{color option}%
    This option sets the color that is used for fill, drawing, and text inside
    the current scope. Any special settings for filling colors or drawing
    colors are immediately ``overruled'' by this option.

    此选项设置用于当前作用域内的填充、描边和文本的颜色。填充颜色或描边颜色的特殊设置会立即被此选项“覆盖。


    The \meta{color name} is the name of a previously defined color. For
    \LaTeX\ users, this is just a normal ``\LaTeX-color'' and the |xcolor|
    extensions are allowed. Here is an example:

    \meta{颜色名称} 是先前定义的颜色的名称。对于 \LaTeX\ 用户，这只是一个普通的“\LaTeX-颜色”，允许使用 |xcolor| 扩展。以下是一个示例：

    %
\begin{codeexample}[]
\tikz \fill[color=red!20] (0,0) circle (1ex);
\end{codeexample}

    It is possible to ``leave out'' the |color=| part and you can also write:
    
    可以“省略”|color=|部分，也可以写成：
%
\begin{codeexample}[]
\tikz \fill[red!20] (0,0) circle (1ex);
\end{codeexample}
    %
    What happens is that every option that \tikzname\ does not know, like
    |red!20|, gets a ``second chance'' as a color name.

    发生的情况是，\tikzname\ 不认识的所有选项，如 |red!20|，会被“第二次机会”作为颜色名称。


    For plain \TeX\ users, it is not so easy to specify colors since plain
    \TeX\ has no ``standardized'' color naming mechanism. Because of this,
    \pgfname\ emulates the |xcolor| package, though the emulation is
    \emph{extremely basic} (more precisely, what I could hack together in two
    hours or so). The emulation allows you to do the following:
    
    对于 plain \TeX\ 用户来说，指定颜色并不那么容易，因为 plain \TeX\ 没有“标准化”的颜色命名机制。因此，\pgfname\ 模拟了 |xcolor| 宏包，尽管这个模拟是“极其基本的”（更准确地说，是我在两个小时左右的时间里能够拼凑出来的）。这个模拟允许你做以下操作：
%
    \begin{itemize}
        \item Specify a new color using |\definecolor|. Only the color models
            |gray|, |rgb|, and |RGB| are supported\footnote{Con\TeX t users
            should be aware that \texttt{\textbackslash definecolor} has a
            different meaning in Con\TeX t. There is a low-level equivalent
            named \texttt{\textbackslash pgfutil@definecolor} which can be
            used instead.}.

            使用 |\definecolor| 来指定新颜色。只支持 |gray|、|rgb| 和 |RGB| 颜色模型\footnote{Con\TeX t 用户应该注意，\texttt{\textbackslash definecolor} 在 Con\TeX t 中有不同的含义。这里有一个名为 \texttt{\textbackslash pgfutil@definecolor} 的底层等效命令可以替代。}。

            %
            \example |\definecolor{orange}{rgb}{1,0.5,0}|
        \item Use |\colorlet| to define a new color based on an old one.
            Here, the |!| mechanism is supported, though only ``once'' (use
            multiple |\colorlet| for more fancy colors).

            使用 |\colorlet| 根据旧颜色定义新颜色。在这里，|!| 机制是支持的，但只能“一次”使用（使用多个 |\colorlet| 可以得到更多的花哨颜色）。

            %
            \example |\colorlet{lightgray}{black!25}|
        \item Use |\color|\marg{color name} to set the color in the current
            \TeX\ group. |\aftergroup|-hackery is used to restore the color
            after the group.

            使用 |\color|\marg{颜色名称} 在当前 \TeX\ 组中设置颜色。使用 |\aftergroup| 技巧在组之后恢复颜色。
    \end{itemize}
\end{key}

As pointed out above, the |color=| option applies to ``everything'' (except to
shadings), which is not always what you want. Because of this, there are
several more specialized color options. For example, the |draw=| option sets
the color used for drawing, but does not modify the color used for filling.
These color options are documented where the path action they influence is
described.

如上所述，|color=| 选项适用于“所有内容”（除了着色），这并不总是你想要的。因此，还有一些更专门的颜色选项。例如，|draw=| 选项设置用于描边的颜色，但不修改用于填充的颜色。这些颜色选项在描述它们影响的路径操作时有详细说明。


\subsection{Drawing a Path\\绘制路径}

You can draw a path using the following option:

您可以使用以下选项绘制路径：
%
\begin{key}{/tikz/draw=\meta{color} (default \normalfont is scope's color setting)}
    Causes the path to be drawn. ``Drawing'' (also known as ``stroking'') can
    be thought of as picking up a pen and moving it along the path, thereby
    leaving ``ink'' on the canvas.

    使路径被绘制。``绘制''（也称为``描边''）可以理解为拿起一支笔并沿着路径移动，从而在画布上留下``墨迹''。

    There are numerous parameters that influence how a line is drawn, like the
    thickness or the dash pattern. These options are explained below.

    有许多参数会影响线条的绘制，例如线条的粗细或虚线模式。这些选项将在下面进行解释。


    If the optional \meta{color} argument is given, drawing is done using the
    given \meta{color}. This color can be different from the current filling
    color, which allows you to draw and fill a path with different colors. If
    no \meta{color} argument is given, the last usage of the |color=| option is
    used.
    
    如果给定了可选的 \meta{color} 参数，将使用给定的 \meta{color} 进行绘制。该颜色可以与当前填充颜色不同，这使您可以使用不同的颜色绘制和填充路径。如果没有给定 \meta{color} 参数，则使用 |color=| 选项的最后一次使用。

    If the special color name |none| is given, this option causes drawing to be
    ``switched off''. This is useful if a style has previously switched on
    drawing and you locally wish to undo this effect.

    如果给定了特殊颜色名称 |none|，此选项将导致绘图被 "关闭"。如果样式之前打开了绘图，并且您希望在局部上撤消此效果，这将非常有用。

    Although this option is normally used on paths to indicate that the path
    should be drawn, it also makes sense to use the option with a |{scope}| or
    |{tikzpicture}| environment. However, this will \emph{not} cause all paths
    to be drawn. Instead, this just sets the \meta{color} to be used for
    drawing paths inside the environment.

    尽管通常在路径上使用此选项表示应该绘制路径，但也可以在 |{scope}| 或 |{tikzpicture}| 环境中使用该选项是有意义的。但是，这不会导致绘制所有路径。相反，它只是设置用于绘制环境内部路径的 \meta{color}。

    %
\begin{codeexample}[]
\begin{tikzpicture}
  \path[draw=red] (0,0) -- (1,1) -- (2,1) circle (10pt);
\end{tikzpicture}
\end{codeexample}
    %
\end{key}

The following subsections list the different options that influence how a path
is drawn. All of these options only have an effect if the |draw| option is
given (directly or indirectly).

以下小节列出了影响路径绘制的不同选项。所有这些选项只有在给出 |draw| 选项（直接或间接）时才会生效。


\subsubsection{Graphic Parameters: Line Width, Line Cap, and Line Join\\图形参数：线宽、线帽和线接合}
\label{section-cap-joins}

\begin{key}{/tikz/line width=\meta{dimension} (initially 0.4pt)}
    Specifies the line width. Note the space.
    
    
    指定线宽。注意空格。
%
\begin{codeexample}[]
  \tikz \draw[line width=5pt] (0,0) -- (1cm,1.5ex);
\end{codeexample}
    %
\end{key}

There are a number of predefined styles that provide more ``natural'' ways of
setting the line width. You can also redefine these styles.

有一些预定义的样式提供了更 "自然" 的设置线宽的方式。您还可以重新定义这些样式。

\begin{stylekey}{/tikz/ultra thin}
    Sets the line width to 0.1pt.

    将线宽设置为0.1pt。

    %
\begin{codeexample}[]
  \tikz \draw[ultra thin] (0,0) -- (1cm,1.5ex);
\end{codeexample}
    %
\end{stylekey}

\begin{stylekey}{/tikz/very thin}
    Sets the line width to 0.2pt.

    将线宽设置为0.2pt。

    %
\begin{codeexample}[]
  \tikz \draw[very thin] (0,0) -- (1cm,1.5ex);
\end{codeexample}
    %
\end{stylekey}

\begin{stylekey}{/tikz/thin}
    Sets the line width to 0.4pt.

    将线宽设置为0.4pt。

    %
\begin{codeexample}[]
  \tikz \draw[thin] (0,0) -- (1cm,1.5ex);
\end{codeexample}
    %
\end{stylekey}

\begin{stylekey}{/tikz/semithick}
    Sets the line width to 0.6pt.

    将线宽设置为0.6pt。

    %
\begin{codeexample}[]
  \tikz \draw[semithick] (0,0) -- (1cm,1.5ex);
\end{codeexample}
    %
\end{stylekey}

\begin{stylekey}{/tikz/thick}
    Sets the line width to 0.8pt.

    将线宽设置为0.8pt。

    %
\begin{codeexample}[]
  \tikz \draw[thick] (0,0) -- (1cm,1.5ex);
\end{codeexample}
    %
\end{stylekey}

\begin{stylekey}{/tikz/very thick}
    Sets the line width to 1.2pt.

    将线宽设置为1.2pt。
    %
\begin{codeexample}[]
  \tikz \draw[very thick] (0,0) -- (1cm,1.5ex);
\end{codeexample}
    %
\end{stylekey}

\begin{stylekey}{/tikz/ultra thick}
    Sets the line width to 1.6pt.

    将线宽设置为1.6pt。
    %
\begin{codeexample}[]
  \tikz \draw[ultra thick] (0,0) -- (1cm,1.5ex);
\end{codeexample}
    %
\end{stylekey}

    \label{section-line-cap}
\begin{key}{/tikz/line cap=\meta{type} (initially butt)}
    Specifies how lines ``end''. Permissible \meta{type} are |round|, |rect|,
    and |butt|. They have the following effects:

    指定线条的 "末端"。允许的 \meta{type} 有 |round|、|rect| 和 |butt|。它们具有以下效果：
    %
\begin{codeexample}[]
\begin{tikzpicture}
  \begin{scope}[line width=10pt]
    \draw[line cap=round] (0,1 ) -- +(1,0);
    \draw[line cap=butt]  (0,.5) -- +(1,0);
    \draw[line cap=rect]  (0,0 ) -- +(1,0);
  \end{scope}
  \draw[white,line width=1pt]
    (0,0 ) -- +(1,0) (0,.5) -- +(1,0) (0,1 ) -- +(1,0);
\end{tikzpicture}
\end{codeexample}
    %
\end{key}

\begin{key}{/tikz/line join=\meta{type} (initially miter)}
    Specifies how lines ``join''. Permissible \meta{type} are |round|, |bevel|,
    and |miter|. They have the following effects:
    
    指定线条的 "连接"。允许的 \meta{type} 有 |round|、|bevel| 和 |miter|。它们具有以下效果：
%
\begin{codeexample}[]
\begin{tikzpicture}[line width=10pt]
  \draw[line join=round] (0,0) -- ++(.5,1) -- ++(.5,-1);
  \draw[line join=bevel] (1.25,0) -- ++(.5,1) -- ++(.5,-1);
  \draw[line join=miter] (2.5,0) -- ++(.5,1) -- ++(.5,-1);
  \useasboundingbox (0,1.5); % enlarge bounding box
\end{tikzpicture}
\end{codeexample}

    \begin{key}{/tikz/miter limit=\meta{factor} (initially 10)}
        When you use the miter join and there is a very sharp corner (a small
        angle), the miter join may protrude very far over the actual joining
        point. In this case, if it were to protrude by more than \meta{factor}
        times the line width, the miter join is replaced by a bevel join.
        
        当使用斜接连接时，如果有一个非常尖锐的角（一个小角度），斜接连接可能会在实际连接点之外突出得很远。在这种情况下，如果它突出超过线宽的 \meta{factor} 倍，则将斜接连接替换为斜角连接。
        %
\begin{codeexample}[]
\begin{tikzpicture}[line width=5pt]
  \draw                 (0,0) -- ++(5,.5) -- ++(-5,.5);
  \draw[miter limit=25] (6,0) -- ++(5,.5) -- ++(-5,.5);
  \useasboundingbox (14,0); % make bounding box bigger
\end{tikzpicture}
\end{codeexample}
    \end{key}
\end{key}


\subsubsection{Graphic Parameters: Dash Pattern\\图形参数：虚线模式}

\begin{key}{/tikz/dash pattern=\meta{dash pattern}}
    Sets the dashing pattern. The syntax is the same as in \textsc{metafont}.
    For example following pattern |on 2pt off 3pt on 4pt off 4pt| means ``draw
    2pt, then leave out 3pt, then draw 4pt once more, then leave out 4pt again,
    repeat''.
    
    设置虚线模式。语法与 \textsc{metafont} 相同。
例如，以下模式 |on 2pt off 3pt on 4pt off 4pt| 表示“画2pt，然后跳过3pt，再画4pt，再跳过4pt，重复”。
%
\begin{codeexample}[]
\begin{tikzpicture}[dash pattern=on 2pt off 3pt on 4pt off 4pt]
  \draw (0pt,0pt) -- (3.5cm,0pt);
\end{tikzpicture}
\end{codeexample}
    %
\end{key}

\begin{key}{/tikz/dash phase=\meta{dash phase} (initially 0pt)}
    Shifts the start of the dash pattern by \meta{phase}.
    
    通过 \meta{相位} 调整虚线模式的起始位置。
%
\begin{codeexample}[]
\begin{tikzpicture}[dash pattern=on 20pt off 10pt]
  \draw[dash phase=0pt] (0pt,3pt) -- (3.5cm,3pt);
  \draw[dash phase=10pt] (0pt,0pt) -- (3.5cm,0pt);
\end{tikzpicture}
\end{codeexample}
    %
\end{key}

\begin{key}{/tikz/dash=\meta{dash pattern}|phase|\meta{dash phase}}
    Sets the dashing pattern and phase at the same time.
    
    同时设置虚线模式和相位。
%
\begin{codeexample}[]
\begin{tikzpicture}
  \draw [dash=on 20pt off 10pt phase  0pt] (0pt,3pt) -- (3.5cm,3pt);
  \draw [dash=on 20pt off 10pt phase 10pt] (0pt,0pt) -- (3.5cm,0pt);
\end{tikzpicture}
\end{codeexample}
    %
\end{key}

\begin{key}{/tikz/dash expand off}
    Makes the |off| part of a dash pattern expandable such that it can stretch.
    This only works when there is a single |on| and a single |off| field and
    requires the |decorations| library. Right now this option has to be
    specified on the path where it is supposed to take effect after the
    |dash pattern| option because the dash pattern has to be known at the point
    where it is applied.
    
    使虚线模式中的 |off| 部分可伸缩，以便可以拉伸。这仅适用于只有一个 |on| 和一个 |off| 字段且需要使用 |decorations| 库的情况。
目前，此选项必须在应用时的路径上指定，以便在应用时知道虚线模式。
%
\begin{codeexample}[preamble={\usetikzlibrary{decorations}}]
\begin{tikzpicture}[|-|, dash pattern=on 4pt off 2pt]
  \draw [dash expand off] (0pt,30pt) -- (26pt,30pt);
  \draw [dash expand off] (0pt,20pt) -- (24pt,20pt);
  \draw [dash expand off] (0pt,10pt) -- (22pt,10pt);
  \draw [dash expand off] (0pt, 0pt) -- (20pt, 0pt);
\end{tikzpicture}
\end{codeexample}
    %
\end{key}

As for the line thickness, some predefined styles allow you to set the dashing
conveniently.

至于线条粗细，一些预定义的样式可以方便地设置虚线模式。

\begin{stylekey}{/tikz/solid}
    Shorthand for setting a solid line as ``dash pattern''. This is the default.
    
    设置实线作为“虚线模式”的缩写。这是默认设置。
%
\begin{codeexample}[]
\tikz \draw[solid] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
    %
\end{stylekey}

\begin{stylekey}{/tikz/dotted}
    Shorthand for setting a dotted dash pattern.
    
    设置点线作为“虚线模式”的缩写。
%
\begin{codeexample}[]
\tikz \draw[dotted] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
    %
\end{stylekey}

\begin{stylekey}{/tikz/densely dotted}
    Shorthand for setting a densely dotted dash pattern.
    
    设置密集点线作为“虚线模式”的缩写。
%
\begin{codeexample}[]
\tikz \draw[densely dotted] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
    %
\end{stylekey}

\begin{stylekey}{/tikz/loosely dotted}
    Shorthand for setting a loosely dotted dash pattern.
    
    设置疏松点线作为“虚线模式”的缩写。
%
\begin{codeexample}[]
\tikz \draw[loosely dotted] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
    %
\end{stylekey}

\begin{stylekey}{/tikz/dashed}
    Shorthand for setting a dashed dash pattern.
    
    设置虚线作为“虚线模式”的缩写。
%
\begin{codeexample}[]
\tikz \draw[dashed] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
    %
\end{stylekey}

\begin{stylekey}{/tikz/densely dashed}
    Shorthand for setting a densely dashed dash pattern.
    
    设置密集虚线作为“虚线模式”的缩写。
%
\begin{codeexample}[]
\tikz \draw[densely dashed] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
    %
\end{stylekey}

\begin{stylekey}{/tikz/loosely dashed}
    Shorthand for setting a loosely dashed dash pattern.
    
    设置疏松虚线作为“虚线模式”的缩写。
%
\begin{codeexample}[]
\tikz \draw[loosely dashed] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
    %
\end{stylekey}

\begin{stylekey}{/tikz/dash dot}
    Shorthand for setting a dashed and dotted dash pattern.
    
    设置虚线和点线作为“虚线模式”的缩写。
%
\begin{codeexample}[]
\tikz \draw[dash dot] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
    %
\end{stylekey}

\begin{stylekey}{/tikz/densely dash dot}
    Shorthand for setting a densely dashed and dotted dash pattern.
    
    设置密集虚线和点线作为“虚线模式”的缩写。
%
\begin{codeexample}[]
\tikz \draw[densely dash dot] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
    %
\end{stylekey}

\begin{stylekey}{/tikz/loosely dash dot}
    Shorthand for setting a loosely dashed and dotted dash pattern.
    
    设置疏松虚线和点线作为“虚线模式”的缩写。
%
\begin{codeexample}[]
\tikz \draw[loosely dash dot] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
    %
\end{stylekey}

\begin{stylekey}{/tikz/dash dot dot}
    Shorthand for setting a dashed and dotted dash pattern with more dots.
    
    设置更多点的虚线和点线作为“虚线模式”的缩写。
%
\begin{codeexample}[]
\tikz \draw[dash dot dot] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
    %
\end{stylekey}

\begin{stylekey}{/tikz/densely dash dot dot}
    Shorthand for setting a densely dashed and dotted dash pattern with more dots.
    
    设置更多点的密集虚线和点线作为“虚线模式”的缩写。
%
\begin{codeexample}[]
\tikz \draw[densely dash dot dot] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
    %
\end{stylekey}

\begin{stylekey}{/tikz/loosely dash dot dot}
    Shorthand for setting a loosely dashed and dotted dash pattern with more dots.
    
    设置更多点的疏松虚线和点线作为“虚线模式”的缩写。
%
\begin{codeexample}[]
\tikz \draw[loosely dash dot dot] (0pt,0pt) -- (50pt,0pt);
\end{codeexample}
    %
\end{stylekey}


\subsubsection{Graphic Parameters: Draw Opacity\\图形参数：绘制透明度}

When a line is drawn, it will normally ``obscure'' everything behind it as if
you had used perfectly opaque ink. It is also possible to ask \tikzname\ to use
an ink that is a little bit (or a big bit) transparent using the |draw opacity|
option. This is explained in Section~\ref{section-tikz-transparency} on
transparency in more detail.

当绘制一条线时，它通常会“遮挡”其后的所有内容，就像你使用完全不透明的墨水一样。还可以使用 |draw opacity| 选项要求 \tikzname\ 使用稍微（或者非常）透明的墨水。有关透明性的更多详细信息，请参见第~\ref{section-tikz-transparency} 节。


\subsubsection{Graphic Parameters: Double Lines and Bordered Lines\\图形参数：双线和有边框线}

\begin{key}{/tikz/double=\meta{core color} (default white)}
    This option causes ``two'' lines to be drawn instead of a single one.
    However, this is not what really happens. In reality, the path is drawn
    twice. First, with the normal drawing color, secondly with the \meta{core
    color}, which is normally |white|. Upon the second drawing, the line width
    is reduced. The net effect is that it appears as if two lines had been
    drawn and this works well even with complicated, curved paths:
    %

    使用此选项会绘制“两条”线而不是单条线。
但实际上不是这样的。实际上，路径被绘制了两次。首先，使用普通的绘制颜色，然后使用\meta{core color}进行第二次绘制，通常为|white|。在第二次绘制时，线宽会减小。总体效果是看起来好像绘制了两条线，即使在复杂的曲线路径中也能很好地工作：

\begin{codeexample}[]
\tikz \draw[double]
  plot[smooth cycle] coordinates{(0,0) (1,1) (1,0) (0,1)};
\end{codeexample}

    You can also use the doubling option to create an effect in which a line
    seems to have a certain ``border'':
    %

    您还可以使用双倍选项创建一种具有特定“边框”的线的效果：

\begin{codeexample}[]
\begin{tikzpicture}
  \draw (0,0) -- (1,1);
  \draw[draw=white,double=red,very thick] (0,1) -- (1,0);
\end{tikzpicture}
\end{codeexample}
    %
\end{key}

\begin{key}{/tikz/double distance=\meta{dimension} (initially 0.6pt)}
    Sets the distance the ``two'' lines are spaced apart. In reality, this is
    the thickness of the line that is used to draw the path for the second
    time. The thickness of the \emph{first} time the path is drawn is twice the
    normal line width plus the given \meta{dimension}. As a side-effect, this
    option ``selects'' the |double| option.
    %

    设置“两条”线之间的间距。实际上，这是用于第二次绘制路径的线的厚度。第一次绘制路径的线宽是正常线宽的两倍加上给定的\meta{dimension}。作为副作用，此选项“选择”了|double|选项。

\begin{codeexample}[]
\begin{tikzpicture}
  \draw[very thick,double]              (0,0) arc (180:90:1cm);
  \draw[very thick,double distance=2pt] (1,0) arc (180:90:1cm);
  \draw[thin,double distance=2pt]       (2,0) arc (180:90:1cm);
\end{tikzpicture}
\end{codeexample}
    %
\end{key}

\begin{key}{/tikz/double distance between line centers=\meta{dimension}}
    This option works like |double distance|, only the distance is not the
    distance between (inner) borders of the two main lines, but between their
    centers. Thus, the thickness the \emph{first} time the path is drawn is the
    normal line width plus the given \meta{dimension}, while the line width of
    the \emph{second} line that is drawn is \meta{dimension} minus the normal
    line width. As a side-effect, this option ``selects'' the |double| option.
    
    此选项的工作方式类似于|double distance|，只是距离不是两条主线（内部）边界之间的距离，而是它们的中心之间的距离。因此，第一次绘制路径的线宽是正常线宽加上给定的\meta{dimension}，而绘制的第二条线的线宽是\meta{dimension}减去正常线宽。作为副作用，此选项“选择”了|double|选项。
\begin{codeexample}[]
\begin{tikzpicture}[double distance between line centers=3pt]
  \foreach \lw in {0.5,1,1.5,2,2.5}
    \draw[line width=\lw pt,double] (\lw,0) -- ++(4mm,0);
\end{tikzpicture}
\end{codeexample}
    %
\begin{codeexample}[]
\begin{tikzpicture}[double distance=3pt]
  \foreach \lw in {0.5,1,1.5,2,2.5}
    \draw[line width=\lw pt,double] (\lw,0) -- ++(4mm,0);
\end{tikzpicture}
\end{codeexample}
    %
\end{key}

\begin{stylekey}{/tikz/double equal sign distance}
    This style selects a double line distance such that it corresponds to the
    distance of the two lines in an equal sign.
    
    此样式选择双线距离，使其与等号中两条线的距离相对应。

\begin{codeexample}[
    preamble={\usepackage{amsmath}
\usetikzlibrary{arrows.meta}}
]
\Huge $=\implies$\tikz[baseline,double equal sign distance]
                    \draw[double,thick,-{Implies[]}](0,0.55ex) --++(3ex,0);
\end{codeexample}
    %
\begin{codeexample}[
    preamble={\usepackage{amsmath}
\usetikzlibrary{arrows.meta}}
]
\normalsize $=\implies$\tikz[baseline,double equal sign distance]
                          \draw[double,-{Implies[]}](0,0.6ex) --++(3ex,0);
\end{codeexample}
    %
\begin{codeexample}[
    preamble={\usepackage{amsmath}
\usetikzlibrary{arrows.meta}}
]
\tiny $=\implies$\tikz[baseline,double equal sign distance]
                   \draw[double,very thin,-{Implies[]}](0,0.5ex) -- ++(3ex,0);
\end{codeexample}
    %
\end{stylekey}


\subsection{Adding Arrow Tips to a Path\\在路径中添加箭头}
\label{section-arrow-tip-action}

In different situations, \tikzname\ will add arrow tips to the end of a path.
For this to happen, a number of different things need to be specified:

在不同的情况下，\tikzname\ 会在路径的末尾添加箭头。为了实现这一点，需要指定几个不同的内容：

\begin{enumerate}
    \item You must have used the |arrows| key, explained in detail in
        Section~\ref{section-tikz-arrows}, to setup which kinds of arrow tips
        you would like.

        您必须使用|arrows|关键字（在第~\ref{section-tikz-arrows}节中详细解释）来设置所需的箭头类型。
    \item The path may not be closed (like a circle or a rectangle) and, if
        it consists of several subpaths, further restrictions apply as
        explained in Section~\ref{section-tikz-arrows}.

        路径不能是闭合的（如圆形或矩形），如果路径由多个子路径组成，则还需要进一步限制，如第~\ref{section-tikz-arrows}节中所述。
    \item The |tips| key must be set to an appropriate value, see
        Section~\ref{section-tikz-arrows} once more.

        必须将|tips|关键字设置为适当的值，再次参见第~\ref{section-tikz-arrows}节。
\end{enumerate}

For the current section on paths, it is only important that when you add the
|tips| option to a path that is not drawn, arrow tips will still be added at
the beginning and at the end of the current path. This is true even when
``only'' arrow tips get drawn for a path without drawing the path itself. Here
is an example:

对于当前关于路径的部分，重要的是，当您将|tips|选项添加到不绘制的路径时，箭头仍将添加到当前路径的开头和末尾。即使对于仅绘制路径的箭头，也是如此。下面是一个例子：

%
\begin{codeexample}[width=2cm,preamble={\usetikzlibrary{arrows.meta,bending}}]
\tikz \path[tips, -{Latex[open,length=10pt,bend]}] (0,0) to[bend left] (1,0);
\end{codeexample}
%
\begin{codeexample}[width=2cm,preamble={\usetikzlibrary{arrows.meta,bending}}]
\tikz \draw[tips, -{Latex[open,length=10pt,bend]}] (0,0) to[bend left] (1,0);
\end{codeexample}


\subsection{Filling a Path\\填充路径}
\label{section-rules}

To fill a path, use the following option:

要填充路径，请使用以下选项：

%
\begin{key}{/tikz/fill=\meta{color} (default \normalfont is scope's color setting)}
    This option causes the path to be filled. All unclosed parts of the path
    are first closed, if necessary. Then, the area enclosed by the path is
    filled with the current filling color, which is either the last color set
    using the general |color=| option or the optional color \meta{color}. For
    self-intersection paths and for paths consisting of several closed areas,
    the ``enclosed area'' is somewhat complicated to define and two different
    definitions exist, namely the nonzero winding number rule and the even odd
    rule, see the explanation of these options, below.

    此选项使路径填充。首先，如果需要，将关闭路径的所有未封闭部分。然后，路径所围的区域将用当前填充颜色填充，该颜色可以是使用一般的|color=|选项设置的最后一种颜色，也可以是可选\meta{color}。对于自交路径和由多个封闭区域组成的路径，定义“封闭区域”有点复杂，存在两种不同的定义，即非零环绕数规则和奇偶规则，请参阅下面对这些选项的解释。



    Just as for the |draw| option, setting \meta{color} to |none| disables
    filling locally.

    与|draw|选项一样，将\meta{color}设置为|none|会在局部禁用填充。

    %
\begin{codeexample}[]
\begin{tikzpicture}
  \fill (0,0) -- (1,1) -- (2,1);
  \fill (4,0) circle (.5cm)  (4.5,0) circle (.5cm);
  \fill[even odd rule] (6,0) circle (.5cm)  (6.5,0) circle (.5cm);
  \fill (8,0) -- (9,1) -- (10,0) circle (.5cm);
\end{tikzpicture}
\end{codeexample}

    If the |fill| option is used together with the |draw| option (either
    because both are given as options or because a |\filldraw| command is
    used), the path is filled \emph{first}, then the path is drawn
    \emph{second}. This is especially useful if different colors are selected
    for drawing and for filling. Even if the same color is used, there is a
    difference between this command and a plain |fill|: A ``filldrawn'' area
    will be slightly larger than a filled area because of the thickness of the
    ``pen''.

    如果同时使用|fill|选项和|draw|选项（无论是作为选项给出还是使用|\filldraw|命令），路径将首先被填充，然后再次绘制路径。如果为绘制和填充选择了不同的颜色，这尤其有用。即使使用相同的颜色，此命令与纯|fill|之间存在差异：由于“笔”的厚度，填充的区域将稍微大于填充区域。

    %
\begin{codeexample}[]
\begin{tikzpicture}[fill=yellow!80!black,line width=5pt]
  \filldraw (0,0) -- (1,1) -- (2,1);
  \filldraw (4,0) circle (.5cm)  (4.5,0) circle (.5cm);
  \filldraw[even odd rule] (6,0) circle (.5cm)  (6.5,0) circle (.5cm);
  \filldraw (8,0) -- (9,1) -- (10,0) circle (.5cm);
\end{tikzpicture}
\end{codeexample}
    %
\end{key}


\subsubsection{Graphic Parameters: Fill Pattern\\图形参数：填充图案}
\label{section-fill-pattern}

Instead of filling a path with a single solid color, it is also possible to
fill it with a \emph{tiling pattern}. Imagine a small tile that contains a
simple picture like a star. Then these tiles are (conceptually) repeated
infinitely in all directions, but clipped against the path.

除了使用单一的纯色填充路径之外，还可以使用\emph{平铺图案}填充路径。想象一个包含简单图片（如星星）的小瓷砖。然后，这些瓷砖在所有方向上（概念上）无限重复，但会被剪裁以适应路径。

Tiling patterns come in two variants: \emph{inherently colored patterns} and
\emph{form-only patterns}. An inherently colored pattern is, say, a red star
with a black border and will always look like this. A form-only pattern may
have a different color each time it is used, only the form of the pattern will
stay the same. As such, form-only patterns do not have any colors of their own,
but when it is used the current \emph{pattern color} is used as its color.

平铺图案有两种变体：\emph{内在着色图案}和\emph{仅形状图案}。内在着色图案是指具有特定颜色的图案，例如红色的星星带有黑色边框，它们始终保持这种外观。仅形状图案在每次使用时可能具有不同的颜色，但图案的形状保持不变。因此，仅形状图案没有自己的颜色，但在使用时使用当前的\emph{图案颜色}作为其颜色。

Patterns are not overly flexible. In particular, it is not possible to change
the size or orientation of a pattern without declaring a new pattern. For
complicated cases, it may be easier to use two nested |\foreach| statements to
simulate a pattern, but patterns are rendered \emph{much} more quickly than
simulated ones.

图案并不是非常灵活的。特别是，无法更改图案的大小或方向，而不声明新的图案。对于复杂情况，使用两个嵌套的|\foreach|语句模拟图案可能更容易，但是图案的渲染速度比模拟图案要快得多。

\begin{key}{/tikz/pattern=\meta{name} (default \normalfont is scope's pattern)}
    This option causes the path to be filled with a pattern. If the \meta{name}
    is given, this pattern is used, otherwise the pattern set in the enclosing
    scope is used. As for the |draw| and |fill| options, setting \meta{name} to
    |none| disables filling locally.

    此选项使路径填充为图案。如果给出\meta{name}，则使用该图案，否则使用封闭作用域中设置的图案。与|draw|和|fill|选项一样，将\meta{name}设置为|none|将在局部禁用填充。



    The pattern works like a fill color. In particular, setting a new fill
    color will fill the path with a solid color once more.

    该图案的工作方式类似于填充颜色。特别是，设置新的填充颜色将再次填充路径为纯色。


    Strangely, no \meta{name}s are permissible by default. You need to load for
    instance the |patterns| library, see
    Section~\ref{section-library-patterns}, to install predefined patterns.
    
    奇怪的是，默认情况下不允许使用任何\meta{name}。您需要加载例如|patterns|库，参见第~\ref{section-library-patterns}节，以安装预定义的图案。

\begin{codeexample}[preamble={\usetikzlibrary{patterns}}]
\begin{tikzpicture}
  \draw[pattern=dots] (0,0) circle (1cm);
  \draw[pattern=fivepointed stars] (0,0) rectangle (3,1);
\end{tikzpicture}
\end{codeexample}
    %
\end{key}

\begin{key}{/tikz/pattern color=\meta{color}}
    This option is used to set the color to be used for form-only patterns.
    This option has no effect on inherently colored patterns.
    
    此选项用于设置用于仅形状图案的颜色。此选项对内在着色图案没有影响。

\begin{codeexample}[preamble={\usetikzlibrary{patterns}}]
\begin{tikzpicture}
  \draw[pattern color=red,pattern=fivepointed stars]  (0,0) circle (1cm);
  \draw[pattern color=blue,pattern=fivepointed stars] (0,0) rectangle (3,1);
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[preamble={\usetikzlibrary{patterns}}]
\begin{tikzpicture}
  \def\mypath{(0,0) -- +(0,1) arc (180:0:1.5cm) -- +(0,-1)}
  \fill   [red]                                \mypath;
  \pattern[pattern color=white,pattern=bricks] \mypath;
\end{tikzpicture}
\end{codeexample}
    %
\end{key}


\subsubsection{Graphic Parameters: Interior Rules\\图形参数：内部规则}

The following two options can be used to decide how interior points should be
determined:

以下两个选项用于决定如何确定内部点：

\begin{key}{/tikz/nonzero rule}
    If this rule is used (which is the default), the following method is used
    to determine whether a given point is ``inside'' the path: From the point,
    shoot a ray in some direction towards infinity (the direction is chosen
    such that no strange borderline cases occur). Then the ray may hit the
    path. Whenever it hits the path, we increase or decrease a counter, which
    is initially zero. If the ray hits the path as the path goes ``from left to
    right'' (relative to the ray), the counter is increased, otherwise it is
    decreased. Then, at the end, we check whether the counter is nonzero (hence
    the name). If so, the point is deemed to lie ``inside'', otherwise it is
    ``outside''. Sounds complicated? It is.
    
    如果使用此规则（默认情况下），则使用以下方法来确定给定点是否位于路径的“内部”：从该点向无穷远的某个方向发射一条射线（选择的方向使得不会发生奇怪的边界情况）。然后射线可能会与路径相交。每当它与路径相交时，我们会增加或减少一个计数器，该计数器最初为零。如果射线与路径相交时，路径相对于射线“从左到右”（相对于射线）运动，则增加计数器，否则减少计数器。最后，我们检查计数器是否为非零值（因此得名）。如果是，则认为该点位于“内部”，否则位于“外部”。听起来很复杂吗？确实如此。
\begin{codeexample}[]
\begin{tikzpicture}
  \filldraw[fill=yellow!80!black]
  % Clockwise rectangle
  (0,0) -- (0,1) -- (1,1) -- (1,0) -- cycle
  % Counter-clockwise rectangle
  (0.25,0.25) -- (0.75,0.25) -- (0.75,0.75) -- (0.25,0.75) -- cycle;

  \draw[->] (0,1) -- (.4,1);
  \draw[->] (0.75,0.75) -- (0.3,.75);

  \draw[->] (0.5,0.5) -- +(0,1) node[above] {crossings: $-1+1 = 0$};

  \begin{scope}[yshift=-3cm]
    \filldraw[fill=yellow!80!black]
    % Clockwise rectangle
    (0,0) -- (0,1) -- (1,1) -- (1,0) -- cycle
    % Clockwise rectangle
    (0.25,0.25) -- (0.25,0.75) -- (0.75,0.75) -- (0.75,0.25) -- cycle;

    \draw[->] (0,1) -- (.4,1);
    \draw[->] (0.25,0.75) -- (0.4,.75);

    \draw[->] (0.5,0.5) -- +(0,1) node[above] {crossings: $1+1 = 2$};
  \end{scope}
\end{tikzpicture}
\end{codeexample}
    %
\end{key}

\begin{key}{/tikz/even odd rule}
    This option causes a different method to be used for determining the inside
    and outside of paths. While it is less flexible, it turns out to be more
    intuitive.

    此选项导致使用不同的方法来确定路径的内部和外部。虽然它的灵活性较低，但它被证明更直观。

    With this method, we also shoot rays from the point for which we wish to
    determine whether it is inside or outside the filling area. However, this
    time we only count how often we ``hit'' the path and declare the point to
    be ``inside'' if the number of hits is odd.

    使用此方法，我们还是从要确定其是否位于填充区域内部或外部的点发射射线。然而，这一次我们只计算我们“击中”路径的次数，并声明如果击中次数为奇数，则该点位于“内部”。

    Using the even-odd rule, it is easy to ``drill holes'' into a path.

    使用奇偶规则，可以轻松地在路径中“钻洞”。

    %
\begin{codeexample}[]
\begin{tikzpicture}
  \filldraw[fill=yellow!80!black,even odd rule]
    (0,0) rectangle (1,1) (0.5,0.5) circle (0.4cm);
  \draw[->] (0.5,0.5) -- +(0,1) [above] node{crossings: $1+1 = 2$};
\end{tikzpicture}
\end{codeexample}
    %
\end{key}


\subsubsection{Graphic Parameters: Fill Opacity\\图形参数：填充不透明度}
\label{section-fill-opacity}

Analogously to the |draw opacity|, you can also set the fill opacity. Please
see Section~\ref{section-tikz-transparency} for more details.

类似于|draw opacity|，您还可以设置填充不透明度。有关更多详细信息，请参见第~\ref{section-tikz-transparency}节。


\subsection{Generalized Filling: Using Arbitrary Pictures to Fill a Path\\广义填充：使用任意图片填充路径}

Sometimes you wish to ``fill'' a path with something even more complicated than
a pattern, let alone a single color. For instance, you might wish to use an
image to fill the path or some other, complicated drawing. In principle, this
effect can be achieved by first using the path for clipping and then,
subsequently, drawing the desired image or picture. However, there is an option
that makes this process much easier:

有时，您希望用比图案更复杂的东西“填充”路径，更不用说单一颜色了。例如，您可能希望使用图像填充路径或其他复杂的绘图。原则上，可以通过首先使用路径进行剪切，然后随后绘制所需的图像或图片来实现此效果。然而，有一个选项可以使这个过程更加容易：


\begin{key}{/tikz/path picture=\meta{code}}
    When this option is given on a path and when the \meta{code} is not empty,
    the following happens: After all other ``filling'' operations are done with
    the path, which are caused by the options |fill|, |pattern| and  |shade|, a
    local scope is opened and the path is temporarily installed as a clipping
    path. Then, the \meta{code} is executed, which can now draw something.
    Then, the local scope ends and, possibly, the path is stroked, provided the
    |draw| option has been given.

    当在路径上给出此选项且\meta{code}不为空时，将发生以下情况：在使用路径执行所有其他“填充”操作后，这些操作由选项|fill|、|pattern|和|shade|引起，打开一个局部作用域并将路径临时安装为剪切路径。然后，执行\meta{code}，该代码可以绘制某些内容。然后，局部作用域结束，可能会描边路径（如果给定了|draw|选项）。



    As with other keys like |fill| or |draw| this option needs to be given on a
    path, setting the |path picture| outside a path has no effect (the path
    picture is cleared at the beginning of each path).

    与|fill|或|draw|等其他键一样，此选项需要在路径上给出，将|path picture|设置在路径外部没有效果（在每个路径的开始处清除路径图片）。


    The \meta{code} can be any normal \tikzname\ code like |\draw ...| or
    |\node ...|. As always, when you include an external graphic, you need to
    put it inside a |\node|.

    \meta{code}可以是任何常规的\tikzname\ 代码，如|\draw ...|或|\node ...|。与以往一样，当您包含外部图形时，需要将其放在|\node|内部。


    Note that no special actions are taken to transform the origin in any way.
    This means that the coordinate |(0,0)| is still where is was when the path
    was being constructed and not -- as one might expect -- at the lower left
    corner of the path. However, you can use the following special node to
    access the size of the path:

    注意，不会采取任何特殊操作来以任何方式转换原点。这意味着坐标|(0,0)|仍然是在构建路径时所在的位置，而不是（人们可能期望的）路径的左下角。但是，您可以使用以下特殊节点来访问路径的大小：

    %
    \begin{predefinednode}{path picture bounding box}
        This node is of shape |rectangle|. Its size and position are those of
        |current path bounding box| just before the \meta{code} of the path
        picture started to be executed. The \meta{code} can construct its own
        paths, so accessing the |current path bounding box| inside the
        \meta{code} yields the bounding box of any path that is currently being
        constructed inside the \meta{code}.

        该节点的形状为|rectangle|。其大小和位置与在执行路径图片的\meta{code}之前的|current path bounding box|相同。可以构建自己的路径，因此在\meta{code}内部访问|current path bounding box|将得到当前在\meta{code}内部正在构建的任何路径的边界框。

    \end{predefinednode}
    %
\begin{codeexample}[]
\begin{tikzpicture}
  \draw [help lines] (0,0) grid (3,2);
  \filldraw [fill=blue!10,draw=blue,thick] (1.5,1) circle (1)
    [path picture={
      \node at (path picture bounding box.center) {
        This is a long text.
      };}
    ];
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
\begin{tikzpicture}[cross/.style={path picture={
      \draw[black]
            (path picture bounding box.south east) --
            (path picture bounding box.north west)
            (path picture bounding box.south west) --
            (path picture bounding box.north east);
    }}]
  \draw [help lines] (0,0) grid (3,2);
  \filldraw [cross,fill=blue!10,draw=blue,thick] (1,1) circle (1);
  \path     [cross,top color=red,draw=red,thick] (2,0) -- (3,2) -- (3,0);
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[]
  \begin{tikzpicture}[path image/.style={
      path picture={
        \node at (path picture bounding box.center) {
          \includegraphics[height=3cm]{#1}
        };}}]
  \draw     [help lines] (0,0) grid (3,2);

  \draw [path image=brave-gnu-world-logo,draw=blue,thick]
          (0,1) circle (1);
  \draw [path image=brave-gnu-world-logo,draw=red,very thick,->]
          (1,0) parabola[parabola height=2cm] (3,0);

\end{tikzpicture}
\end{codeexample}
    %
\end{key}


\subsection{Shading a Path\\路径渐变填充}

You can shade a path using the |shade| option. A shading is like a filling,
only the shading changes its color smoothly from one color to another.

您可以使用|shade|选项对路径进行渐变填充。渐变填充类似于填充，只是渐变填充会使颜色在一个颜色到另一个颜色之间平滑变化。

\begin{key}{/tikz/shade}
    Causes the path to be shaded using the currently selected shading (more on
    this later). If this option is used together with the |draw| option, then
    the path is first shaded, then drawn.

    使用当前选择的渐变对路径进行渐变填充（稍后详细介绍）。如果此选项与|draw|选项一起使用，则先进行渐变填充，然后再绘制路径。

    It is not an error to use this option together with the |fill| option, but
    it makes no sense.

    使用此选项与|fill|选项同时使用并不是错误，但没有意义。

    %
\begin{codeexample}[]
\tikz \shade (0,0) circle (1ex);
\end{codeexample}

\begin{codeexample}[]
\tikz \shadedraw (0,0) circle (1ex);
\end{codeexample}
    %
\end{key}

For some shadings it is not really clear how they can ``fill'' the path. For
example, the |ball| shading normally looks like this:
\tikz \shade[shading=ball] (0,0) circle (0.75ex);. How is this supposed to
shade a rectangle? Or a triangle?

对于某些渐变，它们如何“填充”路径并不是很清楚。例如，|ball|渐变通常如下所示：
\tikz \shade[shading=ball] (0,0) circle (0.75ex);。这如何渐变填充一个矩形？或一个三角形？



To solve this problem, the predefined shadings like |ball| or |axis| fill a
large rectangle completely in a sensible way. Then, when the shading is used to
``shade'' a path, what actually happens is that the path is temporarily used
for clipping and then the rectangular shading is drawn, scaled and shifted such
that all parts of the path are filled.

为了解决这个问题，预定义的渐变如|ball|或|axis|以合理的方式完全填充一个大矩形。然后，当使用渐变来“填充”路径时，实际发生的是路径被临时用于剪切，然后绘制、缩放和移动矩形渐变，使得路径的所有部分都被填充。

The default shading is a smooth transition from gray to white and from top to
bottom. However, other shadings are also possible, for example a shading that
will sweep a color from the center to the corners outward. To choose the
shading, you can use the |shading=| option, which will also automatically
invoke the |shade| option. Note that this does \emph{not} change the shading
color, only the way the colors sweep. For changing the colors, other options
are needed, which are explained below.

默认渐变是从灰色到白色，从上到下的平滑过渡。然而，也可以使用其他渐变，例如从中心向角落外部扫过的渐变。要选择渐变，可以使用|shading=|选项，这也会自动调用|shade|选项。请注意，这不会改变渐变颜色，只改变颜色扫过的方式。要更改颜色，需要使用其他选项，下面将对此进行解释。


\begin{key}{/tikz/shading=\meta{name}}
    This selects a shading named \meta{name}. The following shadings are
    predefined: |axis|, |radial|, and |ball|.

    这里选择了名为\meta{name}的着色。预定义的着色有：|axis|、|radial|和|ball|。

    %
\begin{codeexample}[]
\tikz \shadedraw [shading=axis] (0,0) rectangle (1,1);
\tikz \shadedraw [shading=radial] (0,0) rectangle (1,1);
\tikz \shadedraw [shading=ball] (0,0) circle (.5cm);
\end{codeexample}

    The shadings as well as additional shadings are described in more detail in
    Section~\ref{section-library-shadings}.

    这些着色以及其他额外的着色在第~\ref{section-library-shadings}节中有更详细的描述。



    To change the color of a shading, special options are needed like
    |left color|, which sets the color of an axis shading from left to right.
    These options implicitly also select the correct shading type, see the
    following example

    要更改着色的颜色，需要使用特殊选项，如|left color|，它将一个轴着色从左到右设置为颜色。这些选项隐式地也选择了正确的着色类型，参见以下示例

    %
\begin{codeexample}[]
\tikz \shadedraw [left color=red,right color=blue]
    (0,0) rectangle (1,1);
\end{codeexample}

    For a complete list of the possible options see
    Section~\ref{section-library-shadings} once more.

    要查看可能选项的完整列表，请再次参阅第~\ref{section-library-shadings}节。



    \begin{key}{/tikz/shading angle=\meta{degrees} (initially 0)}
        This option rotates the shading (not the path!) by the given angle. For
        example, we can turn a top-to-bottom axis shading into a left-to-right
        shading by rotating it by $90^\circ$.

        此选项通过给定的角度旋转着色（而不是路径！）。例如，我们可以通过将其旋转$90^\circ$将自上而下的轴着色变为自左到右的着色。

        %
\begin{codeexample}[]
\tikz \shadedraw [shading=axis,shading angle=90] (0,0) rectangle (1,1);
\end{codeexample}
    \end{key}
\end{key}

You can also define new shading types yourself. However, for this, you need to
use the basic layer directly, which is, well, more basic and harder to use.
Details on how to create a shading appropriate for filling paths are given in
Section~\ref{section-shading-a-path}.

您还可以自定义新的着色类型。但是，为此，您需要直接使用基本层，这更基础且更难使用。有关如何创建适合填充路径的着色的详细信息，请参见第~\ref{section-shading-a-path}节。



\subsection{Establishing a Bounding Box\\建立边界框}

\pgfname\ is reasonably good at keeping track of the size of your picture and
reserving just the right amount of space for it in the main document. However,
in some cases you may want to say things like ``do not count this for the
picture size'' or ``the picture is actually a little large''. For this you can
use the option |use as bounding box| or the command |\useasboundingbox|, which
is just a shorthand for |\path[use as bounding box]|.

\pgfname 在跟踪图片的大小和在主文档中为其保留恰当的空间方面做得相当好。然而，在某些情况下，您可能希望说“不要计算此部分的图片大小”或者“图片实际上有点大”。为此，您可以使用选项|use as bounding box|或命令|\useasboundingbox|，它只是|\path[use as bounding box]|的简写形式。

\begin{key}{/tikz/use as bounding box}
    Normally, when this option is given on a path, the bounding box of the
    present path is used to determine the size of the picture and the size of
    all \emph{subsequent} paths are ignored. However, if there were previous
    path operations that have already established a larger bounding box, it
    will not be made smaller by this operation (consider the
    |\pgfresetboundingbox| command to reset the previous bounding box).

    通常情况下，当在路径上给出此选项时，当前路径的边界框用于确定图片的大小，并且所有\emph{后续}路径的大小被忽略。然而，如果存在已经建立了较大边界框的先前路径操作，那么此操作不会使边界框变小（考虑使用|\pgfresetboundingbox|命令重置先前的边界框）。


    In a sense, |use as bounding box| has the same effect as clipping all
    subsequent drawing against the current path -- without actually doing the
    clipping, only making \pgfname\ treat everything as if it were clipped.

    从某种意义上说，|use as bounding box| 的效果就像将所有后续的绘图裁剪到当前路径一样——实际上并不执行裁剪，只是使 \pgfname 以裁剪的方式对待所有内容。


    The first application of this option is to have a |{tikzpicture}| overlap
    with the main text:
    
    此选项的第一个应用是使 |{tikzpicture}| 与主文本重叠：

\begin{codeexample}[]
Left of picture\begin{tikzpicture}
  \draw[use as bounding box] (2,0) rectangle (3,1);
  \draw (1,0) -- (4,.75);
\end{tikzpicture}right of picture.
\end{codeexample}

    In a second application this option can be used to get better control over
    the white space around the picture:

    在第二个应用中，可以使用此选项更好地控制图片周围的空白：

    %
\begin{codeexample}[]
Left of picture
\begin{tikzpicture}
  \useasboundingbox (0,0) rectangle (3,1);
  \fill (.75,.25) circle (.5cm);
\end{tikzpicture}
right of picture.
\end{codeexample}

    Note: If this option is used on a path inside a \TeX\ group (scope), the
    effect ``lasts'' only until the end of the scope. Again, this behavior is
    the same as for clipping.

    注意：如果在\TeX 组（作用域）内的路径上使用此选项，则此效果仅持续到作用域结束。再次强调，此行为与裁剪相同。


    Consider using |\useasboundingbox| together with |\pgfresetboundingbox| in
    order to replace the bounding box with a new one.

    考虑在 |\useasboundingbox| 和 |\pgfresetboundingbox| 一起使用，以替换边界框为新边界框。
\end{key}

There is a node that allows you to get the size of the current bounding box.
The |current bounding box| node has the |rectangle| shape and its size is
always the size of the current bounding box.

有一个节点允许您获取当前边界框的大小。|current bounding box| 节点具有 |rectangle| 形状，其大小始终是当前边界框的大小。


Similarly, the |current path bounding box| node has the |rectangle| shape and
the size of the bounding box of the current path.

类似地，|current path bounding box| 节点具有 |rectangle| 形状和当前路径的边界框大小。

\begin{codeexample}[]
\begin{tikzpicture}
  \draw[red] (0,0) circle (2pt);
  \draw[red] (2,1) circle (3pt);

  \draw (current bounding box.south west) rectangle
        (current bounding box.north east);

  \draw[red] (3,-1) circle (4pt);

  \draw[thick] (current bounding box.south west) rectangle
               (current bounding box.north east);
\end{tikzpicture}
\end{codeexample}

Occasionally, you may want to align multiple |tikzpicture| environments
horizontally and/or vertically at some prescribed position. The vertical
alignment can be realized by means of the |baseline| option since \TeX\
supports the concept of box depth natively. For horizontal alignment, things
are slightly more involved. The following approach is realized by means of
negative |\hspace|s before and/or after the picture, thereby removing parts of
the picture. However, the actual amount of negative horizontal space is
provided by means of image coordinates using the |trim left| and |trim right|
keys:

偶尔，您可能希望在某个指定位置水平和/或垂直地对齐多个|tikzpicture| 环境。可以通过 |baseline| 选项实现垂直对齐，因为 \TeX 支持盒子深度的概念。对于水平对齐，情况稍微复杂一些。下面的方法是通过在图片之前和/或之后使用负的|\hspace|来移除图片的部分内容来实现的。然而，实际的负水平空间量是使用 |trim left| 和 |trim right| 键以图像坐标的方式提供的：

\begin{key}{/tikz/trim left=\meta{dimension or coordinate or \texttt{default}} (default 0pt)}
    The |trim left| key tells \pgfname\space to discard everything which is
    left of the provided \meta{dimension or coordinate}. Here, \meta{dimension}
    is a single $x$ coordinate of the picture and \meta{coordinate} is a point
    with $x$ and $y$ coordinates (but only its $x$ coordinate will be used).
    The effect is the same as if you issue |\hspace{-s}| where |s| is the
    difference of the picture's bounding box lower left $x$ coordinate and the
    $x$ coordinate specified as \meta{dimension or coordinate}:
    
    |trim left| 键告诉 \pgfname 忽略左边提供的 \meta{dimension or coordinate} 左侧的所有内容。在这里，\meta{dimension} 是图片的单个 $x$ 坐标，\meta{coordinate} 是具有 $x$ 和 $y$ 坐标的点（但只使用其 $x$ 坐标）。效果等同于发出 |\hspace{-s}|，其中 $s$ 是图片边界框左下角 $x$ 坐标与指定的 \meta{dimension or coordinate} 的 $x$ 坐标的差值：

\begin{codeexample}[]
Text before image.%
    \begin{tikzpicture}[trim left]
        \draw (-1,-1) grid (3,2);
        \fill (0,0) circle (5pt);
    \end{tikzpicture}%
Text after image.
\end{codeexample}
    %
    Since |trim left| uses the default |trim left=0pt|, everything left of
    $x=0$ is removed from the bounding box.

    由于 |trim left| 使用默认值 |trim left=0pt|，所以边界框左侧 $x=0$ 的内容将被移除。

    The following example has once the relative long label $-1$ and once the
    shorter label $1$. Horizontal alignment is established with |trim left|:

    下面的示例中，一次使用了相对较长的标签 $-1$，一次使用了较短的标签 $1$。使用 |trim left| 实现了水平对齐：
    %
\begin{codeexample}[pre={\vbox\bgroup\hsize=5cm},post=\egroup,width=8cm]
\begin{tikzpicture}
    \draw (0,1) -- (0,0) -- (1,1) -- cycle;
    \fill (0,0) circle (2pt);
    \node[left] at (0,0) {$-1$};
\end{tikzpicture}
\par
\begin{tikzpicture}
    \draw (0,1) -- (0,0) -- (1,1) -- cycle;
    \fill (0,0) circle (2pt);
    \node[left] at (0,0) {$1$};
\end{tikzpicture}
\par
\begin{tikzpicture}[trim left]
    \draw (0,1) -- (0,0) -- (1,1) -- cycle;
    \fill (0,0) circle (2pt);
    \node[left] at (0,0) {$-1$};
\end{tikzpicture}
\par
\begin{tikzpicture}[trim left]
    \draw (0,1) -- (0,0) -- (1,1) -- cycle;
    \fill (0,0) circle (2pt);
    \node[left] at (0,0) {$1$};
\end{tikzpicture}
\end{codeexample}

    Use |trim left=default| to reset the value.

    使用 |trim left=default| 重置值。
\end{key}

\begin{key}{/tikz/trim right=\meta{dimension or coordinate or \texttt{default}}}
    This key is similar to |trim left|: it discards everything which is right
    of the provided \meta{dimension or coordinate}. As for |trim left|,
    \meta{dimension} denotes a single $x$ coordinate of the picture and
    \meta{coordinate} a coordinate with $x$ and $y$ value (although only its
    $x$ component will be used).

    此键类似于 |trim left|：它忽略提供的 \meta{dimension or coordinate} 右侧的所有内容。与 |trim left| 一样，\meta{dimension} 表示图片的单个 $x$ 坐标，\meta{coordinate} 是具有 $x$ 和 $y$ 值的坐标（尽管只使用其 $x$ 分量）。



    We use the same example from above and add |trim right|:
    
    我们使用上面的相同示例，并添加 |trim right|：

\begin{codeexample}[]
Text before image.%
    \begin{tikzpicture}[trim left, trim right=2cm, baseline]
        \draw (-1,-1) grid (3,2);
        \fill (0,0) circle (5pt);
    \end{tikzpicture}%
Text after image.
\end{codeexample}
    %
    In addition to |trim left=0pt|, we also discard everything which is right
    of $x$|=2cm|. Furthermore, the |baseline| key supports vertical alignment
    as well (using the $y$|=0cm| baseline).

    除了 |trim left=0pt| 之外，我们还丢弃了 $x=2\mathrm{cm}$ 右侧的所有内容。此外，|baseline| 键还支持垂直对齐（使用 $y=0\mathrm{cm}$ 的基线）。


    Use |trim right=default| to reset the value.

    使用 |trim right=default| 重置值。

\end{key}

Note that |baseline|, |trim left| and |trim right| are currently the
\emph{only} supported way of truncated bounding boxes which are compatible with
image externalization (see the |external| library for details).

请注意，目前仅支持使用 |baseline|、|trim left| 和 |trim right| 来截取与图像外部化兼容的边界框（有关详细信息，请参阅 |external| 库）。

\begin{key}{/pgf/trim lowlevel=\mchoice{true,false} (initially false)}
    This affects only the basic level image externalization: the initial
    configuration |trim lowlevel=false| stores the normal image, without
    trimming, and the trimming into a separate file. This allows reduced
    bounding boxes without clipping the rest away. The |trim lowlevel=true|
    information causes the image externalization to store the trimmed image,
    possibly resulting in clipping.

    这仅影响基本级别的图像外部化：初始配置 |trim lowlevel=false| 会将正常图像存储，不进行裁剪，并将裁剪结果存储到单独的文件中。这样可以实现减小边界框而不裁剪其余部分。而 |trim lowlevel=true| 会将裁剪后的图像存储，可能导致剪裁。
\end{key}


\subsection{Clipping and Fading (Soft Clipping)\\剪裁和渐变（软剪裁）}

\emph{Clipping path} means that all painting on the page is restricted to a
certain area. This area need not be rectangular, rather an arbitrary path can
be used to specify this area. The |clip| option, explained below, is used to
specify the region that is to be used for clipping.

\emph{剪裁路径}指的是限制页面上的所有绘画活动在某个特定区域内。该区域不一定是矩形的，可以使用任意路径来指定。下面将介绍的 |clip| 选项用于指定用于剪裁的区域。

A \emph{fading} (a term that I propose, fadings are commonly known as soft
masks, transparency masks, opacity masks or soft clips) is similar to clipping,
but a fading allows parts of the picture to be only ``half clipped''. This
means that a fading can specify that newly painted pixels should be partly
transparent. The specification and handling of fadings is a bit complex and it
is detailed in Section~\ref{section-tikz-transparency}, which is devoted to
transparency in general.

\emph{渐变}（我提议的术语，渐变通常被称为软蒙版、透明蒙版、不透明蒙版或软剪裁）类似于剪裁，但是渐变允许图像的某些部分只被“半剪裁”。这意味着渐变可以指定新绘制的像素部分为部分透明。渐变的规范和处理有些复杂，详细内容请参见第~\ref{section-tikz-transparency} 节中关于透明度的介绍。

\begin{key}{/tikz/clip}
    This option causes all subsequent drawings to be clipped against the
    current path and the size of subsequent paths will not be important for the
    picture size. If you clip against a self-intersecting path, the even-odd
    rule or the nonzero winding number rule is used to determine whether a
    point is inside or outside the clipping region.

    此选项导致后续的绘图被剪裁为当前路径所限，并且后续路径的大小对图片大小无关紧要。如果对自交路径进行剪裁，则使用奇偶规则或非零环绕数规则来确定点位于剪裁区域的内部还是外部。

    The clipping path is a graphic state parameter, so it will be reset at the
    end of the current scope. Multiple clippings accumulate, that is, clipping
    is always done against the intersection of all clipping areas that have
    been specified inside the current scopes. The only way of enlarging the
    clipping area is to end a |{scope}|.

    剪裁路径是一个图形状态参数，因此它会在当前作用域结束时被重置。多个剪裁会累积，也就是说，剪裁将始终针对在当前作用域内指定的所有剪裁区域的交集进行。唯一扩大剪裁区域的方法是结束一个 |{scope}|。
    %
\begin{codeexample}[]
\begin{tikzpicture}
  \draw[clip] (0,0) circle (1cm);
  \fill[red] (1,0) circle (1cm);
\end{tikzpicture}
\end{codeexample}

    It  is usually a \emph{very} good idea to apply the |clip| option only to
    the first path command in a scope.

    最好将 |clip| 选项仅应用于作用域中的第一个路径命令。

    If you ``only wish to clip'' and do not wish to draw anything, you can use
    the |\clip| command, which is a shorthand for |\path[clip]|.

    如果你只希望进行剪裁而不画任何东西，可以使用 |\clip| 命令，它是 |\path[clip]| 的简写。
    %
\begin{codeexample}[]
\begin{tikzpicture}
  \clip (0,0) circle (1cm);
  \fill[red] (1,0) circle (1cm);
\end{tikzpicture}
\end{codeexample}

    To keep clipping local, use |{scope}| environments as in the following
    example:

    要保持剪裁局部化，请使用 |{scope}| 环境，如下面的示例所示：
    %
\begin{codeexample}[]
\begin{tikzpicture}
  \draw (0,0) -- ( 0:1cm);
  \draw (0,0) -- (10:1cm);
  \draw (0,0) -- (20:1cm);
  \draw (0,0) -- (30:1cm);
  \begin{scope}[fill=red]
    \fill[clip] (0.2,0.2) rectangle (0.5,0.5);

    \draw (0,0) -- (40:1cm);
    \draw (0,0) -- (50:1cm);
    \draw (0,0) -- (60:1cm);
  \end{scope}
  \draw (0,0) -- (70:1cm);
  \draw (0,0) -- (80:1cm);
  \draw (0,0) -- (90:1cm);
\end{tikzpicture}
\end{codeexample}

    There is a slightly annoying catch: You cannot specify certain graphic
    options for the command used for clipping. For example, in the above code
    we could not have moved the |fill=red| to the |\fill| command. The reasons
    for this have to do with the internals of the \pdf\ specification. You do
    not want to know the details. It is best simply not to specify any options
    for these commands.

    这里有一个稍微令人讨厌的问题：不能为用于剪裁的命令指定某些图形选项。例如，在上面的代码中，我们不能将 |fill=red| 移动到 |\fill| 命令中。这是由于 \pdf\ 规范的内部机制导致的。你不需要了解细节。最好是对这些命令不指定任何选项。
\end{key}


\subsection{Doing Multiple Actions on a Path\\在路径上执行多个操作}

If more than one of the basic actions like drawing, clipping and filling are
requested, they are automatically applied in a sensible order: First, a path is
filled, then drawn, and then clipped (although it took Apple two major
revisions of their operating system to get this right\dots). Sometimes,
however, you need finer control over what is done with a path. For instance,
you might wish to first fill a path with a color, then repaint the path with a
pattern and then repaint it with yet another pattern. In such cases you can use
the following two options:

如果要求执行多个基本操作（如绘制、剪裁和填充），它们会自动以合理的顺序应用：首先填充路径，然后绘制路径，最后剪裁路径（尽管苹果公司经过两次主要的操作系统修订才正确实现这一点……）。然而，有时您需要对路径的处理顺序进行更精细的控制。例如，您可能希望首先用颜色填充路径，然后用图案重新绘制路径，最后用另一个图案再次绘制路径。在这种情况下，您可以使用以下两个选项：

\begin{key}{/tikz/preaction=\meta{options}}
    This option can be given to a |\path| command (or to derived commands like
    |\draw| which internally call |\path|). Similarly to options like |draw|,
    this option only has an effect when given to a |\path| or as part of the
    options of a |node|; as an option to a |{scope}| it has no effect.

    此选项可以应用于 |\path| 命令（或内部调用 |\path| 的派生命令，如 |\draw|）。与 |draw| 等选项类似，此选项仅在应用于 |\path| 或作为 |node| 的选项的一部分时才有效；作为 |{scope}| 的选项时没有效果。



    When this option is used on a |\path|, the effect is the following: When
    the path has been completely constructed and is about to be used, a scope
    is created. Inside this scope, the path is used but not with the original
    path options, but with \meta{options} instead. Then, the path is used in
    the usual manner. In other words, the path is used twice: Once with
    \meta{options} in force and then again with the normal path options in
    force.

    当在 |\path| 上使用此选项时，效果如下：当路径完全构建并即将使用时，创建一个作用域。在此作用域内，使用路径，但不使用原始路径选项，而是使用 \meta{options}。然后，以通常的方式使用路径。换句话说，路径被使用两次：一次使用 \meta{options}，一次使用正常的路径选项。


    Here is an example in which the path consists of a rectangle. The main
    action is to draw this path in red (which is why we see a red rectangle).
    However, the preaction is to draw the path in blue, which is why we see a
    blue rectangle behind the red rectangle.

    下面是一个例子，其中路径由一个矩形组成。主要操作是以红色绘制该路径（因此我们看到一个红色矩形）。然而，preaction 是以蓝色绘制路径，所以我们看到红色矩形后面有一个蓝色矩形。

    %
\begin{codeexample}[]
\begin{tikzpicture}
  \draw[help lines] (0,0) grid (3,2);

  \draw
    [preaction={draw,line width=4mm,blue}]
    [line width=2mm,red] (0,0) rectangle (2,2);
\end{tikzpicture}
\end{codeexample}

    Note that when the preactions are preformed, then the path is already
    ``finished''. In particular, applying a coordinate transformation to the
    path has no effect. By comparison, applying a canvas transformation does
    have an effect. Let us use this to add a ``shadow'' to a path. For this, we
    use the preaction to fill the path in gray, shifted a bit to the right and
    down:

    请注意，当执行 preactions 时，路径已经“完成”。特别是，对路径应用坐标变换不会产生任何效果。相比之下，应用画布变换会产生效果。让我们使用这个特性为路径添加一个“阴影”。为此，我们使用 preaction 在稍微向右下方偏移的位置以灰色填充路径：

    %
\begin{codeexample}[]
\begin{tikzpicture}
  \draw[help lines] (0,0) grid (3,2);
  \draw
    [preaction={fill=black,opacity=.5,
                transform canvas={xshift=1mm,yshift=-1mm}}]
    [fill=red] (0,0) rectangle (1,2)
               (1,2) circle (5mm);
\end{tikzpicture}
\end{codeexample}

    Naturally, you would normally create a style |shadow| that contains the
    above code. The |shadows| library, see Section~\ref{section-libs-shadows},
    contains predefined shadows of this kind.

    通常，您通常会创建一个包含上述代码的样式 |shadow|。|shadows| 库中包含了预定义的此类阴影，详见第~\ref{section-libs-shadows} 节。


    It is possible to use the |preaction| option multiple times. In this case,
    for each use of the |preaction| option, the path is used again (thus, the
    \meta{options} do not accumulate in a single usage of the path). The path
    is used in the order of |preaction| options given.

    可以多次使用 |preaction| 选项。在这种情况下，对于每个 |preaction| 选项的使用，路径都会再次使用（因此，\meta{options} 不会在单个路径使用中累积）。路径的使用顺序遵循给定的 |preaction| 选项的顺序。


    In the following example, we use one |preaction| to add a shadow and
    another to provide a shading, while the main action is to use a pattern.
    
    在下面的示例中，我们使用一个 |preaction| 添加阴影，另一个提供渐变效果，而主要操作是使用图案：

\begin{codeexample}[preamble={\usetikzlibrary{patterns}}]
\begin{tikzpicture}
  \draw[help lines] (0,0) grid (3,2);
  \draw [pattern=fivepointed stars]
    [preaction={fill=black,opacity=.5,
                transform canvas={xshift=1mm,yshift=-1mm}}]
    [preaction={top color=blue,bottom color=white}]
               (0,0) rectangle (1,2)
               (1,2) circle (5mm);
\end{tikzpicture}
\end{codeexample}

    A complicated application is shown in the following example, where the path
    is used several times with different fadings and shadings to create a
    special visual effect:
    
    下面的示例展示了一个复杂的应用，其中路径多次使用不同的渐变和阴影创建特殊的视觉效果：

\begin{codeexample}[preamble={\usetikzlibrary{fadings,patterns}}]
\begin{tikzpicture}
  [
    % Define an interesting style
    button/.style={
      % First preaction: Fuzzy shadow
      preaction={fill=black,path fading=circle with fuzzy edge 20 percent,
                 opacity=.5,transform canvas={xshift=1mm,yshift=-1mm}},
      % Second preaction: Background pattern
      preaction={pattern=#1,
                 path fading=circle with fuzzy edge 15 percent},
      % Third preaction: Make background shiny
      preaction={top color=white,
                 bottom color=black!50,
                 shading angle=45,
                 path fading=circle with fuzzy edge 15 percent,
                 opacity=0.2},
      % Fourth preaction: Make edge especially shiny
      preaction={path fading=fuzzy ring 15 percent,
                 top color=black!5,
                 bottom color=black!80,
                 shading angle=45},
      inner sep=2ex
    },
    button/.default=horizontal lines light blue,
    circle
  ]

  \draw [help lines] (0,0) grid (4,3);

  \node [button] at (2.2,1) {\Huge Big};
  \node [button=crosshatch dots light steel blue,
         text=white] at (1,1.5) {Small};
\end{tikzpicture}
\end{codeexample}
    %
\end{key}

\begin{key}{/tikz/postaction=\meta{options}}
    The postactions work in the same way as the preactions, only they are
    applied \emph{after} the main action has been taken. Like preactions,
    multiple |postaction| options may be given to a |\path| command, in which
    case the path is reused several times, each time with a different set of
    options in force.

    postaction与preaction的工作方式相同，只是它们在主要动作被执行\emph{之后}应用。与preaction类似，可以在|\path|命令中给出多个|postaction|选项，此时路径会被多次重用，每次使用不同的选项集。

    If both pre- and postactions are specified, then the preactions are taken
    first, then the main action, and then the post actions.

    如果同时指定了preaction和postaction，则首先执行preaction，然后执行主要动作，最后执行postaction。


    In the first example, we use a postaction to draw the path, after it has
    already been drawn:

    在第一个示例中，我们使用postaction在路径已经被绘制后再次绘制它：
    %
\begin{codeexample}[]
\begin{tikzpicture}
  \draw[help lines] (0,0) grid (3,2);

  \draw
    [postaction={draw,line width=2mm,blue}]
    [line width=4mm,red,fill=white] (0,0) rectangle (2,2);
\end{tikzpicture}
\end{codeexample}

    In another example, we use a postaction to ``colorize'' a path:

    在另一个示例中，我们使用postaction对路径进行“着色”：
    %
\begin{codeexample}[preamble={\usetikzlibrary{fadings}}]
\begin{tikzpicture}
  \draw[help lines] (0,0) grid (3,2);
  \draw
    [postaction={path fading=south,fill=white}]
    [postaction={path fading=south,fading angle=45,fill=blue,opacity=.5}]
    [left color=black,right color=red,draw=white,line width=2mm]
               (0,0) rectangle (1,2)
               (1,2) circle (5mm);
\end{tikzpicture}
\end{codeexample}
    %
\end{key}


\subsection{Decorating and Morphing a Path\\装饰和变形路径}

Before a path is used, it is possible to first ``decorate'' and/or ``morph''
it. Morphing means that the path is replaced by another path that is slightly
varied. Such morphings are a special case of the more general ``decorations''
described in detail in Section~\ref{section-tikz-decorations}. For instance, in
the following example the path is drawn twice: Once normally and then in a
morphed (=decorated) manner.

在使用路径之前，可以先对其进行“装饰”和/或“变形”。变形意味着将路径替换为稍微变化的另一条路径。这种变形是更一般的“装饰”的特殊情况，详细介绍在第~\ref{section-tikz-decorations}节中。例如，在下面的示例中，路径被绘制两次：一次正常绘制，然后以变形（即装饰）的方式再次绘制。


\begin{codeexample}[preamble={\usetikzlibrary{decorations.pathmorphing}}]
\begin{tikzpicture}
  \draw (0,0) rectangle (3,2);
  \draw [red, decorate, decoration=zigzag]
        (0,0) rectangle (3,2);
\end{tikzpicture}
\end{codeexample}

Naturally, we could have combined this into a single command using pre- or
postaction. It is also possible to deform shapes:

当然，我们也可以使用preaction或postaction将其合并为单个命令。还可以对形状进行变形：

\begin{codeexample}[preamble={\usetikzlibrary{decorations.pathmorphing,shadows}}]
\begin{tikzpicture}
  \node [circular drop shadow={shadow scale=1.05},minimum size=3.13cm,
         decorate, decoration=zigzag,
         fill=blue!20,draw,thick,circle] {Hello!};
\end{tikzpicture}
\end{codeexample}
