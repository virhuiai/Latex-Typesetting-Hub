% Copyright 2019 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Free Documentation License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.
\columnratio{0.55}
\columnratio{0.55}
\begin{paracol}{2}

\section{Tutorial: Euclid's Amber Version of the \emph{Elements}}
\switchcolumn
\section{教程：欧几里德的《几何原本》琥珀版}
\switchcolumn[0]*%%%%%%%%%%%%
In this third tutorial we have a look at how \tikzname\ can be used to draw
geometric constructions.
\switchcolumn
在这个第三个教程中，我们将看看如何使用\tikzname\ 绘制几何构造。
\switchcolumn[0]*%%%%%%%%%%%%
Euclid is currently quite busy writing his new book series, whose working title
is ``Elements'' (Euclid is not quite sure whether this title will convey the
message of the series to future generations correctly, but he intends to change
the title before it goes to the publisher). Up to now, he wrote down his text
and graphics on papyrus, but his publisher suddenly insists that he must submit
in electronic form. Euclid tries to argue with the publisher that electronics
will only be discovered thousands of years later, but the publisher informs him
that the use of papyrus is no longer cutting edge technology and Euclid will
just have to keep up with modern tools.
\switchcolumn
欧几里德目前正在忙于撰写他的新书系列，暂定名为《几何原本》（欧几里德不确定这个标题是否能正确传达系列的信息给后代，但他打算在提交给出版商之前更改标题）。到目前为止，他把自己的文本和图形写在纸莎草上，但他的出版商突然坚持他必须以电子形式提交。欧几里德试图向出版商辩解，电子技术只会在几千年后被发现，但出版商告诉他，使用纸莎草已经不再是最前沿的技术，欧几里德必须跟上现代工具的步伐。
\switchcolumn[0]*%%%%%%%%%%%%
Slightly disgruntled, Euclid starts converting his papyrus entitled ``Book I,
Proposition I'' to an amber version.
\switchcolumn
欧几里德有些不满，开始将自己的纸莎草《第一卷，命题一》转换成琥珀版本。

\switchcolumn[0]*%%%%%%%%%%%%
\subsection{Book I, Proposition I}
\switchcolumn
\subsection{第一卷，命题一}
\switchcolumn[0]*%%%%%%%%%%%%
The drawing on his papyrus looks like this:\footnote{The text is taken from the
wonderful interactive version of Euclid's Elements by David E. Joyce, to be
found on his website at Clark University.}
\switchcolumn
他的纸莎草上的绘图如下所示：\footnote{文本摘自大卫·E·乔伊斯（David E. Joyce）出色的《欧几里德几何原本》互动版本，在克拉克大学的网站上可以找到。}

\bigskip
\switchcolumn[0]*%%%%%%%%%%%%
\noindent
\begin{tikzpicture}[thick,help lines/.style={thin,draw=black!50}]
  \pgfmathsetseed{1}
  \def\A{\textcolor{input}{$A$}}
  \def\B{\textcolor{input}{$B$}}
  \def\C{\textcolor{output}{$C$}}
  \def\D{$D$}
  \def\E{$E$}

  \colorlet{input}{blue!80!black}
  \colorlet{output}{red!70!black}
  \colorlet{triangle}{orange}

  \coordinate [label=left:\A]
    (A) at ($ (0,0) + .1*(rand,rand) $);
  \coordinate [label=right:\B]
    (B) at ($ (1.25,0.25) + .1*(rand,rand) $);

  \draw [input] (A) -- (B);

  \node [name path=D,help lines,draw,label=left:\D] (D) at (A) [circle through=(B)] {};
  \node [name path=E,help lines,draw,label=right:\E] (E) at (B) [circle through=(A)] {};

  \path [name intersections={of=D and E,by={[label=above:\C]C}}];

  \draw [output] (A) -- (C);
  \draw [output] (B) -- (C);

  \foreach \point in {A,B,C}
    \fill [black,opacity=.5] (\point) circle (2pt);

  \begin{pgfonlayer}{background}
    \fill[triangle!80] (A) -- (C) -- (B) -- cycle;
  \end{pgfonlayer}

  \node [below right,text width=10cm,align=justify] at (4,3)
  {
    \small
    \textbf{Proposition I}\par
    \emph{To construct an \textcolor{triangle}{equilateral triangle}
      on a given \textcolor{input}{finite straight line}.}
    \par
    \vskip1em
    Let \A\B\ be the given \textcolor{input}{finite straight line}. It
    is required to construct an \textcolor{triangle}{equilateral
      triangle} on the \textcolor{input}{straight line}~\A\B.

    Describe the circle \B\C\D\ with center~\A\ and radius \A\B. Again
    describe the circle \A\C\E\ with center~\B\ and radius \B\A. Join the
    \textcolor{output}{straight lines} \C\A\ and \C\B\ from the
    point~\C\ at which the circles cut one another to the points~\A\ and~\B.

    Now, since the point~\A\ is the center of the circle \C\D\B,
    therefore \A\C\ equals \A\B. Again, since the point \B\ is the
    center of the circle \C\A\E, therefore \B\C\ equals \B\A. But
    \A\C\ was proved equal to \A\B, therefore each of the straight
    lines \A\C\ and \B\C\ equals \A\B. And
    things which equal the same thing also equal one another,
    therefore \A\C\ also equals \B\C. Therefore the three straight
    lines \A\C, \A\B, and \B\C\ equal one another.
    Therefore the \textcolor{triangle}{triangle} \A\B\C\ is
    equilateral, and it has been  constructed on the given finite
    \textcolor{input}{straight line}~\A\B.
  };
\end{tikzpicture}
\switchcolumn
\noindent
\begin{tikzpicture}[thick,help lines/.style={thin,draw=black!50}]
  \pgfmathsetseed{1}
  \def\A{\textcolor{input}{$A$}}
  \def\B{\textcolor{input}{$B$}}
  \def\C{\textcolor{output}{$C$}}
  \def\D{$D$}
  \def\E{$E$}

  \colorlet{input}{blue!80!black}
  \colorlet{output}{red!70!black}
  \colorlet{triangle}{orange}

  \coordinate [label=left:\A]
    (A) at ($ (0,0) + .1*(rand,rand) $);
  \coordinate [label=right:\B]
    (B) at ($ (1.25,0.25) + .1*(rand,rand) $);

  \draw [input] (A) -- (B);

  \node [name path=D,help lines,draw,label=left:\D] (D) at (A) [circle through=(B)] {};
  \node [name path=E,help lines,draw,label=right:\E] (E) at (B) [circle through=(A)] {};

  \path [name intersections={of=D and E,by={[label=above:\C]C}}];

  \draw [output] (A) -- (C);
  \draw [output] (B) -- (C);

  \foreach \point in {A,B,C}
    \fill [black,opacity=.5] (\point) circle (2pt);

  \begin{pgfonlayer}{background}
    \fill[triangle!80] (A) -- (C) -- (B) -- cycle;
  \end{pgfonlayer}

  \node [below right,text width=10cm,align=justify] at (4,3)
  {
    \small
    \textbf{命题 I}\par
    
    
      \emph{在给定的\textcolor{input}{有限直线}上构造一个\textcolor{triangle}{等边三角形}。}
      \par
    \vskip1em
    

      设\A\B\ 是给定的\textcolor{input}{有限直线}。要在直线\A\B 上构造一个\textcolor{triangle}{等边三角形}。\vskip1em

  

    以\A\ 为圆心，\A\B\ 为半径描述圆\B\C\D\ 。再以\B\ 为圆心，\B\A\ 为半径描述圆\A\C\E\ 。连接圆相交处\C\ 到点\A\ 和\B\ 的\textcolor{output}{直线}\C\A\ 和\C\B\ 。   \vskip1em

    由于点\A\ 是圆\C\D\B\ 的圆心，因此\A\C\ 等于\A\B。再由于点\B\ 是圆\C\A\E\ 的圆心，因此\B\C\ 等于\B\A。但是已经证明\A\C\ 等于\A\B，因此直线\A\C\ 和\B\C\ 都等于\A\B。而且相等于同一物体的物体也相等，因此\A\C\ 也等于\B\C。因此直线\A\C、\A\B\ 和\B\C\ 三者相等。所以\textcolor{triangle}{三角形}\A\B\C\ 是等边的，它已经在给定的有限\textcolor{input}{直线}\A\B\ 上被构造出来了。

  };
\end{tikzpicture}

% \bigskip
\switchcolumn[0]*%%%%%%%%%%%%
Let us have a look at how Euclid can turn this into \tikzname\ code.
\switchcolumn
现在让我们看看欧几里德如何将其转换为\tikzname\ 代码。

\switchcolumn[0]*%%%%%%%%%%%%
\subsubsection{Setting up the Environment}
\switchcolumn
\subsubsection{设置环境}
\switchcolumn[0]*%%%%%%%%%%%%
As in the previous tutorials, Euclid needs to load \tikzname, together with
some libraries. These libraries are |calc|, |intersections|, |through|, and
|backgrounds|. Depending on which format he uses, Euclid would use one of the
following in the preamble:
\switchcolumn
与之前的教程一样，欧几里德需要加载\tikzname\ ，以及一些库。这些库是|calc|、|intersections|、|through|和|backgrounds|。根据他使用的格式，欧几里德会在导言区使用以下之一：
\switchcolumn[1]\begin{codeexample}[code only]
% For LaTeX:
\usepackage{tikz}
\usetikzlibrary{calc,intersections,through,backgrounds}
\end{codeexample}

\switchcolumn[1]\begin{codeexample}[code only]
% For plain TeX:
\input tikz.tex
\usetikzlibrary{calc,intersections,through,backgrounds}
\end{codeexample}

\switchcolumn[1]\begin{codeexample}[code only]
% For ConTeXt:
\usemodule[tikz]
\usetikzlibrary[calc,intersections,through,backgrounds]
\end{codeexample}

\switchcolumn[0]*%%%%%%%%%%%%
\subsubsection{The Line \emph{AB}}
\switchcolumn
\subsubsection{线段\emph{AB}}
\switchcolumn[0]*%%%%%%%%%%%%
The first part of the picture that Euclid wishes to draw is the line $AB$. That
is easy enough, something like |\draw (0,0) -- (2,1);| might do. However,
Euclid does not wish to reference the two points $A$ and $B$ as $(0,0)$ and
$(2,1)$ subsequently. Rather, he wishes to just write |A| and |B|. Indeed, the
whole point of his book is that the points $A$ and $B$ can be arbitrary and all
other points (like $C$) are constructed in terms of their positions. It would
not do if Euclid were to write down the coordinates of $C$ explicitly.
\switchcolumn
欧几里德希望绘制的图片的第一部分是线段$AB$。这很容易，像|\draw (0,0) -- (2,1);|这样的代码可能就可以了。然而，欧几里德不希望在后续引用点$A$和$B$时使用$(0,0)$和$(2,1)$。相反，他希望只写|A|和|B|。实际上，他的整个观点是点$A$和$B$可以是任意的，而所有其他点（如$C$）都是基于它们的位置构造的。如果欧几里德明确写下$C$的坐标，那就不太好了。

\switchcolumn[0]*%%%%%%%%%%%%
So, Euclid starts with defining two coordinates using the |\coordinate|
command:
\switchcolumn
因此，欧几里德开始使用|\coordinate|命令定义两个坐标：
\switchcolumn[0]*%%%%%%%%%%%%
\begin{dispExample*}{sidebyside}
\begin{tikzpicture}
  \coordinate (A) at (0,0);
  \coordinate (B) at (1.25,0.25);

  \draw[blue] (A) -- (B);
\end{tikzpicture}

\end{dispExample*}
\switchcolumn
\begin{dispExample*}{sidebyside}
\begin{tikzpicture}
  \coordinate (A) at (0,0);
  \coordinate (B) at (1.25,0.25);

  \draw[blue] (A) -- (B);
\end{tikzpicture}

\end{dispExample*}

\switchcolumn[0]*%%%%%%%%%%%%
That was easy enough. What is missing at this point are the labels for the
coordinates. Euclid does not want them \emph{on} the points, but next to them.
He decides to use the |label| option:
\switchcolumn
这很简单。这时还缺少坐标的标签。欧几里德不希望它们在点上，而是在点旁边。他决定使用|label|选项：
%
\switchcolumn[0]*%%%%%%%%%%%%
\begin{dispExample*}{sidebyside,lefthand ratio=0.8}
\begin{tikzpicture}
  \coordinate [label=left:\textcolor{blue}{$A$}]  (A) at (0,0);
  \coordinate [label=right:\textcolor{blue}{$B$}] (B) at (1.25,0.25);

  \draw[blue] (A) -- (B);
\end{tikzpicture}

\end{dispExample*}
\switchcolumn
\begin{dispExample*}{sidebyside,lefthand ratio=0.8}
\begin{tikzpicture}
  \coordinate [label=left:\textcolor{blue}{$A$}]  (A) at (0,0);
  \coordinate [label=right:\textcolor{blue}{$B$}] (B) at (1.25,0.25);

  \draw[blue] (A) -- (B);
\end{tikzpicture}

\end{dispExample*}

\switchcolumn[0]*%%%%%%%%%%%%
At this point, Euclid decides that it would be even nicer if the points $A$ and
$B$ were in some sense ``random''. Then, neither Euclid nor the reader can make
the mistake of taking ``anything for granted'' concerning these position of
these points. Euclid is pleased to learn that there is a |rand| function in
\tikzname\ that does exactly what he needs: It produces a number between $-1$
and $1$. Since \tikzname\ can do a bit of math, Euclid can change the
coordinates of the points as follows:
\switchcolumn
此时，欧几里德认为如果点$A$和$B$在某种意义上是“随机的”会更好。这样，欧几里德和读者都不会错误地将这些点的位置视为“理所当然”。欧几里德很高兴得知\tikzname\ 中有一个|rand|函数正好可以满足他的需求：它会生成一个介于$-1$和$1$之间的数字。由于\tikzname\ 可以进行一些数学计算，欧几里德可以按如下方式更改点的坐标：
\switchcolumn[1]\begin{codeexample}[code only]
\coordinate [...] (A) at (0+0.1*rand,0+0.1*rand);
\coordinate [...] (B) at (1.25+0.1*rand,0.25+0.1*rand);
\end{codeexample}

\switchcolumn[0]*%%%%%%%%%%%%
This works fine. However, Euclid is not quite satisfied since he would prefer
that the ``main coordinates'' $(0,0)$ and $(1.25,0.25)$ are ``kept separate''
from the perturbation $0.1(\mathit{rand},\mathit{rand})$. This means, he would
like to specify that coordinate $A$ as ``the point that is at $(0,0)$ plus one
tenth of the vector  $(\mathit{rand},\mathit{rand})$''.
\switchcolumn
这样做很好。然而，欧几里德并不完全满意，因为他更希望“主要坐标”$(0,0)$和$(1.25,0.25)$与扰动$0.1(\mathit{rand},\mathit{rand})$“保持分离”。这意味着，他希望将坐标$A$指定为“位于$(0,0)$加上向量$(\mathit{rand},\mathit{rand})$的十分之一”的点。
\switchcolumn[0]*%%%%%%%%%%%%
It turns out that the |calc| library allows him to do exactly this kind of
computation. When this library is loaded, you can use special coordinates that
start with |($| and end with |$)| rather than just |(| and~|)|. Inside these
special coordinates you can give a linear combination of coordinates. (Note
that the dollar signs are only intended to signal that a ``computation'' is
going on; no mathematical typesetting is done.)
\switchcolumn
事实证明，|calc|库允许他进行这种计算。当加载了该库后，您可以使用以|($|开头，以|$)|结尾的特殊坐标，而不是只使用|(|和~|)|。在这些特殊坐标内，您可以给出坐标的线性组合。（请注意，美元符号仅用于表示正在进行“计算”，而不进行数学排版。）
\switchcolumn[0]*%%%%%%%%%%%%
The new code for the coordinates is the following:
\switchcolumn
坐标的新代码如下：
%
\switchcolumn[1]\begin{codeexample}[code only]
\coordinate [...] (A) at ($ (0,0) + .1*(rand,rand) $);
\coordinate [...] (B) at ($ (1.25,0.25) + .1*(rand,rand) $);
\end{codeexample}
\switchcolumn[0]*%%%%%%%%%%%%
Note that if a coordinate in such a computation has a factor (like |.1|), you
must place a |*| directly before the opening parenthesis of the coordinate. You
can nest such computations.
\switchcolumn
请注意，如果计算中的坐标具有因子（如|.1|），则必须在坐标的开括号之前直接放置|*|。您可以嵌套这样的计算。

\switchcolumn[0]*%%%%%%%%%%%%
\subsubsection{The Circle Around \emph{A}}
\switchcolumn
\subsubsection{以\emph{A}为圆心的圆}
\switchcolumn[0]*%%%%%%%%%%%%
The first tricky construction is the circle around~$A$. We will see later how
to do this in a very simple manner, but first let us do it the ``hard'' way.
\switchcolumn
构造中的第一个棘手部分是以$A$为圆心的圆。稍后我们将看到如何以非常简单的方式完成此操作，但首先让我们用“困难”的方式来做。
\switchcolumn[0]*%%%%%%%%%%%%
The idea is the following: We draw a circle around the point $A$ whose radius
is given by the length of the line $AB$. The difficulty lies in computing the
length of this line.
\switchcolumn
思路如下：我们绘制以点$A$为圆心的圆，半径由线段$AB$的长度确定。困难在于计算这条线的长度。
\switchcolumn[0]*%%%%%%%%%%%%
Two ideas ``nearly'' solve this problem: First, we can write |($ (A) - (B) $)|
for the vector that is the difference between $A$ and~$B$. All we need is the
length of this vector. Second, given two numbers $x$ and $y$, one can write
|veclen(|$x$|,|$y$|)| inside a mathematical expression. This gives the value
$\sqrt{x^2+y^2}$, which is exactly the desired length.
\switchcolumn
有两个“几乎”解决这个问题的思路：首先，我们可以用|($ (A) - (B) $)|来表示向量$A$和$B$之间的差。我们只需要这个向量的长度。其次，对于给定的两个数$x$和$y$，可以在数学表达式中使用|veclen(|$x$|,|$y$|)|。这给出了值$\sqrt{x^2+y^2}$，正好是所需的长度。
\switchcolumn[0]*%%%%%%%%%%%%
The only remaining problem is to access the $x$- and $y$-coordinate of the
vector~$AB$. For this, we need a new concept: the \emph{let operation}. A let
operation can be given anywhere on a path where a normal path operation like a
line-to or a move-to is expected. The effect of a let operation is to evaluate
some coordinates and to assign the results to special macros. These macros make
it easy to access the $x$- and $y$-coordinates of the coordinates.
\switchcolumn
唯一剩下的问题是如何访问向量$AB$的$x$坐标和$y$坐标。为此，我们需要一个新概念：let操作。let操作可以在期望普通路径操作（如画线或移动）的任何路径上进行。let操作的效果是计算一些坐标并将结果分配给特殊的宏。这些宏使得可以轻松地访问坐标的$x$坐标和$y$坐标。
\switchcolumn[0]*%%%%%%%%%%%%
Euclid would write the following:
\switchcolumn
欧几里德会写下以下内容：
\switchcolumn[0]*%%%%%%%%%%%%
\begin{dispExample*}{sidebyside}
% \usetikzlibrary{calc}
\begin{tikzpicture}
  \coordinate [label=left:$A$]  (A) at (0,0);
  \coordinate [label=right:$B$] (B) at (1.25,0.25);
  \draw (A) -- (B);

  \draw (A) let
              \p1 = ($ (B) - (A) $)
            in
              circle ({veclen(\x1,\y1)});
\end{tikzpicture}
\end{dispExample*}
\switchcolumn
\begin{dispExample*}{sidebyside,lefthand ratio=0.7}
% \usetikzlibrary{calc}
\begin{tikzpicture}
  \coordinate [label=left:$A$]  (A) at (0,0);
  \coordinate [label=right:$B$] (B) at (1.25,0.25);
  \draw (A) -- (B);

  \draw (A) let
              \p1 = ($ (B) - (A) $)
            in
              circle ({veclen(\x1,\y1)});
\end{tikzpicture}
\end{dispExample*}

% \begin{codeexample}[preamble={\usetikzlibrary{calc}}]
% \begin{tikzpicture}
%   \coordinate [label=left:$A$]  (A) at (0,0);
%   \coordinate [label=right:$B$] (B) at (1.25,0.25);
%   \draw (A) -- (B);

%   \draw (A) let
%               \p1 = ($ (B) - (A) $)
%             in
%               circle ({veclen(\x1,\y1)});
% \end{tikzpicture}
% \end{codeexample}

\switchcolumn[0]*%%%%%%%%%%%%
Each assignment in a let operation starts with |\p|, usually followed by a
\meta{digit}. Then comes an equal sign and a coordinate. The coordinate is
evaluated and the result is stored internally. From then on you can use the
following expressions:
\switchcolumn
let操作中的每个赋值都以|\p|开头，通常后面跟着一个\meta{数字}。然后是等号和一个坐标。计算该坐标并将结果存储在内部。从那时起，您可以使用以下表达式：
\end{paracol}

\begin{enumerate}
\columnratio{0.55}
\begin{paracol}{2}
\item |\x|\meta{digit} yields the $x$-coordinate of the resulting point.
\switchcolumn
\item     |\x|\meta{数字}给出结果点的$x$坐标。
\switchcolumn[0]*%%%%%%%%%%%%
\item |\y|\meta{digit} yields the $y$-coordinate of the resulting point.
\switchcolumn
\item     |\y|\meta{数字}给出结果点的$y$坐标。
\switchcolumn[0]*%%%%%%%%%%%%
\item |\p|\meta{digit} yields the same as
|\x|\meta{digit}|,\y|\meta{digit}.
\switchcolumn
\item 
|\p|\meta{数字}给出与|\x|\meta{数字}|,\y|\meta{数字}相同的结果。
\end{paracol}
\end{enumerate}


\columnratio{0.55}
\begin{paracol}{2}
%
You can have multiple assignments in a let operation, just separate them with
commas. In later assignments you can already use the results of earlier
assignments.

在let操作中可以有多个赋值，只需用逗号分隔它们。在后续赋值中，您已经可以使用前面赋值的结果。

Note that |\p1| is not a coordinate in the usual sense. Rather, it just expands
to a string like |10pt,20pt|. So, you cannot write, for instance,
|(\p1.center)| since this would just expand to |(10pt,20pt.center)|, which
makes no sense.

请注意，|\p1|不是通常意义上的坐标。它只是扩展为类似于|10pt,20pt|的字符串。因此，您不能写，例如，|(\p1.center)|，因为这将只扩展为|(10pt,20pt.center)|，这是没有意义的。

Next, we want to draw both circles at the same time. Each time the radius is
|veclen(\x1,\y1)|. It seems natural to compute this radius only once. For this,
we can also use a let operation: Instead of writing |\p1 = ...|, we write
|\n2 = ...|. Here, ``n'' stands for ``number'' (while ``p'' stands for
``point''). The assignment of a number should be followed by a number in curly
braces.

接下来，我们要在计算中仅计算一次长度为|veclen(\x1,\y1)|的半径，然后绘制两个圆。对此，我们还可以使用let操作：与其写|\p1 = ...|，我们写成|\n2 = ...|。在这里，“n”代表“数字”（而“p”代表“点”）。数字的赋值后面应跟一个花括号中的数字。

\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \coordinate [label=left:$A$]  (A) at (0,0);
  \coordinate [label=right:$B$] (B) at (1.25,0.25);
  \draw (A) -- (B);

  \draw let \p1 = ($ (B) - (A) $),
            \n2 = {veclen(\x1,\y1)}
        in
          (A) circle (\n2)
          (B) circle (\n2);
\end{tikzpicture}
\end{codeexample}
%
In the above example, you may wonder, what |\n1| would yield? The answer is
that it would be undefined -- the |\p|, |\x|, and |\y| macros refer to the same
logical point, while the |\n| macro has ``its own namespace''. We could even
have replaced |\n2| in the example by |\n1| and it would still work. Indeed,
the digits following these macros are just normal \TeX\ parameters. We could
also use a longer name, but then we have to use curly braces:

在上面的示例中，您可能想知道|\n1|会得到什么结果？答案是它将是未定义的——|\p|、|\x|和|\y|宏引用相同的逻辑点，而|\n|宏具有“自己的命名空间”。实际上，在示例中我们甚至可以将|\n2|替换为|\n1|，它仍然可以工作。事实上，这些宏后面的数字只是正常的\TeX 参数。我们也可以使用更长的名称，但是我们必须使用花括号：
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \coordinate [label=left:$A$]  (A) at (0,0);
  \coordinate [label=right:$B$] (B) at (1.25,0.25);
  \draw (A) -- (B);

  \draw let \p1        = ($ (B) - (A) $),
            \n{radius} = {veclen(\x1,\y1)}
        in
          (A) circle (\n{radius})
          (B) circle (\n{radius});
\end{tikzpicture}
\end{codeexample}

At the beginning of this section it was promised that there is an easier way to
create the desired circle. The trick is to use the |through| library. As the
name suggests, it contains code for creating shapes that go through a given
point.

在本节开始时，承诺有一种更简单的方法来创建所需的圆。诀窍是使用|through|库。顾名思义，它包含用于通过给定点的形状创建的代码。

The option that we are looking for is |circle through|. This option is given to
a \emph{node} and has the following effects: First, it causes the node's inner
and outer separations to be set to zero. Then it sets the shape of the node to
|circle|. Finally, it sets the radius of the node such that it goes through the
parameter given to |circle through|. This radius is computed in essentially the
same way as above.

我们要寻找的选项是|circle through|。此选项应用于一个\emph{节点}，并具有以下效果：首先，它将节点的内部和外部间隔设置为零。然后，它将节点的形状设置为|circle|。最后，它设置节点的半径，使其通过给定的参数。该半径的计算方式与上面完全相同。
%
\begin{codeexample}[preamble={\usetikzlibrary{through}}]
\begin{tikzpicture}
  \coordinate [label=left:$A$]  (A) at (0,0);
  \coordinate [label=right:$B$] (B) at (1.25,0.25);
  \draw (A) -- (B);

  \node [draw,circle through=(B),label=left:$D$] at (A) {};
\end{tikzpicture}
\end{codeexample}



\subsubsection{The Intersection of the Circles\\圆的相交}

Euclid can now draw the line and the circles. The final problem is to compute
the intersection of the two circles. This computation is a bit involved if you
want to do it ``by hand''. Fortunately, the |intersections| library allows us
to compute the intersection of arbitrary paths.

欧几里德现在可以绘制线段和圆。最后一个问题是计算两个圆的相交点。如果要手动计算，这个计算会有一些复杂。幸运的是，|intersections|库允许我们计算任意路径的交点。

The idea is simple: First, you ``name'' two paths using the |name path| option.
Then, at some later point, you can use the option |name intersections|, which
creates coordinates called |intersection-1|, |intersection-2|, and so on at all
intersections of the paths. Euclid assigns the names |D| and |E| to the paths
of the two circles (which happen to be the same names as the nodes themselves,
but nodes and their paths live in different ``namespaces'').
%

思路很简单：首先，使用|name path|选项“命名”两条路径。然后，在稍后的某个时间点，可以使用|name intersections|选项，它在路径的所有交点处创建名为|intersection-1|、|intersection-2|等的坐标。欧几里德将路径的路径命名为|D|和|E|（恰好与节点本身的名称相同，但节点和它们的路径位于不同的“命名空间”中）。
\begin{codeexample}[preamble={\usetikzlibrary{intersections,through}}]
\begin{tikzpicture}
  \coordinate [label=left:$A$]  (A) at (0,0);
  \coordinate [label=right:$B$] (B) at (1.25,0.25);
  \draw (A) -- (B);

  \node (D) [name path=D,draw,circle through=(B),label=left:$D$]  at (A) {};
  \node (E) [name path=E,draw,circle through=(A),label=right:$E$] at (B) {};

  % Name the coordinates, but do not draw anything:
  \path [name intersections={of=D and E}];

  \coordinate [label=above:$C$] (C) at (intersection-1);

  \draw [red] (A) -- (C);
  \draw [red] (B) -- (C);
\end{tikzpicture}
\end{codeexample}

It turns out that this can be further shortened: The |name intersections| takes
an optional argument |by|, which lets you specify names for the coordinates and
options for them. This creates more compact code. Although Euclid does not need
it for the current picture, it is just a small step to computing the bisection
of the line $AB$:
%

事实证明，这可以进一步简化：|name intersections|还接受一个可选参数|by|，可以让您指定坐标的名称和选项。这样可以创建更紧凑的代码。尽管欧几里德不需要当前图片的这个功能，但计算线段$AB$的平分线只是一个小小的步骤：
\begin{codeexample}[preamble={\usetikzlibrary{intersections,through}}]
\begin{tikzpicture}
  \coordinate [label=left:$A$]  (A) at (0,0);
  \coordinate [label=right:$B$] (B) at (1.25,0.25);
  \draw [name path=A--B] (A) -- (B);

  \node (D) [name path=D,draw,circle through=(B),label=left:$D$]  at (A) {};
  \node (E) [name path=E,draw,circle through=(A),label=right:$E$] at (B) {};

  \path [name intersections={of=D and E, by={[label=above:$C$]C, [label=below:$C'$]C'}}];

  \draw [name path=C--C',red] (C) -- (C');

  \path [name intersections={of=A--B and C--C',by=F}];
  \node [fill=red,inner sep=1pt,label=-45:$F$] at (F) {};
\end{tikzpicture}
\end{codeexample}



\subsubsection{The Complete Code\\完整代码}

Back to Euclid's code. He introduces a few macros to make life simpler, like a
|\A| macro for typesetting a blue $A$. He also uses the |background| layer for
drawing the triangle behind everything at the end.

回到欧几里德的代码。他引入了一些宏来简化生活，比如一个用于排版蓝色$A$的|\A|宏。他还在最后使用了|background|层来绘制三角形。
%
\begin{codeexample}[pre={\pgfmathsetseed{1}},preamble={\usetikzlibrary{backgrounds,calc,intersections,through}}]
\begin{tikzpicture}[thick,help lines/.style={thin,draw=black!50}]
  \def\A{\textcolor{input}{$A$}}     \def\B{\textcolor{input}{$B$}}
  \def\C{\textcolor{output}{$C$}}    \def\D{$D$}
  \def\E{$E$}

  \colorlet{input}{blue!80!black}    \colorlet{output}{red!70!black}
  \colorlet{triangle}{orange}

  \coordinate [label=left:\A]  (A) at ($ (0,0) + .1*(rand,rand) $);
  \coordinate [label=right:\B] (B) at ($ (1.25,0.25) + .1*(rand,rand) $);

  \draw [input] (A) -- (B);

  \node [name path=D,help lines,draw,label=left:\D]   (D) at (A) [circle through=(B)] {};
  \node [name path=E,help lines,draw,label=right:\E]  (E) at (B) [circle through=(A)] {};

  \path [name intersections={of=D and E,by={[label=above:\C]C}}];

  \draw [output] (A) -- (C) -- (B);

  \foreach \point in {A,B,C}
    \fill [black,opacity=.5] (\point) circle (2pt);

  \begin{pgfonlayer}{background}
    \fill[triangle!80] (A) -- (C) -- (B) -- cycle;
  \end{pgfonlayer}

  \node [below right, text width=10cm,align=justify] at (4,3) {
    \small\textbf{Proposition I}\par
    \emph{To construct an \textcolor{triangle}{equilateral triangle}
      on a given \textcolor{input}{finite straight line}.}
    \par\vskip1em
    Let \A\B\ be the given \textcolor{input}{finite straight line}.  \dots
  };
\end{tikzpicture}
\end{codeexample}


\subsection{Book I, Proposition II\\第一卷，命题二}

The second proposition in the Elements is the following:

《几何原本》中的第二个命题如下：

\bigskip\noindent
\begin{tikzpicture}[thick,help lines/.style={thin,draw=black!50}]
  \pgfmathsetseed{1}
  \def\A{\textcolor{orange}{$A$}}   \def\B{\textcolor{input}{$B$}}
  \def\C{\textcolor{input}{$C$}}    \def\D{$D$}
  \def\E{$E$}                       \def\F{$F$}
  \def\G{$G$}                       \def\H{$H$}
  \def\K{$K$}                       \def\L{\textcolor{output}{$L$}}

  \colorlet{input}{blue!80!black}    \colorlet{output}{red!70!black}

  \coordinate [label=left:\A]  (A) at ($ (0,0) + .1*(rand,rand) $);
  \coordinate [label=right:\B] (B) at ($ (1,0.2) + .1*(rand,rand) $);
  \coordinate [label=above:\C] (C) at ($ (1,2) + .1*(rand,rand) $);

  \draw [input] (B) -- (C);
  \draw [help lines] (A) -- (B);

  \coordinate [label=above:\D] (D) at ($ (A)!.5!(B) ! {sin(60)*2} ! 90:(B) $);

  \draw [help lines] (D) -- ($ (D)!3.75!(A) $) coordinate [label=-135:\E] (E);
  \draw [help lines] (D) -- ($ (D)!3.75!(B) $) coordinate [label=-45:\F] (F);

  \node (H) at (B) [name path=H,help lines,circle through=(C),draw,label=135:\H] {};
  \path [name path=B--F] (B) -- (F);
  \path [name intersections={of=H and B--F}]
    coordinate [label=right:\G] (G) at (intersection-1);

  \node (K) at (D) [name path=K,help lines,circle through=(G),draw,label=135:\K] {};

  \path [name path=A to E line] (A) -- (E);
  \path [name intersections={of=K and A to E line}]
    coordinate [label=below:\L] (L) at (intersection-1);

  \draw [output] (A) -- (L);

  \foreach \point in {A,B,C,D,G,L}
    \fill [black,opacity=.5] (\point) circle (2pt);

  \node [below right, text width=9cm,align=justify] at (4,4) {
    \small\textbf{Proposition II\hfill 命题二}\par\parindent=2em
    \emph{To place a \textcolor{output}{straight line} equal to a
      given \textcolor{input}{straight line} with
      one end at a \textcolor{orange}{given point}.}
    
      \emph{在一端位于\textcolor{orange}{给定点}的前提下，将一条与给定\textcolor{input}{直线}等长的\textcolor{output}{直线}放置在一点上。}

      \par\vskip1em
    Let \A\ be the given point, and \B\C\ the given
    \textcolor{input}{straight line}.
    It is required to place a \textcolor{output}{straight line} equal
    to the given \textcolor{input}{straight line} \B\C\ with one end
    at the point~\A.

    设\A\ 是给定点，\B\C\ 是给定的\textcolor{input}{直线}。
    要求在点\A\ 的一端放置一条与给定的\textcolor{input}{直线}\B\C\ 等长的\textcolor{output}{直线}。



    Join the straight line \A\B\ from the point \A\ to the point \B, and
    construct the equilateral triangle \D\A\B\ on it.

    从点\A\ 到点\B\ 画直线\A\B\ ，并在其上构造等边三角形\D\A\B\ 。

    Produce the straight lines \A\E\ and \B\F\ in a straight line with
    \D\A\ and \D\B. Describe the circle \C\G\H\ with center \B\ and
    radius \B\C, and  again, describe the circle \G\K\L\ with center
    \D\ and radius \D\G.

    沿着\D\A\ 和\D\B\ 在一条直线上延伸直线\A\E\ 和\B\F\ 。以\B\ 为圆心、\B\C\ 为半径画圆\C\G\H\ ，再以\D\ 为圆心、\D\G\ 为半径画圆\G\K\L\ 。


    Since the point \B\ is the center of the circle \C\G\H, therefore
    \B\C\ equals \B\G. Again, since the point \D\ is the center of the
    circle \G\K\L, therefore \D\L\ equals \D\G. And in these \D\A\
    equals \D\B, therefore the remainder \A\L\ equals the remainder
    \B\G. But \B\C\ was also proved  equal to \B\G, therefore each of
    the straight lines \A\L\ and \B\C\ equals \B\G. And things which
    equal the same thing also equal one another, therefore \A\L\ also
    equals \B\C.

    由于点\B\ 是圆\C\G\H\ 的圆心，所以\B\C\ 等于\B\G 。同样，由于点\D\ 是圆\G\K\L\ 的圆心，所以\D\L\ 等于\D\G 。而且在这些线段中\D\A\ 等于\D\B ，因此剩余的\A\L\ 等于剩余的\B\G 。但是\B\C\ 也被证明等于\B\G ，因此直线\A\L\ 和\B\C\ 都等于\B\G 。而且等于同一物体的物体也等于彼此，因此\A\L\ 也等于\B\C 。


    Therefore the \textcolor{output}{straight line} \A\L\ equal to the
    given \textcolor{input}{straight line} \B\C\  has been placed with
    one end at the \textcolor{orange}{given point}~\A.

    因此，已经在点\A\ 的一端放置了与给定的\textcolor{input}{直线}\B\C\ 等长的\textcolor{output}{直线}。
  };
\end{tikzpicture}


\subsubsection{Using Partway Calculations for the Construction of \emph{D}\\使用partway计算构造点\emph{D}}

Euclid's construction starts with ``referencing'' Proposition~I for the
construction of the point~$D$. Now, while we could simply repeat the
construction, it seems a bit bothersome that one has to draw all these circles
and do all these complicated constructions.

欧几里德的构造始于引用命题I来构造点$D$。虽然我们可以简单地重复构造过程，但是必须画出所有这些圆并进行所有这些复杂的构造，这似乎有些麻烦。

For this reason, \tikzname\ supports some simplifications. First, there is a
simple syntax for computing a point that is ``partway'' on a line from $p$
to~$q$: You place these two points in a coordinate calculation -- remember,
they start with |($| and end with |$)| -- and then combine them using
|!|\meta{part}|!|. A \meta{part} of |0| refers to the \emph{first} coordinate,
a \meta{part} of |1| refers to the second coordinate, and a value in between
refers to a point on the line from $p$ to~$q$. Thus, the syntax is similar to
the |xcolor| syntax for mixing colors.

出于这个原因，\tikzname\ 支持一些简化。首先，对于计算位于$p$和$q$之间的“部分位置”的点，有一种简单的语法：您可以在坐标计算中放置这两个点——记住，它们以|($|开头，以|$)|结尾——然后使用|!|\meta{部分}|!|将它们组合起来。部分的值为0表示第一个坐标，部分的值为1表示第二个坐标，介于两者之间的值表示位于$p$和$q$之间的点。因此，语法与|xcolor|混合颜色的语法类似。


Here is the computation of the point in the middle of the line $AB$:

以下是计算线段$AB$中点的代码：
%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \coordinate [label=left:$A$]  (A) at (0,0);
  \coordinate [label=right:$B$] (B) at (1.25,0.25);
  \draw (A) -- (B);
  \node [fill=red,inner sep=1pt,label=below:$X$] (X) at ($ (A)!.5!(B) $) {};
\end{tikzpicture}
\end{codeexample}

The computation of the point $D$ in Euclid's second proposition is a bit more
complicated. It can be expressed as follows: Consider the line from $X$ to $B$.
Suppose we rotate this line around $X$ for 90$^\circ$ and then stretch it by a
factor of $\sin(60^\circ) \cdot 2$. This yields the desired point~$D$. We can
do the stretching using the partway modifier above, for the rotation we need a
new modifier: the rotation modifier. The idea is that the second coordinate in
a partway computation can be prefixed by an angle. Then the partway point is
computed normally (as if no angle were given), but the resulting point is
rotated by this angle around the first point.
%

点$D$的计算稍微复杂一些。可以这样表达：考虑从$X$到$B$的直线。假设我们将该直线绕$X$旋转90$^\circ$，然后将其拉伸一个因子$\sin(60^\circ) \cdot 2$。这样就得到了所需的点$D$。我们可以使用上面的部分计算来进行拉伸，对于旋转，我们需要一个新的修饰符：旋转修饰符。其思想是在部分计算中，第二个坐标可以加上一个角度前缀。然后，部分计算点会正常计算（就好像没有给定角度），但是结果点会围绕第一个点旋转该角度。

\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \coordinate [label=left:$A$]  (A) at (0,0);
  \coordinate [label=right:$B$] (B) at (1.25,0.25);
  \draw (A) -- (B);
  \node [fill=red,inner sep=1pt,label=below:$X$] (X) at ($ (A)!.5!(B) $) {};
  \node [fill=red,inner sep=1pt,label=above:$D$] (D) at
    ($ (X) ! {sin(60)*2} ! 90:(B) $) {};
  \draw (A) -- (D) -- (B);
\end{tikzpicture}
\end{codeexample}

Finally, it is not necessary to explicitly name the point $X$. Rather, again
like in the |xcolor| package, it is possible to chain partway modifiers:

最后，不需要显式命名点$X$。与|xcolor|包一样，可以链式使用部分计算修饰符：

%
\begin{codeexample}[preamble={\usetikzlibrary{calc}}]
\begin{tikzpicture}
  \coordinate [label=left:$A$]  (A) at (0,0);
  \coordinate [label=right:$B$] (B) at (1.25,0.25);
  \draw (A) -- (B);
  \node [fill=red,inner sep=1pt,label=above:$D$] (D) at
    ($ (A) ! .5 ! (B) ! {sin(60)*2} ! 90:(B) $) {};
  \draw (A) -- (D) -- (B);
\end{tikzpicture}
\end{codeexample}



\subsubsection{Intersecting a Line and a Circle\\直线和圆的相交}

The next step in the construction is to draw a circle around $B$ through $C$,
which is easy enough to do using the |circle through| option. Extending the
lines $DA$ and $DB$ can be done using partway calculations, but this time with
a part value outside the range $[0,1]$:

构造中的下一步是通过$C$绘制以$B$为圆心的圆，使用|circle through|选项非常容易实现。使用部分计算可以延长线段$DA$和$DB$，但这次使用超出范围$[0,1]$的部分值：
%
\begin{codeexample}[preamble={\usetikzlibrary{calc,through}}]
\begin{tikzpicture}
  \coordinate [label=left:$A$]  (A) at (0,0);
  \coordinate [label=right:$B$] (B) at (0.75,0.25);
  \coordinate [label=above:$C$] (C) at (1,1.5);
  \draw (A) -- (B) -- (C);
  \coordinate [label=above:$D$] (D) at
    ($ (A) ! .5 ! (B) ! {sin(60)*2} ! 90:(B) $) {};
  \node (H) [label=135:$H$,draw,circle through=(C)] at (B) {};
  \draw (D) -- ($ (D) ! 3.5 ! (B) $) coordinate [label=below:$F$] (F);
  \draw (D) -- ($ (D) ! 2.5 ! (A) $) coordinate [label=below:$E$] (E);
\end{tikzpicture}
\end{codeexample}

We now face the problem of finding the point $G$, which is the intersection of
the line $BF$ and the circle $H$. One way is to use yet another variant of the
partway computation: Normally, a partway computation has the form
\meta{p}|!|\meta{factor}|!|\meta{q}, resulting in the point
$(1-\meta{factor})\meta{p} + \meta{factor}\meta{q}$. Alternatively, instead of
\meta{factor} you can also use a \meta{dimension} between the points. In this
case, you get the point that is \meta{dimension} away from \meta{p} on the
straight line to \meta{q}.

现在我们面临的问题是找到点$G$，它是线段$BF$和圆$H$的交点。一种方法是使用部分计算的另一种变体：通常，部分计算的形式是\meta{p}|!|\meta{factor}|!|\meta{q}，得到的点是$(1-\meta{factor})\meta{p} + \meta{factor}\meta{q}$。或者，您还可以使用\meta{dimension}代替\meta{factor}，在这种情况下，您将得到一个离\meta{p}在指向\meta{q}的直线上\meta{dimension}距离的点。

We know that the point $G$ is on the way from $B$ to $F$. The distance is given
by the radius of the circle~$H$. Here is the code for computing $H$:

我们知道点$G$位于$B$到$F$的路径上。距离由圆$H$的半径给出。以下是计算点$G$的代码：
%
{\ifpgfmanualexternalize\tikzexternaldisable\fi
\begin{codeexample}[
    preamble={\usetikzlibrary{calc,through}},
    pre={\begin{tikzpicture}
  \coordinate [label=left:$A$]  (A) at (0,0);
  \coordinate [label=right:$B$] (B) at (0.75,0.25);
  \coordinate [label=above:$C$] (C) at (1,1.5);
  \draw (A) -- (B) -- (C);
  \coordinate [label=above:$D$] (D) at
    ($ (A) ! .5 ! (B) ! {sin(60)*2} ! 90:(B) $) {};
  \draw (D) -- ($ (D) ! 3.5 ! (B) $) coordinate [label=below:$F$] (F);
  \draw (D) -- ($ (D) ! 2.5 ! (A) $) coordinate [label=below:$E$] (E);},
    post={\end{tikzpicture}},
]
  \node (H) [label=135:$H$,draw,circle through=(C)] at (B) {};
  \path let \p1 = ($ (B) - (C) $) in
    coordinate [label=left:$G$] (G) at ($ (B) ! veclen(\x1,\y1) ! (F) $);
  \fill[red,opacity=.5] (G) circle (2pt);
\end{codeexample}

However, there is a simpler way: We can simply name the path of the circle and
of the line in question and then use |name intersections| to compute the
intersections.

然而，有一个更简单的方法：我们只需为圆和线条命名路径，然后使用|name intersections|来计算交点。
%
\begin{codeexample}[
    preamble={\usetikzlibrary{calc,intersections,through}},
    pre={\begin{tikzpicture}
  \coordinate [label=left:$A$]  (A) at (0,0);
  \coordinate [label=right:$B$] (B) at (0.75,0.25);
  \coordinate [label=above:$C$] (C) at (1,1.5);
  \draw (A) -- (B) -- (C);
  \coordinate [label=above:$D$] (D) at
    ($ (A) ! .5 ! (B) ! {sin(60)*2} ! 90:(B) $) {};
  \draw (D) -- ($ (D) ! 3.5 ! (B) $) coordinate [label=below:$F$] (F);
  \draw (D) -- ($ (D) ! 2.5 ! (A) $) coordinate [label=below:$E$] (E);},
    post={\end{tikzpicture}},
]
  \node (H) [name path=H,label=135:$H$,draw,circle through=(C)] at (B) {};
  \path [name path=B--F] (B) -- (F);
  \path [name intersections={of=H and B--F,by={[label=left:$G$]G}}];
  \fill[red,opacity=.5] (G) circle (2pt);
\end{codeexample}
}%


\subsubsection{The Complete Code\\完整代码}

\begin{codeexample}[pre={\pgfmathsetseed{1}},preamble={\usetikzlibrary{calc,intersections,through}}]
\begin{tikzpicture}[thick,help lines/.style={thin,draw=black!50}]
  \def\A{\textcolor{orange}{$A$}}   \def\B{\textcolor{input}{$B$}}
  \def\C{\textcolor{input}{$C$}}    \def\D{$D$}
  \def\E{$E$}                       \def\F{$F$}
  \def\G{$G$}                       \def\H{$H$}
  \def\K{$K$}                       \def\L{\textcolor{output}{$L$}}

  \colorlet{input}{blue!80!black}    \colorlet{output}{red!70!black}

  \coordinate [label=left:\A]  (A) at ($ (0,0) + .1*(rand,rand) $);
  \coordinate [label=right:\B] (B) at ($ (1,0.2) + .1*(rand,rand) $);
  \coordinate [label=above:\C] (C) at ($ (1,2) + .1*(rand,rand) $);

  \draw [input] (B) -- (C);
  \draw [help lines] (A) -- (B);

  \coordinate [label=above:\D] (D) at ($ (A)!.5!(B) ! {sin(60)*2} ! 90:(B) $);

  \draw [help lines] (D) -- ($ (D)!3.75!(A) $) coordinate [label=-135:\E] (E);
  \draw [help lines] (D) -- ($ (D)!3.75!(B) $) coordinate [label=-45:\F] (F);

  \node (H) at (B) [name path=H,help lines,circle through=(C),draw,label=135:\H] {};
  \path [name path=B--F] (B) -- (F);
  \path [name intersections={of=H and B--F,by={[label=right:\G]G}}];

  \node (K) at (D) [name path=K,help lines,circle through=(G),draw,label=135:\K] {};
  \path [name path=A--E] (A) -- (E);
  \path [name intersections={of=K and A--E,by={[label=below:\L]L}}];

  \draw [output] (A) -- (L);

  \foreach \point in {A,B,C,D,G,L}
    \fill [black,opacity=.5] (\point) circle (2pt);

  % \node ...
\end{tikzpicture}
\end{codeexample}
