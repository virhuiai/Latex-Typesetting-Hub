%%^^A%%  fontspec-doc-enc.tex -- part of FONTSPEC <wspr.io/fontspec>

\documentclass[a4paper]{l3doc}
\usepackage{fontspec-doc-style}
\showexamplesfalse
\begin{document}

\part{Commands for accents and symbols (`encodings')\\重音和符号命令（“编码”）}
\label{part:enc}

\textbf{The functionality described in this section is experimental.\\本节所描述的功能是实验性的。}

In the pre-Unicode era, significant work was required by \LaTeX\ to ensure that
input characters in the source could be interpreted correctly depending on file encoding,
and that glyphs in the output were selected correctly depending on the font encoding.
With Unicode, we have the luxury of a single file and font encoding that is used for both input
and output.

在 Unicode 时代之前，\LaTeX\ 需要做大量工作来确保源代码中的输入字符能够根据文件编码正确解释，
并且输出中的字形能够根据字体编码正确选择。而在 Unicode 时代，我们有了一个单一的文件和字体编码，
用于输入和输出。

While this may provide some illusion that we could get away simply with typing
Unicode text and receive correct output, this is not always the case.
For a start, hyphenation in particular is language-specific, so tags should be used
when switch between languages in a document.
The \pkg{babel} and \pkg{polyglossia} packages both provide features for this.

虽然这可能会给我们一些幻觉，认为我们可以简单地输入 Unicode 文本并获得正确的输出，但并非总是如此。
首先，特别是连字号化是语言特定的，因此在文档中切换语言时应使用标记。\pkg{babel} 和 \pkg{polyglossia} 包都提供了此类功能。

Multilingual documents will often use different fonts for different languages,
not just for style, but for the more pragmatic reason that fonts do not all contain
the same glyphs. (In fact, only test fonts such as Code2000 provide
anywhere near the full Unicode coverage.)
Indeed, certain fonts may be perfect for a certain application but miss a handful
of necessary diacritics or accented letters.
In these cases, \pkg{fontspec} can leverage the font encoding technology built
into \LaTeX2\ to provide on a per-font basis either provide fallback options or
error messages when a desired accent or symbol is not available.
However, at present
these features can only be provided for input using \LaTeX\ commands rather
than Unicode input; for example, typing |\`e| instead of |è| or |\textcopyright|
instead of |©| in the source file.

多语言文档通常会为不同的语言使用不同的字体，这不仅仅是为了风格，更是出于更实际的原因，即字体不包含相同的字形。（实际上，只有 Code2000 等测试字体提供了几乎完整的 Unicode 覆盖。）
确实，某些字体可能非常适合某些应用程序，但缺少少量必要的变音符或重音字母。
在这种情况下，\pkg{fontspec} 可以利用内置在 \LaTeX2\ 中的字体编码技术，为每个字体提供后备选项或在所需的重音符或符号不可用时提供错误消息。
但是，目前这些功能仅适用于使用 \LaTeX\ 命令输入的输入，而不是 Unicode 输入；例如，在源文件中输入 |`e| 而不是 |è| 或 |\textcopyright| 而不是 |©|。

The most widely-used encoding in \LaTeXe\ was |T1| with companion `|TS1|' symbols
provided by the \pkg{textcomp} package.
These encodings provided glyphs to typeset text in a variety of western European languages.
As with most legacy \LaTeXe\ input methods, accents and symbols were input using
encoding-dependent commands such as |\`e| as described above.

在 \LaTeXe\ 中，最广泛使用的编码是带有伴随 |TS1|' 符号的 |T1|。这些编码提供了用于排版各种西欧语言文本的字形。与大多数旧版 \LaTeXe\ 输入方法一样，重音符和符号是使用依赖于编码的命令输入的，如上所述的 |\e|。

As of 2017, in \LaTeXe\ on \XeTeX\ and \LuaTeX, the default encoding is |TU|,
which uses Unicode for input and output.
The |TU| encoding provides appropriate encoding-dependent definitions for input commands
to match the coverage of the |T1+TS1| encodings.
Wider coverage is not provided by default since (a)~each font will provide different glyph coverage, and
(b)~it is expected that most users will be writing with direct Unicode input.

截至2017年，在\XeTeX 和 \LuaTeX 中，\LaTeXe 的默认编码为|TU|，这使用Unicode作为输入和输出。|TU|编码为输入命令提供了适当的编码依赖定义，以匹配|T1 + TS1|编码的覆盖范围。默认情况下不提供更广泛的覆盖范围，因为(a) 每个字体提供不同的字形覆盖范围，和(b) 大多数用户将使用直接的Unicode输入进行编写。


For those users who do need finer-grained control, \pkg{fontspec} provides an
interface for a more extensible system.

对于那些需要更细粒度控制的用户，\pkg{fontspec}提供了一个更可扩展的系统的接口。


\section{A new Unicode-based encoding from scratch\\从头开始创建一个基于Unicode的新编码}

Let's say you need to provide support for a document originally written with fonts
in the |OT2| encoding, which contains encoding-dependent commands for Cyrillic letters.
An example from the |OT2| encoding definition file (|ot2enc.def|) reads:

假设您需要提供对最初使用|OT2|编码的字体编写的文档的支持，该编码包含依赖于Cyrillic字母的编码依赖命令。|OT2|编码定义文件(|ot2enc.def|)中的一个示例如下：
\begin{Verbatim}[numbers=left,firstnumber=57]
\DeclareTextSymbol{\CYRIE}{OT2}{5}
\DeclareTextSymbol{\CYRDJE}{OT2}{6}
\DeclareTextSymbol{\CYRTSHE}{OT2}{7}
\DeclareTextSymbol{\cyrnje}{OT2}{8}
\DeclareTextSymbol{\cyrlje}{OT2}{9}
\DeclareTextSymbol{\cyrdzhe}{OT2}{10}
\end{Verbatim}

To recreate this encoding in a form suitable for \pkg{fontspec}, create a new file
named, say, |fontrange-cyr.def| and populate it with

要在适合\pkg{fontspec}的形式中重新创建此编码，请创建一个名为，例如，|fontrange-cyr.def|的新文件，并填充为：

\begin{Verbatim}
...
\DeclareTextSymbol{\CYRIE}  {\LastDeclaredEncoding}{"0404}
\DeclareTextSymbol{\CYRDJE} {\LastDeclaredEncoding}{"0402}
\DeclareTextSymbol{\CYRTSHE}{\LastDeclaredEncoding}{"040B}
\DeclareTextSymbol{\cyrnje} {\LastDeclaredEncoding}{"045A}
\DeclareTextSymbol{\cyrlje} {\LastDeclaredEncoding}{"0459}
\DeclareTextSymbol{\cyrdzhe}{\LastDeclaredEncoding}{"045F}
...
\end{Verbatim}
The numbers |"0404|, |"0402|, \dots, are the Unicode slots (in hexadecimal)
of each glyph respectively.
The \pkg{fontspec} package provides a number of shorthands to simplify this style of input; in this case,
you could also write

数字|"0404|、|"0402|等是各个字形的Unicode插槽（用十六进制表示）。 \pkg{fontspec}软件包提供了许多简写方式来简化此输入样式；在这种情况下，您也可以编写如下代码：

\begin{Verbatim}
\EncodingSymbol{\CYRIE}{"0404}
...
\end{Verbatim}

To use this encoding in a \pkg{fontspec} font, you would first add this to your preamble:

要在\pkg{fontspec}字体中使用此编码，您首先需要将其添加到导言区：

\begin{Verbatim}
\DeclareUnicodeEncoding{unicyr}{
  \input{fontrange-cyr.def}
}
\end{Verbatim}
Then follow it up with a font loading call such as

然后跟随一个字体加载调用，例如：
\begin{Verbatim}
\setmainfont{...}[NFSSEncoding=unicyr]
\end{Verbatim}
The first argument |unicyr| is the name of the `encoding' to use in the
font family. (There's nothing special about the name chosen but it must be unique.)
The second argument to |\DeclareUnicodeEncoding| also allows adjustments to be made
for per-font changes.
We'll cover this use case in the next section.

第一个参数 |unicyr| 是字体族中要使用的“编码”的名称。（选择的名称没有什么特别之处，但它必须是唯一的。）
|\DeclareUnicodeEncoding| 的第二个参数也允许进行针对每个字体的调整。
我们将在下一节中讨论这种用例。

\section{Adjusting a pre-existing encoding\\调整预设编码}

There are three reasons to adjust a pre-existing encoding:
to add, to remove, and to redefine some symbols, letters, and/or accents.

有三个原因需要调整预设编码：添加、删除和重新定义一些符号、字母和/或重音符号。

When adding symbols, etc., simply write

当添加符号等时，只需编写以下内容：

\begin{Verbatim}
\DeclareUnicodeEncoding{unicyr}{
  \input{tuenc.def}
  \input{fontrange-cyr.def}
  \EncodingSymbol{\textruble}{"20BD}
}
\end{Verbatim}
Of course if you consistently add a number of symbols to an encoding it would be
a good idea to create a new |fontrange-XX.def| file to suit your needs.

当然，如果您要向编码中添加一些符号，建议为您的需求创建一个新的 |fontrange-XX.def| 文件。

When removing symbols, use the |\UndeclareSymbol|\marg{cmd} command.
For example, if you a loading a font that you know is missing, say, the interrobang
(not that unusual a situation), you might write:

当删除符号时，请使用 |\UndeclareSymbol|\marg{cmd} 命令。
例如，如果您正在加载一种字体，您知道它缺少叹问号感叹号符号（这种情况并不罕见），您可以编写：
\begin{Verbatim}
\DeclareUnicodeEncoding{nobang}{
  \input{tuenc.def}
  \UndeclareSymbol\textinterrobang
}
\end{Verbatim}
Provided that you use the command |\textinterrobang| to typeset this symbol,
it will appear in fonts with the default encoding, while in any font loaded with
the |nobang| encoding an attempt to access the symbol will either use the default
fallback definition or return an error, depending on the symbol being undeclared.

只要您使用命令 |\textinterrobang| 来排版此符号，
它将出现在具有默认编码的字体中，而在任何加载了 |nobang| 编码的字体中，尝试访问该符号将使用默认回退定义或返回错误，具体取决于符号是否未声明。

The third use case is to redefine a symbol or accent. The most common use case
in this scenario is to adjust a specific accent command to either fine-tune its placement
or to `fake' it entirely.
For example, the underdot diacritic is used in typeset Sanskrit,
but it is not necessarily included as an accent symbol is all fonts.
By default the underdot is defined in |TU| as:

第三种用例是重新定义符号或重音符号。在这种情况下，最常见的用例是将特定重音命令调整为微调其位置或完全“伪造”它。
例如，下划线变音符用于排版梵文，但并不一定在所有字体中都包括为一个重音符号。
默认情况下，|TU| 中的下划线被定义为：
\begin{Verbatim}
\EncodingAccent{\d}{"0323}
\end{Verbatim}
For fonts with a missing (or poorly-spaced) |"0323| accent glyph, the `traditional' \TeX\ fake accent
construction could be used instead:

对于缺少（或间距不好）的 |"0323| 重音符号的字体，可以使用“传统”的 \TeX\ 伪造重音构造代替：
\begin{Verbatim}
\DeclareUnicodeEncoding{fakeacc}{
  \input{tuenc.def}
  \EncodingCommand{\d}[1]{%
    \hmode@bgroup
      \o@lign{\relax#1\crcr\hidewidth\ltx@sh@ft{-1ex}.\hidewidth}%
    \egroup
  }
}
\end{Verbatim}
This would be set up in a document as such:

这将在文档中设置如下：

\begin{Verbatim}
\newfontfamily\sanskitfont{CharisSIL}
\newfontfamily\titlefont{Posterama}[NFSSEncoding=fakeacc]
\end{Verbatim}
Then later in the document, no additional work is needed:

那么在文档的后面，就不需要再做额外的工作了。
\begin{Verbatim}
...{\titlefont   kalita\d m}...  % <- uses fake accent
...{\sanskitfont kalita\d m}...  % <- uses real accent
\end{Verbatim}
To reiterate from above, typing this input with Unicode text (`|kalitaṃ|')
will \emph{bypass} this encoding mechanism and you will receive only what is contained
literally within the font.

重申一下，使用Unicode文本(`|kalitaṃ|')输入时，会绕过编码机制，你将只会得到在字体中包含的内容。

\section{Summary of commands\\命令概述}

The \LaTeXe\ kernel provides the following font encoding commands suitable for Unicode encodings:

\LaTeXe\ 核心提供了适用于Unicode编码的以下字体编码命令：
\begin{quote}\obeylines
  \cs{DeclareTextCommand}\marg{command}\marg{encoding}\oarg{num}\oarg{default}\marg{code}
  \cs{DeclareUnicodeAccent}\marg{command}\marg{encoding}\marg{slot}
  \cs{DeclareTextSymbol}\marg{command}\marg{encoding}\marg{slot}
  \cs{DeclareTextComposite}\marg{command}\marg{encoding}\marg{letter}\marg{slot}
  \cs{DeclareTextCompositeCommand}\marg{command}\marg{encoding}\marg{letter}\marg{code}
  \cs{UndeclareTextCommand}\marg{command}\marg{encoding}
\end{quote}
See |fntguide.pdf| for full documentation of these.
As shown above, the following shorthands are provided by \pkg{fontspec} to simplify
the process of defining Unicode font range encodings:

详细文档请参见 |fntguide.pdf|。如上所示，下列快捷方式由 \pkg{fontspec} 提供，以简化定义Unicode字体范围编码的过程：

\begin{quote}\obeylines
  \cs{EncodingCommand}\marg{command}\oarg{num}\oarg{default}\marg{code}
  \cs{EncodingAccent}\marg{command}\marg{code}
  \cs{EncodingSymbol}\marg{command}\marg{code}
  \cs{EncodingComposite}\marg{command}\marg{letter}\marg{slot}
  \cs{EncodingCompositeCommand}\marg{command}\marg{letter}\marg{code}
  \cs{UndeclareSymbol}\marg{command}
  \cs{UndeclareAccent}\marg{command}
  \cs{UndeclareCommand}\marg{command}
  \cs{UndeclareComposite}\marg{command}\marg{letter}
\end{quote}

\end{document}


% /©
% ------------------------------------------------
% The FONTSPEC package  <wspr.io/fontspec>
% ------------------------------------------------
% Copyright  2004-2022  Will Robertson, LPPL "maintainer"
% Copyright  2009-2015  Khaled Hosny
% Copyright  2013       Philipp Gesang
% Copyright  2013-2016  Joseph Wright
% ------------------------------------------------
% This package is free software and may be redistributed and/or modified under
% the conditions of the LaTeX Project Public License, version 1.3c or higher
% (your choice): <http://www.latex-project.org/lppl/>.
% ------------------------------------------------
% ©/
