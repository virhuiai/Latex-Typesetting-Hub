
% %\InputFile:char
% %%%% this is input file [char]
% %\subject[char] Characters
% \endofchapter
% \chapter{Characters\\字符}\label{char}

% Internally, \TeX\ represents characters by their (integer) 
% character code. This chapter treats those codes, and the
% commands that have access to them.

% 在内部，\TeX 用它们的（整数）字符码表示字符。本章讨论这些字符码以及能够访问它们的命令。

% \begin{inventory}
% \item [\cs{char}]
%       Explicit denotation of a character to be typeset. 

%       显式表示要排版的字符。
% \item [\cs{chardef}] 
%       Define a control sequence to be a synonym for
%       a~character code.

%       将控制序列定义为字符码的别名。
% \item [\cs{accent}] 
%       Command to place accent characters.

%       用于放置重音字符的命令。
% \item [\cs{if}]
%       Test equality of character codes. 

%       比较字符码是否相等。
% \item [\cs{ifx}]
%       Test equality of both character and category codes.

%       比较字符码和类别码是否都相等。
% \item [\cs{let}]
%       Define a control sequence to be a synonym of a token.

%       将控制序列定义为一个记号的别名。
% \item [\cs{uccode}] 
%       Query or set
%       the character code that is the uppercase variant of a given code.

%       查询或设置给定字符码的大写形式的字符码。
% \item [\cs{lccode}]
%       Query or set
%       the character code that is the lowercase variant of a given code.

%       查询或设置给定字符码的小写形式的字符码。
% \item [\cs{uppercase}]
%       Convert the \gr{general text} argument to its uppercase form.

%       将 \gr{general text} 参数转换为大写形式。
% \item [\cs{lowercase}] 
%       Convert the \gr{general text} argument to its lowercase form.

%       将 \gr{general text} 参数转换为小写形式。
% \item [\cs{string}]
%       Convert a token to a string of one or more characters.

%       将记号转换为一个或多个字符的字符串。
% \item [\cs{escapechar}]
%       Number of the character that is to be used 
%       for the escape character
%       when control sequences are being converted
%       into character tokens. \IniTeX\ default:~92~(\cs{}).

%       当将控制序列转换为字符记号时，用于作为转义字符的字符的编号。在初始的 \TeX 中，默认值为 92（\cs{}）。
% \end{inventory}


% %\point[char:code] Character codes
% \section{Character codes\\字符码}
% \label{char:code}

% Conceptually it is easiest to think that \TeX\ works with
% \term character! codes\par
% characters internally, but in fact
% \TeX\ works with integers: the `character codes'. 

% 从概念上来说，最容易理解的是 \TeX\ 内部使用\term character! codes\par 字符，但实际上 \TeX\ 使用的是整数：即“字符码”。

% The way characters are encoded in a computer may differ
% from system to system.
% Therefore \TeX\ uses its own scheme of character codes.
% Any character that is read from a file (or from the user terminal)
% is converted to a character code according to the
% character code table.
% A~category code is then assigned based on this (see Chapter~\ref{mouth}).
% The character code table is based on the 7-bit \ascii{} table
% for numbers under~128 (see Chapter~\ref{table}).

% 不同的计算机系统对字符的编码方式可能有所不同。因此，\TeX\ 使用自己的字符码方案。从文件（或用户终端）读取的任何字符都会根据字符码表转换为字符码。然后，根据字符码分配类别码（参见第~\ref{mouth}章）。字符码表基于 7 位 \ascii{} 表，在数字小于 128 时使用（参见第\ref{table}~章）。

% There is an explicit conversion between characters
% (better:  character tokens)
% and  character codes  using the left quote (grave, back quote)
% character~\n{`{}}:
% at all places where \TeX\ expects a \gram{number} you
% can use the left quote followed by a character
% token or
% a single-character control sequence.
% Thus both \verb.\count`a. and \verb.\count`\a. are synonyms
% \awp
% for \verb.\count97.. See also Chapter~\ref{number}.

% 可以使用左引号（反引号）字符 \n{{}} 对字符（更准确地说是字符记号）和字符码进行显式转换：在 \TeX\ 需要一个 \gram{number} 的任何地方，都可以使用左引号后跟一个字符记号或一个单字符控制序列。因此，\verb.\counta. 和 \verb.\count`\a. 都是 \verb.\count97. 的同义词。详见第~\ref{number}~章。


% The possibility of a single-character control
% sequence is necessary in certain cases such as

% 在某些情况下，需要使用单字符控制序列，例如：
% \begin{disp}\verb>\catcode`\%=11>\quad or\quad \verb>\def\CommentSign{\char`\%}>\end{disp}
% which would be misunderstood if the backslash were left out.
% For instance 

% 如果省略了反斜杠，则会引起误解。例如：
% \begin{verbatim}
% \catcode`%=11
% \end{verbatim}
% would consider
% the \n{=11} to be a comment.
% Single-character
% control sequences can be formed from characters with any
% category code.

% 会将 \n{=11} 视为注释。单字符控制序列可以由任何类别码的字符构成。

% After the conversion to character codes any connection
% with external representations has disappeared. Of course,
% for most characters  the visible output will `equal' the input
% (that is, an `\n{a}' causes an~`a').
% There are exceptions, however, even among the common symbols.
% In the Computer Modern
% roman fonts there are no `less than' and `greater than'
% \message{Check <>! Dammit!}%
% signs, so the input `\verb.<>.' will give `<>' in the output.
% %{\MathRMx<>}

% 在转换为字符码之后，与外部表示的任何联系都已消失。当然，对于大多数字符，可见的输出将与输入“相等”（即，\n{a}' 会输出为 a'）。然而，即使在常见的符号中也存在例外情况。在 Computer Modern Roman 字体中，没有“小于”和“大于”符号，因此输入 \verb.<>.' 会在输出中显示为 <> '。

% In order to make \TeX\ machine independent at the output
% side, the character codes are also used in the \n{dvi} file:
% opcodes $n=0\ldots127$ denote simply the instruction `take
% character $n$ from the current font'. The complete definition
% of the opcodes in a \n{dvi} file can be found in~\cite{Knuth:TeXprogram}.

% 为了使 \TeX\ 在输出方面具有机器无关性，字符码也用于 \n{dvi} 文件：操作码 $n=0\ldots127$ 简单地表示“从当前字体中获取字符 $n$”。有关 \n{dvi} 文件中操作码的完整定义可以在~\cite{Knuth:TeXprogram} 中找到。


% %\point Control sequences for characters
% \section{Control sequences for characters\\用于字符的控制序列}

% There are a number of ways in which a control sequence can denote
% a character. The \cs{char} command specifies a character to be
% typeset; the \cs{let} command introduces
% a synonym for a character token, that is,
% the combination of character code and category code.

% 有多种方式可以使用控制序列表示一个字符。命令 \cs{char} 指定要排版的字符；命令 \cs{let} 引入了一个字符记号的同义词，即字符编码和类别码的组合。

% %\point Denoting characters to be typeset: \cs\char
% \section{Denoting characters to be typeset: \protect\cs{char}\\用于表示要排版的字符：\protect\cs{char}}

% Characters can be denoted numerically by, for example,
% \verb.\char98.\cstoidx char\par.
% This command tells \TeX\ to add character number~98 of the
% current font to the horizontal list currently under construction.

% 字符可以通过数字进行表示，例如 \verb.\char98.\cstoidx char\par。此命令告诉 \TeX{} 在当前正在构建的水平列表中添加当前字体的第 98 号字符。

% Instead of decimal notation, it is often more convenient to
% use octal or hexadecimal notation. For octal the single quote is used:
% \verb.\char'142.; hexadecimal uses the double quote: \verb.\char"62..
% Note that \verb.\char''62. is incorrect; the process that replaces
% two quotes by a double quote works at a later stage of processing
% (the visual processor) than number scanning (the execution processor).

% 除了十进制表示法，使用八进制或十六进制表示法通常更方便。八进制使用单引号：\verb.\char'142.; 十六进制使用双引号：\verb.\char"62.. 请注意，\verb.\char''62. 是错误的；将两个引号替换为一个双引号的过程发生在处理的较晚阶段（视觉处理器）而不是数字扫描阶段（执行处理器）。

% Because of the explicit conversion to character codes by the
% back quote character it is also possible to get a `b' \ldash provided
% that you are using a font organized a bit like the \ascii{} table \rdash
% with \verb.\char`b.  or \verb.\char`\b..

% 由于反引号字符对字符编码进行了显式转换，因此也可以获取一个 b' \ldash 假设您使用的字体的组织方式有点类似于 \ascii{} 表 \rdash 使用 \verb.\charb. 或 \verb.\char`\b.。

% The \cs{char} command looks superficially a bit like
% the \verb-^^- substitution mechanism (Chapter~\ref{mouth}).
% Both mechanisms access characters without directly denoting them.
% However, the \verb-^^- mechanism operates in a very early stage of
% processing (in the input processor of \TeX,
% but before category code
% assignment); the \cs{char} command, on the other hand,
% comes in the final stages of processing. 
% In effect it says `typeset character number
% so-and-so'.
% \awp

% \cs{char} 命令在表面上看起来有点类似于 \verb-^^- 替换机制（第~\ref{mouth} 章）。这两种机制都是在不直接表示字符的情况下访问字符。然而，\verb-^^- 机制在处理的早期阶段（在 \TeX 的输入处理器中，在类别码分配之前）进行操作；另一方面，\cs{char} 命令在处理的最后阶段出现。实际上，它的作用是“排版字符编号为某某的字符”。

% There is a construction to let a control sequence stand
% for some character code: the \cstoidx chardef\par\ command.
% The syntax of this is \label{chardef}

% 还有一种构造可以让一个控制序列代表某个字符编码，即 \cstoidx chardef\par 命令。它的语法是
% \begin{disp}\cs{chardef}\gram{control sequence}\gr{equals}\gram{number}, 
% \end{disp}
% where the number can be an explicit
% representation or a counter value, but it can also be
% a character code
% obtained using the left quote command (see above; 
% the full definition of \gr{number} is given in Chapter~\ref{number}). 
% In the plain format 
% the latter possibility is used in
% definitions such as 

% 其中数字可以是显式表示或计数器值，也可以是使用左引号命令获得的字符编码（参见上文；\gr{number} 的完整定义在第~\ref{number} 章中给出）。在 plain 格式中，可以使用后一种可能性进行定义，例如：
% \begin{verbatim}
% \chardef\%=`\%
% \end{verbatim}
% which could have been given equivalently as

% 这也可以等价地写为：
% \begin{verbatim}
% \chardef\%=37
% \end{verbatim}
% After this command, the control symbol \verb>\%>
% used on its own is a synonym for \verb>\char37>,
% that is, the command to typeset character~37
% (usually the per cent character).

% 执行此命令后，单独使用的控制符号 \verb>%> 是 \verb>\char37> 的同义词，即用于排版字符 37 的命令（通常是百分号字符）。

% A control sequence that has been defined with a \cs{chardef}
% command can also be used as a \gr{number}.
% This fact is used in  allocation commands such as 
% \cs{newbox} (see Chapters~\ref{number} and~\ref{alloc}).
% Tokens defined with \cs{mathchardef} can also be used this
% way.

% 使用 \cs{chardef} 命令定义的控制序列也可以用作 \gr{number}。在分配命令（如 \cs{newbox}）中使用了这个特性（见第~\ref{number} 和第~\ref{alloc} 章）。使用 \cs{mathchardef} 定义的记号也可以以这种方式使用。


% %\spoint Implicit character tokens: \cs{let}
% \subsection{Implicit character tokens: \protect\cs{let}\\隐式字符记号：\protect\cs{let}}

% Another construction defining a control sequence
% \term character !implicit\par
% to stand for (among other things)
% a character is~\cs{let}\cstoidx let\par:

% 另一种定义控制序列\term 字符！隐式的\par 代表（除其他外）一个字符的构造是 \cs{let}：
% \begin{disp}\cs{let}\gr{control sequence}\gr{equals}\gr{token}\end{disp}
% with a character token on the right hand side of the (optional)
% equals sign. The result is called an implicit character token.
% (See page~\pageref{let} for a further discussion of~\cs{let}.)

% 其中等号（可选）右侧是一个字符记号。结果被称为隐式字符记号。
% （有关 \cs{let} 的进一步讨论，请参见第~\pageref{let} 页。）

% In the
% plain format there are for instance synonyms for
% the open and close brace:

% 在 plain 格式中，例如对于左花括号和右花括号有以下同义词：
% \begin{verbatim}
% \let\bgroup={ \let\egroup=}
% \end{verbatim}
% The resulting control sequences are called `implicit braces'
% (see Chapter~\ref{group}).

% 由此产生的控制序列被称为“隐式花括号”（参见第~\ref{group} 章）。

% Assigning characters by \cs{let}
% is different from defining control sequences by \cs{chardef}, 
% in the sense that \cs{let}
% makes the control sequence stand for the combination
% of a character code and category code. 

% 通过 \cs{let} 分配字符与通过 \cs{chardef} 定义控制序列不同，
% 因为 \cs{let} 使得控制序列代表字符代码和类别码的组合。


% As an example 例如，
% \begin{verbatim}
% \catcode`|=2 % make the bar an end of group
% \let\b=|  % make \b a bar character
% {\def\m{...}\b \m
% \end{verbatim}
% gives an `undefined control sequence \cs{m}'
% because the \cs{b} closed the group inside which \cs{m}
% was defined. On the other hand,

% 会报告“未定义的控制序列 \cs{m}”，因为 \cs{b} 关闭了 \cs{m} 定义所在的组。 另一方面，
% \begin{verbatim}
% \let\b=| % make \b a bar character
% \catcode`|=2  % make the bar character end of group
% {\def\m{...}\b \m
% \end{verbatim}
% leaves one group open, and it prints a vertical bar
% (or whatever is in position 124 of the current font).
% The first of these examples
% implies that even when the braces have been redefined
% (for instance into active characters for macros that
% format C code) the beginning-of-group and end-of-group
% functionality is available through the control sequences
% \cs{bgroup} and~\cs{egroup}.

% 会留下一个未关闭的组，并打印一个竖线
% （或者当前字体位置的字符 124）。
% 这两个示例表明，即使花括号已被重新定义
% （例如作为用于格式化 C 代码的宏的活动字符），组的开始和结束功能仍可通过控制序列 \cs{bgroup} 和 \cs{egroup} 实现。

% Here is
% another example to show
% that implicit character tokens are hard to distinguish
% from real character tokens. After the above sequence

% 以下是另一个示例，以展示隐式字符记号很难与实际字符记号区分。
% 在执行了上述代码之后，
% \begin{verbatim}
% \catcode`|=2 \let\b=|
% \end{verbatim}
% the tests \begin{verbatim}
% \if\b|
% \end{verbatim}
% and \begin{verbatim}
% \ifcat\b}
% \end{verbatim}
% are both true.

% 两者都为真。

% Yet another example can be found in the plain format:
% the commands

% 在 plain 格式中还有另一个示例：
% 命令
% \begin{verbatim}
% \let\sp=^ \let\sb=_ 
% \end{verbatim}
% allow people without an
% underscore or circumflex on their keyboard to 
% make sub- and superscripts in mathematics.
% For instance:

% 允许没有下划线或插入符号的键盘的用户在数学公式中添加上标和下标。
% 例如：
% \begin{disp}\verb>x\sp2\sb{ij}>\quad gives\quad $x\sp2\sb{ij}$\end{disp}
% If a person typing in the format itself does not have
% these keys, some further tricks are needed:\label{spsb:truc}

% 如果在格式本身中输入的人没有这些键，就需要使用一些额外的技巧：
% \begin{verbatim}
% {\lccode`,=94 \lccode`.=95 \catcode`,=7 \catcode`.=8
% \lowercase{\global\let\sp=, \global\let\sb=.}}
% \end{verbatim}
% will do the job; see below for an explanation of lowercase codes.
% The \verb>^^> method as it was in \TeX\ version~2
% (see page~\pageref{hathat}) cannot be used here,
% as it would require typing two characters that can ordinarily
% not be input.
% With the extension in \TeX\ version~3 it would also be possible
% to write 

% 这样就可以实现；有关小写代码的解释，请参见下文。
% 在 \TeX\ 版本 2 中的 \verb>^^> 方法（参见第~\pageref{hathat} 页）无法在此处使用，
% 因为它需要输入通常无法输入的两个字符。
% 在 \TeX\ 版本 3 中的扩展中，也可以写成：
% \begin{verbatim}
% {\catcode`\,=7
% \global\let\sp=,,5e \global\let\sb=,,5f}
% \end{verbatim}
% denoting the codes 94 and 95 hexadecimally.

% 其中分别表示十六进制代码 94 和 95。

% Finding out just what a control sequence has been defined to be with
% \cs{let} can be done using \cs{meaning}:
% the sequence 

% 通过 \cs{let} 找出控制序列的定义可以使用 \cs{meaning}：
% 序列
% \begin{verbatim}
% \let\x=3 \meaning\x
% \end{verbatim}
% gives
% `\n{the character 3}'.\awp


% %\point Accents
% \section{Accents\\重音符号}

% Accents can be placed by the
% \gr{horizontal command}~\cs{accent}\cstoidx accent\par\term accents\par
% \label{character}:

% 重音符号可以通过\gr{水平命令}~\cs{accent} 来放置：


% \begin{disp}\cs{accent}\gr{8-bit number}\gr{optional assignments}%
%      \gr{character}\end{disp}
% where \gr{character} is a character of category 11 or~12,
%  a~\cs{char}\gr{8-bit number} command,
% or a~\cs{chardef} token. If none of these
% four types of \gr{character} follows, the accent is taken to be a
% \cs{char} command itself; this gives an accent `suspended
% in mid-air'. Otherwise the accent is placed
% on top of the following character.
% Font changes between the accent and the character can be effected
% by the \gr{optional assignments}.

% 其中\gr{字符}可以是类别码为11或12的字符，一个\cs{char}\gr{8位数}命令，或一个\cs{chardef}记号。如果没有这四种类型的\gr{字符}之一，重音符号被视为一个\cs{char}命令本身；这会得到一个“悬浮在空中”的重音符号。否则，重音符号将放置在紧随其后的字符上方。可以通过\gr{可选赋值}来改变重音符号和字符之间的字体变化。

% An unpleasant implication of the fact that an \cs{accent} command
% has to be followed by a \gr{character} is that it is not
% possible to place an accent on a ligature, or
% two accents on top of each other.
% In some languages, such as Hindi or Vietnamese,
% such double accents do occur.
% Positioning accents on top of each other is possible,
% however, in math mode.

% 一个令人不愉快的事实是，\cs{accent}命令后面必须跟一个\gr{字符}，因此无法在连字上放置重音符号，也无法将两个重音符号叠放在一起。然而，在某些语言（如印地语或越南语）中，确实会出现双重重音符号。不过，在数学模式下，可以将重音符号叠放在一起。

% The width of a character with an accent is the same as that of
% the unaccented character. \TeX\ assumes that the 
% accent as it appears in the font file
% is properly positioned for a character that is as high
% as the x-height of the font; for characters with other heights
% it correspondingly lowers or raises the accent.

% 带有重音符号的字符的宽度与无重音的字符相同。\TeX\ 假设字体文件中的重音符号在正确的位置上，适合与字体的 x 高度一样高的字符；对于其他高度的字符，它相应地降低或提高重音符号的位置。

% No genuine under-accents exist in \TeX. They are
% implemented as low placed over-accents. A~way of handling
% them more correctly would be to write a macro that
% measures the following character, and raises or drops
% the accent accordingly.
% The cedilla macro, \cs{c}\cstoidx c\par,
% in plain \TeX\ does something along these lines. However,
% it does not drop the accent for characters with descenders.

% \TeX\ 中不存在真正的下重音符号。它们被实现为位于底部的上重音符号。更正确处理它们的一种方法是编写一个宏，测量接下来的字符，并相应地提升或降低重音符号。在 plain \TeX\ 中，附带的勾音宏 \cs{c}\cstoidx c\par 大致按照这个思路进行操作。然而，对于带有下行字符的字符，它不会降低重音符号的位置。

% The horizontal positioning of an accent is controlled by
% \cs{fontdimen1}, slant per point. Kerns are used
% for the horizontal movement. Note that, although they
% are inserted automatically, these kerns are classified
% as {\italic explicit\/} kerns. Therefore they inhibit hyphenation
% in the parts of the word before and after the kern.

% 重音符号的水平定位由\cs{fontdimen1}（每点的倾斜）控制。水平移动使用紧排。请注意，尽管它们是自动插入的，但这些紧排被归类为{\italic 显式紧排}。因此，它们会阻止单词的紧排出现在紧排之前和之后的部分。


% As an example of kerning for accents, 
% here follows the dump of a horizontal list.
% \message{maybe italic correction for extra line}

% 作为重音符号紧排的一个示例，以下是水平列表的转储。
% \begin{verbatim}
% \setbox0=\hbox{\it \`l}
% \showbox0
% \end{verbatim}
% gives\begin{verbatim}
% \hbox(9.58334+0.0)x2.55554
% .\kern -0.61803 (for accent)
% .\hbox(6.94444+0.0)x5.11108, shifted -2.6389
% ..\tenit ^^R
% .\kern -4.49306 (for accent)
% .\tenit l
% \end{verbatim}
% Note that the accent is placed first, so afterwards the italic
% correction of the last character is still available.
% \awp

% 注意，重音符号首先放置，因此最后一个字符的斜体修正仍然可用。

