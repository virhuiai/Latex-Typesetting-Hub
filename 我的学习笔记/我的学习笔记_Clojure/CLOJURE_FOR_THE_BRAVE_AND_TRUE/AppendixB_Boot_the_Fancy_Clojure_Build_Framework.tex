\chapter{Boot, the Fancy Clojure Build Framework}

\columnratio{0.55}
\begin{paracol}{2}
\switchcolumn[0]*
Boot is an alternative to Leiningen that provides the same
functionality. Leiningen's more popular (as of the summer of 2015), but
I personally like to work with Boot because it's easier to extend. This
appendix explains Boot's underlying concepts and guides you through
writing your first Boot tasks. If you're interested in using Boot to
build projects right this second, check out its GitHub README
(\emph{https://github.com/boot-clj/boot/}) and its wiki
(\emph{https://github.com/boot-clj/boot/wiki/}).
\switchcolumn
Boot是Leiningen的替代品，提供了相同的功能。虽然Leiningen更受欢迎（截至2015年夏季），但我个人更喜欢使用Boot，因为它更容易扩展。本附录解释了Boot的基本概念，并指导您编写第一个Boot任务。如果您有兴趣立即使用Boot构建项目，请查看其GitHub README（https://github.com/boot-clj/boot/）和其Wiki（https://github.com/boot-clj/boot/wiki/）。
\switchcolumn[0]*
\begin{quote}
\textbf{NOTE}:
\emph{As of this writing, Boot has limited support for Windows. The Boot
team welcomes contributions!}
\end{quote}
\switchcolumn
\begin{quote}
注意：截至本文写作时，Boot对Windows的支持有限。Boot团队欢迎贡献！
\end{quote}
\switchcolumn[0]*
\section{Boot's Abstractions}
\switchcolumn
\section{Boot的抽象}
\switchcolumn[0]*
Created by Micha Niskin and Alan Dipert, Boot is a fun and powerful
addition to the Clojure tooling landscape. On the surface, it's a
convenient way to build Clojure applications and run Clojure tasks from
the command line. Dig a little deeper and you'll see that Boot is like
the Lisped-up lovechild of Git and Unix in that it provides abstractions
that make it more pleasant to write code that exists at the intersection
of your operating system and your application.
\switchcolumn
由Micha Niskin和Alan Dipert创建，Boot是Clojure工具生态系统中有趣且强大的补充。从表面上看，它是一种方便的方式来构建Clojure应用程序并从命令行运行Clojure任务。深入挖掘，您会发现Boot就像Git和Unix的结合体，它提供了一些抽象，使得编写处于操作系统和应用程序交集处的代码更加愉快。
\switchcolumn[0]*
Unix provides abstractions that we're all familiar with to the point
where we take them for granted. (Would it kill you to take your computer
out to a nice restaurant once in a while?) The process abstraction lets
you reason about programs as isolated units of logic that can be easily
composed into a stream-processing pipeline through the STDIN and STDOUT
file descriptors. These abstractions make certain kinds of operations,
like text processing, very straightforward.
\switchcolumn
Unix提供了我们都熟悉的抽象，以至于我们认为它们理所当然。 （难道你不能偶尔带电脑去好餐厅吗？）进程抽象使您可以将程序视为独立的逻辑单元，通过STDIN和STDOUT文件描述符轻松组合成流处理管道。这些抽象使得某些操作（如文本处理）变得非常简单。
\switchcolumn[0]*
Similarly, Boot provides abstractions that make it easy to compose
independent operations into the kinds of complex, coordinated operations
that build tools end up doing, like converting ClojureScript into
JavaScript. Boot's task abstraction lets you easily define units of
logic that communicate through \emph{filesets}. The fileset abstraction
keeps track of the evolving build context and provides a well-defined,
reliable method of task coordination.
\switchcolumn
类似地，Boot提供了一些抽象，使得将独立操作组合成构建工具常常需要的复杂协调操作变得容易，比如将ClojureScript转换为JavaScript。Boot的任务抽象使您可以轻松定义通过文件集相互通信的逻辑单元。文件集抽象跟踪不断演变的构建上下文，并提供了一种明确定义的、可靠的任务协调方法。
\switchcolumn[0]*
That's a lot of high-level description, which hopefully has hooked your
attention. But I would be ashamed to leave you with a plateful of
metaphors. Oh no, dear reader, that was only the appetizer. Throughout
the rest of this appendix, you'll learn how to build your own Boot
tasks. Along the way, you'll discover that build tools can actually have
a conceptual foundation.
\switchcolumn
这是很多高层描述，希望能吸引您的注意。但是，如果我只给你上了一盘隐喻，我会感到羞愧的。不，亲爱的读者，那只是开胃菜。在本附录的其余部分，您将学习如何构建自己的Boot任务。在此过程中，您将发现构建工具实际上可以有一个概念基础。
\switchcolumn[0]*
\section{Tasks}
\switchcolumn
\section{任务}
\switchcolumn[0]*
Like make, rake, grunt, and other build tools of yore, Boot lets you
define tasks. \emph{Tasks} are named operations that take command line
options dispatched by some intermediary program (make, rake, Boot).
\switchcolumn
像make、rake、grunt和其他早期的构建工具一样，Boot允许您定义任务。任务是命名的操作，它们接受由某个中介程序（如make、rake、Boot）分派的命令行选项。
\switchcolumn[0]*
Boot provides the dispatching program, \emph{boot}, and a Clojure
library that makes it easy for you to define named operations and their
command line options with the deftask macro. To see what all the fuss is
about, let's create your first task. Normally, programming tutorials
encourage you to write code that prints ``Hello World,'' but I like my
examples to have real-world utility, so your task is to print ``My pants
are on fire!'' This information is objectively more useful. First,
install Boot; then create a new directory named \emph{boot-walkthrough},
navigate to that directory, create a file named \emph{build.boot,} and
write this:
\begin{verbatim}
(deftask fire
    "Prints 'My pants are on fire!'"
    []
    (println "My pants are on fire!"))
\end{verbatim}
\switchcolumn
Boot提供了分派程序boot和一个Clojure库，使用deftask宏可以轻松定义命名操作及其命令行选项。为了了解到底是怎么回事，让我们创建您的第一个任务。通常，编程教程鼓励您编写打印“Hello World”的代码，但我喜欢我的示例具有实际的用途，所以您的任务是打印“我的裤子着火了！”这个信息是客观上更有用的。首先，安装Boot；然后创建一个名为boot-walkthrough的新目录，进入该目录，创建一个名为build.boot的文件，并编写以下内容：
\begin{verbatim}
(deftask fire
    "Prints 'My pants are on fire!'"
    []
    (println "My pants are on fire!"))
\end{verbatim}
\switchcolumn[0]*
Now run this task from the command line with boot fire; you should see
the message you wrote printed to your terminal. This task demonstrates
two out of the three task components: the task is named (fire), and it's
dispatched by boot. This is super cool. You've essentially created a
Clojure shell script, stand-alone Clojure code that you can run from the
command line with ease. No \emph{project.clj}, directory structure, or
namespaces needed!
\switchcolumn
现在在命令行中使用boot fire运行此任务；您应该看到您编写的消息打印到终端上。这个任务演示了三个任务组件中的两个：任务有一个名称（fire），并且由boot分派。这非常酷。您实际上创建了一个Clojure shell脚本，一个独立的Clojure代码，可以轻松地从命令行运行。不需要project.clj、目录结构或命名空间！
\switchcolumn[0]*
Let's extend the example to demonstrate how you'd write command line
options:
\begin{verbatim}
(deftask fire
    "Announces that something is on fire"
    [t thing     THING str "The thing that's on fire"
    p pluralize       bool "Whether to pluralize"]
    (let [verb (if pluralize "are" "is")]
    (println "My" thing verb "on fire!")))
\end{verbatim}
\switchcolumn
让我们扩展示例以演示如何编写命令行选项：
\begin{verbatim}
(deftask fire
    "Announces that something is on fire"
    [t thing     THING str "The thing that's on fire"
    p pluralize       bool "Whether to pluralize"]
    (let [verb (if pluralize "are" "is")]
    (println "My" thing verb "on fire!")))
\end{verbatim}
\switchcolumn[0]*
Try running the task like so:
\begin{verbatim}
boot fire -t heart
# => My heart is on fire!


boot fire -t logs -p
# => My logs are on fire!
\end{verbatim}
\switchcolumn
尝试以以下方式运行任务：
\begin{verbatim}
boot fire -t heart
# => My heart is on fire!


boot fire -t logs -p
# => My logs are on fire!
\end{verbatim}
\switchcolumn[0]*
In the first instance, either you're newly in love or you need to be
rushed to the emergency room. In the second, you are a Boy Scout
awkwardly expressing your excitement over meeting the requirements for a
merit badge. In both instances, you were able to easily specify options
for the task.
\switchcolumn
在第一个示例中，要么您新恋爱了，要么您需要赶紧去急诊室。在第二个示例中，您是一个笨拙地表达自己对满足获得勋章要求的兴奋的童子军。在这两种情况下，您都可以轻松地为任务指定选项。
\switchcolumn[0]*
This refinement of the fire task introduced two command line options,
thing and pluralize. Both options are defined using a
\emph{domain-specific language (DSL)}. DSLs are their own topic, but
briefly, the term refers to mini-languages that you can use within a
larger program to write compact, expressive code for narrowly defined
domains (like defining options).
\switchcolumn
这个改进的fire任务引入了两个命令行选项thing和pluralize。这两个选项使用特定领域语言（DSL）进行定义。DSL是一个独立的主题，但简而言之，该术语指的是您可以在较大程序中使用的迷你语言，用于在狭义定义的领域（如定义选项）中编写紧凑、表达力强的代码。
\switchcolumn[0]*
In the option thing, t specifies its short name, and thing specifies its
long name. THING is a bit complicated, and I'll get to it in a second.
str specifies the option's type, and Boot uses that to validate the
argument and convert it. "The thing that's on fire" is the documentation
for the option. You can view a task's documentation in the terminal with
boot task-name -h:
\begin{verbatim}
boot fire -h
# Announces that something is on fire
#
# Options:
#   -h, --help        Print this help info.
#   -t, --thing THING Set the thing that's on fire to THING.
#   -p, --pluralize   Whether to pluralize
\end{verbatim}
\switchcolumn
在选项thing中，t指定了其短名称，thing指定了其长名称。THING有点复杂，我一会儿会解释。str指定了选项的类型，Boot使用它来验证参数并进行转换。"着火的东西"是该选项的文档。您可以在终端中使用boot任务名称 -h查看任务的文档。
\begin{verbatim}
boot fire -h
# Announces that something is on fire
#
# Options:
#   -h, --help        Print this help info.
#   -t, --thing THING Set the thing that's on fire to THING.
#   -p, --pluralize   Whether to pluralize
\end{verbatim}
\switchcolumn[0]*
Pretty groovy! Boot makes it very easy to write code that's meant to be
invoked from the command line.
\switchcolumn
非常棒！Boot使得编写可以从命令行调用的代码变得非常容易。
\switchcolumn[0]*
Now, let's look at THING. THING is an \emph{optarg}, and it indicates
that this option expects an argument. You don't have to include an
optarg when you're defining an option (notice that the pluralize option
has no optarg). The optarg doesn't have to correspond to the full name
of the option; you could replace THING with BILLY\_JOEL or whatever you
want and the task would work the same. You can also designate complex
options using the optarg. (Visit
\emph{https://github.com/boot-clj/boot/wiki/Task-Options-DSL\#complex-options}
for Boot's documentation on the subject.) Basically, complex options
allow you to specify that option arguments should be treated as maps,
sets, vectors, or even nested collections. It's pretty powerful.
\switchcolumn
现在，让我们来看看THING。THING是一个\emph{optarg}，它表示该选项需要一个参数。在定义选项时，你不必包含optarg（注意到复数化选项没有optarg）。optarg不必对应于选项的全名；你可以将THING替换为BILLY\_JOEL或其他任何你想要的名称，任务将工作得一样好。你还可以使用optarg来指定复杂的选项。（请访问
\emph{https://github.com/boot-clj/boot/wiki/Task-Options-DSL\#complex-options}
，查看关于Boot的文档。）基本上，复杂选项允许你将选项参数处理为映射、集合、向量，甚至是嵌套集合。这非常强大。
\switchcolumn[0]*
Boot provides you with all the tools you could ask for to build command
line interfaces with Clojure. And you've only just started learning
about it!
\switchcolumn
Boot为你提供了构建Clojure命令行界面所需的所有工具。而你现在只是刚刚开始学习它！
\switchcolumn[0]*
\section{REPL}
\switchcolumn
\section{REPL}
\switchcolumn[0]*
Boot comes with a number of useful built-in tasks, including a REPL
task. Run boot repl to fire up that puppy. The Boot REPL is similar to
Leiningen's in that it handles loading your project code so you can play
around with it. You might not think this applies to the project you've
been writing because you've only written tasks, but you can actually run
tasks in the REPL (I've omitted the boot.user=\textgreater{} prompt).
You can specify options using a string:
\switchcolumn
Boot提供了许多有用的内置任务，包括一个REPL任务。运行boot repl来启动这个任务。Boot REPL与Leiningen的REPL类似，它会加载你的项目代码，这样你就可以对其进行操作。你可能认为这与你正在编写的项目无关，因为你只编写了任务，但实际上你可以在REPL中运行任务（我省略了boot.user=\textgreater{}提示符）。你可以使用字符串来指定选项：
\switchcolumn[0]*
\begin{verbatim}
(fire "-t" "NBA Jam guy")
; My NBA Jam guy is on fire!
; => nil
\end{verbatim}
\switchcolumn
\begin{verbatim}
(fire "-t" "NBA Jam guy")
; My NBA Jam guy is on fire!
; => nil
\end{verbatim}
\switchcolumn[0]*
Notice that the option's value comes right after the option.

You can also specify an option using a keyword:
\switchcolumn
注意选项的值紧跟在选项后面。

你还可以使用关键字来指定选项：
\switchcolumn[0]*
\begin{verbatim}
(fire :thing "NBA Jam guy")
; My NBA Jam guy is on fire!
; => nil
\end{verbatim}
\switchcolumn
\begin{verbatim}
(fire :thing "NBA Jam guy")
; My NBA Jam guy is on fire!
; => nil
\end{verbatim}
\switchcolumn[0]*
You can also combine options:
\switchcolumn
你还可以组合选项：
\switchcolumn[0]*
\begin{verbatim}
(fire "-p" "-t" "NBA Jam guys")
; My NBA Jam guys are on fire!
; => nil

(fire :pluralize true :thing "NBA Jam guys")
; My NBA Jam guys are on fire!
; => nil
\end{verbatim}
\switchcolumn
\begin{verbatim}
(fire "-p" "-t" "NBA Jam guys")
; My NBA Jam guys are on fire!
; => nil

(fire :pluralize true :thing "NBA Jam guys")
; My NBA Jam guys are on fire!
; => nil
\end{verbatim}
\switchcolumn[0]*
And of course, you can use deftask in the REPL as well---it's just
Clojure, after all. The takeaway is that Boot lets you interact with
your tasks as Clojure functions, because that's what they are.
\switchcolumn
当然，你也可以在REPL中使用deftask——毕竟它就是Clojure。关键是，Boot允许你将任务作为Clojure函数与之交互，因为它们本质上就是函数。
\switchcolumn[0]*
\section{Composition and Coordination}
\switchcolumn
\section{组合和协调}
\switchcolumn[0]*
If what you've seen so far was all that Boot had to offer, it'd be a
pretty swell tool, but it wouldn't be very different from other build
tools. One feature that sets Boot apart is how it lets you compose
tasks. For comparison's sake, here's an example Rake invocation (Rake is
the premier Ruby build tool):
\switchcolumn
如果到目前为止你所见到的就是Boot所提供的全部功能，那么它将是一个非常棒的工具，但并不与其他构建工具有多大区别。Boot的一个与众不同之处在于它允许你组合任务。为了进行比较，这里是一个Rake调用的例子（Rake是最好的Ruby构建工具）：
\switchcolumn[0]*
\begin{verbatim}
rake db:create db:migrate db:seed
\end{verbatim}
\switchcolumn
\begin{verbatim}
rake db:create db:migrate db:seed
\end{verbatim}
\switchcolumn[0]*
This code will create a database, run migrations on it, and populate it
with seed data when run in a Rails project. However, worth noting is
that Rake doesn't provide any way for these tasks to communicate with
each other. Specifying multiple tasks is just a convenience, saving you
from having to run rake db:create; rake db:migrate; rake db:seed. If you
want to access the result of Task A within Task B, the build tool
doesn't help you; you have to manage that coordination yourself.
Usually, you'll do this by shoving the result of Task A into a special
place on the filesystem and then making sure Task B reads that special
place. This looks like programming with mutable, global variables, and
it's just as brittle.
\switchcolumn
当在Rails项目中运行时，此代码将创建一个数据库，在其上运行迁移，并用种子数据填充它。然而值得注意的是，Rake不提供任何方式让这些任务相互通信。指定多个任务只是一种方便，省去了运行rake db:create; rake db:migrate; rake db:seed的麻烦。如果你想在任务A中访问任务A的结果，构建工具并没有帮助你；你必须自己管理协调。通常，你会将任务A的结果放入文件系统的一个特殊位置，然后确保任务B读取该特殊位置。这看起来就像是使用可变的全局变量进行编程，同样脆弱。
\switchcolumn[0]*
\subsubsection{Handlers and Middleware}
\switchcolumn
\subsubsection{处理器和中间件}
\switchcolumn[0]*
Boot addresses this task communication problem by treating tasks as
\emph{middleware factories}. If you're familiar with Ring, Boot's tasks
work very similarly, so feel free to skip to
``\href{javascript:void(0)}{Tasks Are Middleware Factories}'' on
\href{javascript:void(0)}{page 287}. If you're not familiar with the
concept of middleware, allow me to explain! \emph{Middleware} refers to
a set of \emph{conventions} that programmers adhere to so they can
flexibly create domain-specific function pipelines. That's pretty dense,
so let's un-dense it. I'll discuss the \emph{flexible} part in this
section and cover \emph{domain-specific} in
``\href{javascript:void(0)}{Filesets}'' on
\href{javascript:void(0)}{page 288}.
\switchcolumn
Boot通过将任务视为\emph{中间件工厂}来解决这个任务通信问题。如果你熟悉Ring，Boot的任务工作方式非常相似，所以可以直接跳到第287页的``任务是中间件工厂''部分。如果你对中间件的概念不熟悉，让我来解释一下！\emph{中间件}是指程序员遵循的一组\emph{约定}，以便能够灵活地创建特定于领域的函数流水线。这听起来有点复杂，让我们来简化一下。在本节中，我将讨论灵活性的部分，并在第288页的``文件集''中讨论\emph{特定于领域}的部分。
\switchcolumn[0]*
To understand how the middleware approach differs from run-of-the-mill
function composition, here's an example of composing everyday functions:
\begin{verbatim}
(def strinc (comp str inc))
(strinc 3)
; => "4"
\end{verbatim}
\switchcolumn
为了理解中间件方法与普通函数组合的不同之处，这里有一个组合常规函数的示例：
\begin{verbatim}
(def strinc (comp str inc))
(strinc 3)
; => "4"
\end{verbatim}
\switchcolumn[0]*
There's nothing interesting about this function composition. In fact,
this function composition is so unremarkable that it strains my
abilities as a writer to actually say anything about it. There are two
functions, each does its own thing, and now they've been composed into
one. Whoop-dee-doo!
\switchcolumn
这个函数组合并没有什么特别的。实际上，这个函数组合是如此平凡，以至于作为作者实际上无法对其说出任何有意义的话。有两个函数，每个函数都做自己的事情，现在它们被组合成一个函数。太棒了！
\switchcolumn[0]*
Middleware introduces an extra step to function composition, giving you
more flexibility in defining your function pipeline. Suppose, in the
preceding example, that you wanted to return "I don't like the number X"
for arbitrary numbers but return a string-ified number for everything
else. Here's how you could do that:
\switchcolumn
中间件在函数组合中引入了一个额外的步骤，使您能够更灵活地定义函数流水线。假设在前面的示例中，您想要对任意数字返回"I don't like the number X"，但对其他所有内容返回字符串化的数字。您可以这样做：
\switchcolumn[0]*
\begin{verbatim}
(defn whiney-str
    [rejects]
    {:pre [(set? rejects)]}
    (fn [x]
    (if (rejects x)
        (str "I don't like " x)
        (str x))))

(def whiney-strinc (comp (whiney-str #{2}) inc))
(whiney-strinc 1)
; => "I don't like 2"
\end{verbatim}
\switchcolumn
\begin{verbatim}
(defn whiney-str
    [rejects]
    {:pre [(set? rejects)]}
    (fn [x]
    (if (rejects x)
        (str "I don't like " x)
        (str x))))

(def whiney-strinc (comp (whiney-str #{2}) inc))
(whiney-strinc 1)
; => "I don't like 2"
\end{verbatim}
\switchcolumn[0]*
Now let's take it one step further. What if you want to decide whether
or not to call inc in the first place? \href{javascript:void(0)}{Listing
B-1} shows how you could do that:
\begin{verbatim}
(defn whiney-middleware
    [next-handler rejects]
    {:pre [(set? rejects)]}
    (fn [x]
    (if (= x 1)
        "I'm not going to bother doing anything to that"
        (let [y (next-handler x)]
            (if (rejects y)
            (str "I don't like " y)
            (str y))))))

(def whiney-strinc (whiney-middleware inc #{2}))
(whiney-strinc 1)
; => "I don't like 2"
\end{verbatim}
\emph{Listing B-1: The middleware approach to function composition lets
you introduce choice}
\switchcolumn
现在让我们再进一步。如果您想要决定是否调用inc呢？\href{javascript:void(0)}{清单B-1}展示了如何实现：
\begin{verbatim}
(defn whiney-middleware
    [next-handler rejects]
    {:pre [(set? rejects)]}
    (fn [x]
    (if (= x 1)
        "I'm not going to bother doing anything to that"
        (let [y (next-handler x)]
            (if (rejects y)
            (str "I don't like " y)
            (str y))))))

(def whiney-strinc (whiney-middleware inc #{2}))
(whiney-strinc 1)
; => "I don't like 2"
\end{verbatim}
\emph{清单B-1：中间件方法可以引入选择}
\switchcolumn[0]*
Here, instead of using comp to create your function pipeline, you pass
the next function in the pipeline as the first argument to the
middleware function. In this case, you're passing inc as the first
argument to whiney-middleware as next-handler. whiney-middleware then
returns an anonymous function that closes over inc and has the ability
to choose whether to call it or not. You can see this choice at ➊.
\switchcolumn
在这里，您不是使用comp创建函数流水线，而是将下一个函数作为中间件函数的第一个参数传递。在这种情况下，您将inc作为下一个处理程序作为第一个参数传递给whiney-middleware作为next-handler。whiney-middleware然后返回一个匿名函数，该函数闭包inc并具有选择是否调用它的能力。您可以在➊处看到这个选择。
\switchcolumn[0]*
We say that a middleware takes a handler as its first argument and
returns a handler. In this example, whiney-middleware takes a handler as
its first argument, inc, and it returns another handler, the anonymous
function with x as its only argument. Middleware can also take extra
arguments, like rejects, that act as configuration. The result is that
the handler returned by the middleware can behave more flexibly (thanks
to configuration), and it has more control over the function pipeline
(because it can choose whether or not to call the next handler).
\switchcolumn
我们说中间件将处理程序作为其第一个参数并返回处理程序。在这个示例中，whiney-middleware将处理程序作为其第一个参数，即inc，并返回另一个处理程序，即只有x作为唯一参数的匿名函数。中间件还可以接受额外的参数，比如rejects，它们充当配置。结果是，由中间件返回的处理程序可以更灵活地行为（由于配置），并且它对函数流水线有更多的控制。


\switchcolumn[0]*
\subsubsection{Tasks Are Middleware Factories}
\switchcolumn
\subsubsection{任务是中间件工厂}
\switchcolumn[0]*
Boot takes this pattern of making function composition more flexible one
step further by separating middleware configuration from handler
creation. First, you create a function that takes \emph{n} configuration
arguments. This is the \emph{middleware factory}, and it returns a
middleware function. The middleware function expects one argument, the
next handler, and it returns a handler, just like in the preceding
example. Here's a whiney middleware factory:
\begin{verbatim}
(defn whiney-middleware-factory
    [rejects]
    {:pre [(set? rejects)]}
    (fn [next-handler]
    (fn [x]
        (if (rejects x)
        (str "I don't like " x)
        (str x)))))

(def whiney-strinc (whiney-middleware-factory #{2}))
(whiney-strinc 1)
; => "I don't like 2"
\end{verbatim}
\switchcolumn
Boot将使函数组合更加灵活的模式进一步发展，通过将中间件配置与处理程序创建分离。首先，您创建一个接受\emph{n}个配置参数的函数。这就是\emph{中间件工厂}，它返回一个中间件函数。中间件函数期望一个参数，即下一个处理程序，并返回一个处理程序，就像前面的示例一样。这是一个whiney中间件工厂的例子：
\begin{verbatim}
(defn whiney-middleware-factory
    [rejects]
    {:pre [(set? rejects)]}
    (fn [next-handler]
    (fn [x]
        (if (rejects x)
        (str "I don't like " x)
        (str x)))))

(def whiney-strinc (whiney-middleware-factory #{2}))
(whiney-strinc 1)
; => "I don't like 2"
\end{verbatim}
\switchcolumn[0]*
As you can see, this code is nearly identical to
\href{javascript:void(0)}{Listing B-1}. The change is that the topmost
function, whiney-middleware-factory, now only accepts one argument,
rejects. It returns an anonymous function, the middleware, which expects
one argument, a handler. The rest of the code is the same.
\switchcolumn
正如您所看到的，这段代码与\href{javascript:void(0)}{B-1清单}几乎完全相同。变化在于最上面的函数whiney-middleware-factory现在只接受一个参数rejects。它返回一个匿名函数，即中间件，该中间件期望一个参数handler。其余的代码都是相同的。
\switchcolumn[0]*
In Boot, tasks can act as middleware factories. To show this, let's
split the fire task into two tasks: what and fire (see
\href{javascript:void(0)}{Listing B-2}). what lets you specify an object
and whether it's plural, and fire announces that it's on fire. This is
great modular software engineering because it allows you to add other
tasks, like gnomes, to announce that a thing is being overrun with
gnomes, which is just as objectively useful. (As an exercise, try
creating the gnome task. It should compose with the what task, just as
fire does.)
\switchcolumn
在Boot中，任务可以充当中间件工厂。为了展示这一点，让我们将fire任务拆分为两个任务：what和fire（参见\href{javascript:void(0)}{B-2清单}）。what允许您指定一个对象以及它是否为复数形式，而fire则宣布该对象着火。这是一种很好的模块化软件工程，因为它允许您添加其他任务，比如gnomes任务，用于宣布某个事物被gnomes入侵，这同样是客观有用的。（作为练习，尝试创建gnomes任务。它应该与what任务组合，就像fire任务一样。）
\switchcolumn[0]*
\begin{verbatim}
(deftask what
    "Specify a thing"
    [t thing     THING str  "An object"
    p pluralize       bool "Whether to pluralize"]
    (fn middleware [next-handler]
➊     (fn handler [fileset]
        (next-handler (merge fileset {:thing thing :pluralize pluralize})))))
(deftask fire
    "Announce a thing is on fire"
    []
    (fn middleware [next-handler]
➋     (fn handler [fileset]
        (let [verb (if (:pluralize fileset) "are" "is")]

        (println "My" (:thing fileset) verb "on fire!")
        fileset))))
\end{verbatim}
\switchcolumn
\begin{verbatim}
(deftask what
    "Specify a thing"
    [t thing     THING str  "An object"
    p pluralize       bool "Whether to pluralize"]
    (fn middleware [next-handler]
➊     (fn handler [fileset]
        (next-handler (merge fileset {:thing thing :pluralize pluralize})))))
(deftask fire
    "Announce a thing is on fire"
    []
    (fn middleware [next-handler]
➋     (fn handler [fileset]
        (let [verb (if (:pluralize fileset) "are" "is")]

        (println "My" (:thing fileset) verb "on fire!")
        fileset))))
\end{verbatim}
\switchcolumn[0]*
\emph{Listing B-2: The full code for composable Boot tasks that announce
something's on fire}
\switchcolumn
\emph{清单B-2：可组合的Boot任务的完整代码，用于宣布某个事物着火}
\switchcolumn[0]*
Here's how you'd run this on the command line:
\switchcolumn
以下是如何在命令行中运行它的方式：
\switchcolumn[0]*
\begin{verbatim}
boot what -t "pants" -p – fire
\end{verbatim}
\switchcolumn
\begin{verbatim}
boot what -t "pants" -p – fire
\end{verbatim}
\switchcolumn[0]*
And here's how you'd run it in the REPL:
\switchcolumn
以下是在REPL中运行它的方式：
\switchcolumn[0]*
\begin{verbatim}
(boot (what :thing "pants" :pluralize true) (fire))
\end{verbatim}
\switchcolumn
\begin{verbatim}
(boot (what :thing "pants" :pluralize true) (fire))
\end{verbatim}

\switchcolumn[0]*
Wait a minute, what's that boot call doing there? And what's with
fileset at ➊ and ➋? In Micha's words, ``The boot macro takes care of
setup and cleanup (creating the initial fileset, stopping servers
started by tasks, things like that). Tasks are functions, so you can
call them directly, but if they use the fileset, they will fail unless
you call them via the boot macro.'' Let's take a closer look at
filesets.
\switchcolumn
等一下，那个boot调用在那里做什么？而且在➊和➋处的fileset是什么意思？用Micha的话来说，``boot宏负责设置和清理（创建初始的fileset，停止任务启动的服务器等等）。任务是函数，所以您可以直接调用它们，但如果它们使用fileset，除非通过boot宏调用它们，否则它们将失败。''让我们更仔细地看一下fileset。
\switchcolumn[0]*
\section{Filesets}
\switchcolumn
\section{文件集}
\switchcolumn[0]*
Earlier I mentioned that middleware is for creating
\emph{domain-specific} function pipelines. All that means is that each
handler expects to receive domain-specific data and returns
domain-specific data. With Ring, for example, each handler expects to
receive a request map representing the HTTP request, which might look
something like this:
\begin{verbatim}
{:server-port 80
    :request-method :get
    :scheme :http}
\end{verbatim}
\switchcolumn
前面我提到中间件用于创建\emph{领域特定}函数管道。这只是意味着每个处理程序都期望接收领域特定的数据并返回领域特定的数据。例如，在Ring中，每个处理程序都期望接收代表HTTP请求的请求映射，可能如下所示：
\begin{verbatim}
{:server-port 80
    :request-method :get
    :scheme :http}
\end{verbatim}
\switchcolumn[0]*
Each handler can choose to modify this request map in some way before
passing it on to the next handler, say, by adding a :params key with a
nice Clojure map of all query string and POST parameters. Ring handlers
return a \emph{response map}, which consists of the keys :status,
:headers, and :body, and once again each handler can transform this data
in some way before returning it to its parent handler.
\switchcolumn
每个处理程序可以选择在将请求映射传递给下一个处理程序之前以某种方式修改它，例如通过添加具有所有查询字符串和POST参数的漂亮Clojure映射的:params键。Ring处理程序返回一个\emph{响应映射}，其中包含键：status、headers和body，同样，每个处理程序可以在将数据返回给其父处理程序之前以某种方式转换此数据。
\switchcolumn[0]*
In Boot, each handler receives and returns a \emph{fileset}. The fileset
abstraction lets you treat files on your filesystem as immutable data,
and this is a great innovation for build tools because building projects
is so file-centric. For example, your project might need to place
temporary, intermediary files on the filesystem. Usually, with most
build tools, these files get placed in some specially named place, say,
\emph{project/target/tmp}. The problem with this is that
\emph{project/target/tmp} is effectively a global variable, and other
tasks can accidentally muck it up.
\switchcolumn
在Boot中，每个处理程序接收和返回一个\emph{文件集}。文件集抽象允许您将文件系统上的文件视为不可变数据，这对于构建工具来说是一个很好的创新，因为构建项目与文件密切相关。例如，您的项目可能需要将临时中间文件放置在文件系统上。通常情况下，在大多数构建工具中，这些文件会被放置在某个特定命名的位置，比如\emph{project/target/tmp}。使用这种方式的问题在于\emph{project/target/tmp}实际上是一个全局变量，其他任务可能会意外地破坏它。
\switchcolumn[0]*
Boot's fileset abstraction solves this problem by adding a layer of
indirection on top of the filesystem. Let's say Task A creates File X
and tells the fileset to store it. Behind the scenes, the fileset stores
the file in an anonymous, temporary directory. The fileset then gets
passed to Task B, and Task B modifies File X and asks the fileset to
store the result. Behind the scenes, a new file, File Y, is created and
stored, but File X remains untouched. In Task B, an updated fileset is
returned. This is the equivalent of doing assoc-in with a map: Task A
can still access the original fileset and the files it references.
\switchcolumn
Boot的文件集抽象通过在文件系统之上添加一层间接性来解决了这个问题。假设任务A创建了文件X并告诉文件集将其存储起来。在幕后，文件集将文件存储在一个匿名的临时目录中。然后将文件集传递给任务B，任务B修改文件X并要求文件集存储结果。在幕后，创建并存储了一个新文件Y，但文件X保持不变。在任务B中，返回了一个更新后的文件集。这相当于对具有map的assoc-in操作：任务A仍然可以访问原始文件集和它引用的文件。
\switchcolumn[0]*
And you didn't even use any of this cool file management functionality
in the what and fire tasks in \href{javascript:void(0)}{Listing B-2}!
Nevertheless, when Boot composes tasks, it expects handlers to receive
and return fileset records. Therefore, to convey your data across tasks,
you sneakily added it to the fileset record using (merge fileset
\{:thing thing :pluralize pluralize\}).
\switchcolumn
你甚至没有使用\href{javascript:void(0)}{图例B-2}中的what和fire任务中的任何这些酷炫的文件管理功能！然而，当Boot组合任务时，它期望处理程序接收和返回文件集记录。因此，为了在任务之间传递数据，你偷偷地使用(merge fileset {:thing thing :pluralize pluralize})将数据添加到文件集记录中。
\switchcolumn[0]*
Although that covers the basic concept of a middleware factory, you'll
need to learn a bit more to take full advantage of filesets. The
mechanics of working with filesets are all explained in the fileset wiki
(\emph{https://github.com/boot-clj/boot/wiki/Filesets}). In the
meantime, I hope this information gave you a good conceptual overview!
\switchcolumn
虽然这只涵盖了中间件工厂的基本概念，但你还需要学习更多知识，以充分利用文件集。关于如何使用文件集的机制在文件集维基(\emph{https://github.com/boot-clj/boot/wiki/Filesets})中都有详细解释。与此同时，希望这些信息能给你提供一个良好的概念概述！
\switchcolumn[0]*
\section{Next Steps}
\switchcolumn
\section{下一步}

\switchcolumn[0]*
The point of this appendix was to explain the concepts behind Boot.
However, Boot also has a bunch of other functions, like set-env! and
task-options!, that make your programming life easier when you're
actually using it. It offers amazing magical features, like providing
classpath isolation so you can run multiple projects using one JVM, and
letting you add new dependencies to your project without having to
restart your REPL. If Boot tickles your fancy, check out its README for
more information on real-world usage. Also, its wiki provides top-notch
documentation.
\switchcolumn
本附录的目的是解释Boot背后的概念。然而，Boot还有很多其他功能，如set-env!和task-options!，在你实际使用它时可以让你的编程生活更轻松。它提供了一些神奇的特性，比如提供类路径隔离，这样你就可以在一个JVM上运行多个项目，而且可以在不重新启动REPL的情况下添加新的依赖项到你的项目中。如果Boot引起了你的兴趣，请查阅它的README以获取有关实际用法的更多信息。此外，它的维基提供了一流的文档。
\end{paracol}
