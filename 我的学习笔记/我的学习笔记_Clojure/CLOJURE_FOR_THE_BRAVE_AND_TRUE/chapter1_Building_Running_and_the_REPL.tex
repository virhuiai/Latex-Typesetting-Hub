% \part{Environment Setup}% \textbf{Part I}\\
% \textbf{第一部分}\\
% \textbf{环境设置}

\chapter{Building, Running, and the REPL}
% 构建、运行和REPL
\columnratio{0.55}
\begin{paracol}{2}
\switchcolumn[0]*
In this chapter, you'll invest a small amount of time up front to get
familiar with a quick, foolproof way to build and run Clojure programs.
It feels great to get a real program running. Reaching that milestone
frees you up to experiment, share your work, and gloat to your
colleagues who are still using last decade's languages. This will help
keep you motivated!
\switchcolumn
在本章中，您将花费一小部分时间来熟悉一种快速、可靠的构建和运行Clojure程序的方法。让一个真正的程序运行起来感觉很棒。达到这个里程碑将使您能够自由地进行实验，分享您的工作，并向那些仍在使用上个十年语言的同事炫耀。这将有助于保持您的动力！
\switchcolumn[0]*
You'll also learn how to instantly run code within a running Clojure
process using a \emph{Read-Eval-Print Loop (REPL)}, which allows you to
quickly test your understanding of the language and learn more
efficiently.
\switchcolumn
您还将学习如何使用\emph{Read-Eval-Print Loop (REPL)}在运行中的Clojure进程中立即运行代码，这样可以快速测试您对语言的理解并更有效地学习。
\switchcolumn[0]*
But first, I'll briefly introduce Clojure. Next, I'll cover Leiningen,
the de facto standard build tool for Clojure. By the end of the chapter,
you'll know how to do the following:
\switchcolumn
但首先，我将简要介绍Clojure。接下来，我将介绍Leiningen，Clojure的事实上的标准构建工具。在本章结束时，您将知道如何执行以下操作：

\begin{itemize}
\switchcolumn[0]*
\item Create a new Clojure project with Leiningen
\switchcolumn
\item 使用Leiningen创建一个新的Clojure项目
\switchcolumn[0]*
\item Build the project to create an executable JAR file
\switchcolumn
\item 构建项目以创建可执行的JAR文件
\switchcolumn[0]*
\item Execute the JAR file
\switchcolumn
\item 执行JAR文件
\switchcolumn[0]*
\item Execute code in a Clojure REPL
\switchcolumn
\item 在Clojure REPL中执行代码
\end{itemize}
\switchcolumn[0]*
\section{First Things First: What Is Clojure?}
\switchcolumn
\section{首先要明确的是：Clojure是什么？}
\switchcolumn[0]*
Clojure was forged in a mythic volcano by Rich Hickey. Using an alloy of
Lisp, functional programming, and a lock of his own epic hair, he
crafted a language that's delightful yet powerful. Its Lisp heritage
gives you the power to write code more expressively than is possible in
most non-Lisp languages, and its distinct take on functional programming
will sharpen your thinking as a programmer. Plus, Clojure gives you
better tools for tackling complex domains (like concurrent programming)
that are traditionally known to drive developers into years of therapy.
\switchcolumn
Clojure是由Rich Hickey在一个神话般的火山中锻造而成的。他使用了Lisp、函数式编程和他自己史诗般的头发的一缕合金，创造了一种既令人愉悦又强大的语言。它的Lisp传统使您能够以比大多数非Lisp语言更富有表现力的方式编写代码，并且它对函数式编程的独特理解将增强您作为程序员的思维能力。此外，Clojure为您提供了更好的工具来处理复杂的领域（如并发编程），而这些领域通常被认为会让开发人员陷入多年的治疗中。
\switchcolumn[0]*
When talking about Clojure, though, it's important to keep in mind the
distinction between the Clojure language and the Clojure compiler. The
Clojure language is a Lisp dialect with a functional emphasis whose
syntax and semantics are independent of any implementation. The compiler
is an executable JAR file, \emph{clojure.jar}, which takes code written
in the Clojure language and compiles it to Java Virtual Machine (JVM)
bytecode. You'll see \emph{Clojure} used to refer to both the language
and the compiler, which can be confusing if you're not aware that
they're separate things. But now that you're aware, you'll be fine.
\switchcolumn
然而，在谈论Clojure时，重要的是要区分Clojure语言和Clojure编译器之间的区别。Clojure语言是一个带有函数式强调的Lisp方言，其语法和语义与任何实现无关。编译器是一个可执行的JAR文件\emph{clojure.jar}，它将用Clojure语言编写的代码编译为Java虚拟机（JVM）字节码。您会看到\emph{Clojure}一词既用于指代语言，也用于指代编译器，如果您不知道它们是分开的，这可能会让您感到困惑。但是现在您知道了，一切都会没事的。
\switchcolumn[0]*
This distinction is necessary because, unlike most programming languages
like Ruby, Python, C, and a bazillion others, Clojure is a \emph{hosted
language}. Clojure programs are executed within a JVM and rely on the
JVM for core features like threading and garbage collection. Clojure
also targets JavaScript and the Microsoft Common Language Runtime (CLR),
but this book only focuses on the JVM implementation.
\switchcolumn
之所以需要这种区分，是因为与大多数编程语言（如Ruby、Python、C等等）不同，Clojure是一种\emph{托管语言}。Clojure程序在JVM内执行，并依赖JVM提供核心功能，如线程和垃圾回收。Clojure还支持JavaScript和Microsoft Common Language Runtime (CLR)，但本书只关注JVM实现。
\switchcolumn[0]*
We'll explore the relationship between Clojure and the JVM more later
on, but for now the main concepts you need to understand are these:
\switchcolumn
我们将在后面更详细地探讨Clojure与JVM之间的关系，但目前您需要了解的主要概念是：
\begin{itemize}
\switchcolumn[0]*
\item JVM processes execute Java bytecode.
\switchcolumn
\item JVM进程执行Java字节码。
\switchcolumn[0]*
\item Usually, the Java Compiler produces Java bytecode from Java source
code.
\switchcolumn
\item 通常，Java编译器会从Java源代码生成Java字节码。
\switchcolumn[0]*
\item JAR files are collections of Java bytecode.
\switchcolumn
JAR文件是Java字节码的集合。
\switchcolumn[0]*
\item Java programs are usually distributed as JAR files.
\switchcolumn
\item Java程序通常以JAR文件的形式分发。
\switchcolumn[0]*
\item The Java program \emph{clojure.jar} reads Clojure source code and
produces Java bytecode.
\switchcolumn
\item Java程序\emph{clojure.jar}读取Clojure源代码并生成Java字节码。
\switchcolumn[0]*
\item That Java bytecode is then executed by the same JVM process already
running \emph{clojure.jar}.
\switchcolumn
\item 然后，同一JVM进程中已经运行的\emph{clojure.jar}执行该Java字节码。
\end{itemize}
\switchcolumn[0]*
Clojure continues to evolve. As of this writing, it's at version 1.7.0,
and development is going strong. If you're reading this book in the far
future and Clojure has a higher version number, don't worry! This book
covers Clojure's fundamentals, which shouldn't change from one version
to the next. There's no need for your robot butler to return this book
to the bookstore.
\switchcolumn
Clojure不断发展。截至本书编写时，它的版本为1.7.0，并且开发工作正在进行中。如果你在未来的某个时间阅读本书，而Clojure的版本号更高，不要担心！本书涵盖了Clojure的基础知识，这些知识不应该随着版本变化而改变。你的机器人管家没有必要把本书退还给书店。
\switchcolumn[0]*
Now that you know what Clojure is, let's actually build a freakin'
Clojure program!
\switchcolumn
现在你知道Clojure是什么了，让我们来实际构建一个Clojure程序吧！
\switchcolumn[0]*
\section{Leiningen}
\switchcolumn
\section{Leiningen}
\switchcolumn[0]*
These days, most Clojurists use Leiningen to build and manage their
projects. You can read a full description of Leiningen in
\href{javascript:void(0)}{Appendix A}, but for now we'll focus on using
it for four tasks:
\switchcolumn
现在大多数Clojure开发人员使用Leiningen来构建和管理他们的项目。你可以在\href{javascript:void(0)}{附录A}中阅读关于Leiningen的完整描述，但现在我们将重点介绍使用Leiningen执行以下四个任务：
\begin{enumerate}
\switchcolumn[0]*
\item  Creating a new Clojure project
\switchcolumn
\item  创建一个新的Clojure项目
\switchcolumn[0]*
\item  Running the Clojure project
\switchcolumn
\item  运行Clojure项目
\switchcolumn[0]*
\item  Building the Clojure project
\switchcolumn
\item  构建Clojure项目
\switchcolumn[0]*
\item  Using the REPL
\switchcolumn
\item  使用REPL
\end{enumerate}

\switchcolumn[0]*
Before continuing, make sure you have Java version 1.6 or later
installed. You can check your version by running java -version in your
terminal, and download the latest Java Runtime Environment (JRE)\footnote{from
\emph{http://www.oracle.com/technetwork/java/javase/downloads/index.html}}.
Then, install Leiningen using the instructions on the Leiningen home
page at \emph{http://leiningen.org/} (Windows users, note there's a
Windows installer). When you install Leiningen, it automatically
downloads the Clojure compiler, \emph{clojure.jar}.
\switchcolumn
在继续之前，请确保你已经安装了Java版本1.6或更高版本。你可以在终端中运行java -version命令来检查你的版本，并下载\footnote{从\emph{http://www.oracle.com/technetwork/java/javase/downloads/index.html}}最新的Java Runtime Environment (JRE)。然后，按照\emph{http://leiningen.org/}主页上的说明安装Leiningen（Windows用户请注意，有一个Windows安装程序）。当你安装Leiningen时，它会自动下载Clojure编译器\emph{clojure.jar}。
\switchcolumn[0]*
\subsection{Creating a New Clojure Project}
\switchcolumn
\subsection{创建一个新的Clojure项目}
\switchcolumn[0]*
Creating a new Clojure project is very simple. A single Leiningen
command creates a project skeleton. Later, you'll learn how to do tasks
like incorporate Clojure libraries, but for now, these instructions will
enable you to execute the code you write.
\switchcolumn
创建一个新的Clojure项目非常简单。一个Leiningen命令就可以创建一个项目骨架。稍后，你将学习如何执行诸如整合Clojure库之类的任务，但现在这些说明将使你能够执行你编写的代码。
\switchcolumn[0]*
Go ahead and create your first Clojure project by typing the following
in your terminal:
\switchcolumn
在终端中输入以下命令，创建你的第一个Clojure项目：
\switchcolumn[0]*
\begin{verbatim}
lein new app clojure-noob
\end{verbatim}
\switchcolumn
\begin{verbatim}
lein new app clojure-noob
\end{verbatim}
\switchcolumn[0]*
This command should create a directory structure that looks similar to
this (it's okay if there are some differences):
\switchcolumn
这个命令应该会创建一个类似下面这样的目录结构（如果有一些差异也没关系）：
\switchcolumn[0]*
\begin{verbatim}
| .gitignore
| doc
| | intro.md
➊ | project.clj
| README.md
➋ | resources
| src

| | clojure_noob
➌ | | | core.clj
➍ | test
| | clojure_noob
| | | core_test.clj
\end{verbatim}
\switchcolumn
\begin{verbatim}
| .gitignore
| doc
| | intro.md
➊ | project.clj
| README.md
➋ | resources
| src

| | clojure_noob
➌ | | | core.clj
➍ | test
| | clojure_noob
| | | core_test.clj
\end{verbatim}
\switchcolumn[0]*
This project skeleton isn't inherently special or Clojure-y. It's just a
convention used by Leiningen. You'll be using Leiningen to build and run
Clojure apps, and Leiningen expects your app to have this structure. The
first file of note is \emph{project.clj} at ➊, which is a configuration
file for Leiningen. It helps Leiningen answer such questions as ``What
dependencies does this project have?'' and ``When this Clojure program
runs, what function should run first?'' In general, you'll save your
your source code in \emph{src/\textless project\_name\textgreater{}}. In
this case, the file \emph{src/clojure\_noob/core.clj} at ➌ is where
you'll be writing your Clojure code for a while. The \emph{test}
directory at ➍ obviously contains tests, and \emph{resources} at ➋ is
where you store assets like images.
\switchcolumn
这个项目骨架本身并没有什么特别的或者特定于Clojure的东西。它只是Leiningen使用的一种约定。你将使用Leiningen来构建和运行Clojure应用程序，而Leiningen希望你的应用程序具有这种结构。第一个要注意的文件是位于➊处的\emph{project.clj}，这是Leiningen的配置文件。它帮助Leiningen回答诸如“这个项目有哪些依赖项？”和“当这个Clojure程序运行时，哪个函数应该首先运行？”这样的问题。通常情况下，你会将源代码保存在\emph{src/\textless project\_name\textgreater{}}中。在这个例子中，文件\emph{src/clojure\_noob/core.clj}位于➌处，你将在其中写入你的Clojure代码。➍处的\emph{test}目录显然包含测试代码，而\emph{resources}目录位于➋处，用于存储像图像之类的资源文件。
\switchcolumn[0]*
\subsection{Running the Clojure Project}
\switchcolumn
\subsection{运行Clojure项目}
\switchcolumn[0]*
Now let's actually run the project. Open
\emph{src/clojure\_noob/core.clj} in your favorite editor. You should
see this:
\switchcolumn
现在让我们实际运行这个项目。在你喜欢的编辑器中打开\emph{src/clojure\_noob/core.clj}。你应该会看到以下内容：
\switchcolumn[0]*
\begin{verbatim}
➊ (ns clojure-noob.core
        (:gen-class))
➋ (defn -main
        "I don't do a whole lot...yet."
        [& args]
➌   (println "Hello, World!"))
\end{verbatim}
\switchcolumn
\begin{verbatim}
➊ (ns clojure-noob.core
        (:gen-class))
➋ (defn -main
        "I don't do a whole lot...yet."
        [& args]
➌   (println "Hello, World!"))
\end{verbatim}

\switchcolumn[0]*
The lines at ➊ declare a namespace, which you don't need to worry about
right now. The -main function at ➋ is the \emph{entry point} to your
program, a topic that is covered in \href{javascript:void(0)}{Appendix
A}. For now, replace the text "Hello, World!" at ➌ with "I'm a little
teapot!". The full line should read (println "I'm a little teapot!")).
\switchcolumn
➊处的代码声明了一个命名空间，你现在不需要担心它。➋处的-main函数是你程序的\emph{入口点}，这个主题在\href{javascript:void(0)}{附录A}中有介绍。现在，将➌处的文本“Hello, World!”替换为“I'm a little teapot!”。完整的行应该是(println "I'm a little teapot!")。
\switchcolumn[0]*
Next, navigate to the \emph{clojure\_noob} directory in your terminal
and enter:
\begin{verbatim}
lein run
\end{verbatim}
\switchcolumn
接下来，在终端中导航到\emph{clojure\_noob}目录，并输入以下命令：
\begin{verbatim}
lein run
\end{verbatim}
\switchcolumn[0]*
You should see the output "I'm a little teapot!" Congratulations, little
teapot, you wrote and executed a program!
\switchcolumn
如果一切顺利，你将在终端中看到输出的消息：“I'm a little teapot!”
\switchcolumn[0]*
You'll learn more about what's actually happening in the program as you
read through the book, but for now all you need to know is that you
created a function, -main, and that function runs when you execute lein
run at the command line.
\switchcolumn
当您阅读本书时，您将更多地了解程序中实际发生的情况，但现在您只需要知道您创建了一个函数，-main，并且当您在命令行上执行lein run时，该函数将运行。
\switchcolumn[0]*
\subsection{Building the Clojure Project}
\switchcolumn
\subsection{构建Clojure项目}
\switchcolumn[0]*
Using lein run is great for trying out your code, but what if you want
to share your work with people who don't have Leiningen installed? To do
that, you can create a stand-alone file that anyone with Java installed
(which is basically everyone) can execute. To create the file, run this:
\begin{verbatim}
lein uberjar
\end{verbatim}
\switchcolumn
使用lein run非常适合尝试你的代码，但是如果你想与没有安装Leiningen的人分享你的工作呢？为了实现这一点，你可以创建一个独立的文件，任何安装了Java（基本上是每个人）的人都可以执行。要创建该文件，请运行以下命令：
\begin{verbatim}
lein uberjar
\end{verbatim}
\switchcolumn[0]*
This command creates the file \emph{target/uberjar/clojure-noob-0.1.0
-SNAPSHOT-standalone.jar}. You can make Java execute it by running this:
\begin{verbatim}
java -jar target/uberjar/clojure-noob-0.1.0-SNAPSHOT-standalone.jar
\end{verbatim}
\switchcolumn
该命令会创建文件\emph{target/uberjar/clojure-noob-0.1.0-SNAPSHOT-standalone.jar}。你可以通过运行以下命令让Java执行该文件：
\begin{verbatim}
java -jar target/uberjar/clojure-noob-0.1.0-SNAPSHOT-standalone.jar
\end{verbatim}
\switchcolumn[0]*
Look at that! The file \emph{target/uberjar/clojure-noob-0.1.0-SNAPSHOT
-standalone.jar} is your new, award-winning Clojure program, which you
can distribute and run on almost any platform.
\switchcolumn
看到了吗！文件\emph{target/uberjar/clojure-noob-0.1.0-SNAPSHOT-standalone.jar}就是你的新的、屡获殊荣的Clojure程序，你可以在几乎任何平台上分发和运行它。
\switchcolumn[0]*
You now have all the basic details you need to build, run, and
distribute (very) basic Clojure programs. In later chapters, you'll
learn more details about what Leiningen is doing when you run the
preceding commands, gaining a complete understanding of Clojure's
relationship to the JVM and how you can run production code.
\switchcolumn
现在你已经掌握了构建、运行和分发（非常）基本的Clojure程序所需的基本细节。在后面的章节中，你将了解在运行前面的命令时Leiningen在做什么，从而完全理解Clojure与JVM的关系以及如何运行生产代码。
\switchcolumn[0]*
Before we move on to \href{javascript:void(0)}{Chapter 2} and discuss
the wonder and glory of Emacs, let's go over another important tool: the
REPL.
\switchcolumn
在我们继续讨论Emacs的奇迹和荣耀之前，让我们再介绍一个重要的工具：REPL。

\switchcolumn[0]*

\switchcolumn

\switchcolumn[0]*

\switchcolumn


\switchcolumn[0]*

\switchcolumn

\switchcolumn[0]*

\switchcolumn


\switchcolumn[0]*

\switchcolumn

\switchcolumn[0]*

\switchcolumn


\switchcolumn[0]*

\switchcolumn

\end{paracol}
