\columnratio{0.55}
\begin{paracol}{2}
 
\switchcolumn[0]*%%%%%%%
\section{Server-Side Rendering (SSR)}
\switchcolumn
\section{服务端渲染 (SSR)}
\switchcolumn[0]*%%%%%%%
\subsection{Overview}
\switchcolumn
\subsection{总览}
\switchcolumn[0]*%%%%%%%
\subsubsection{What is SSR?}
\switchcolumn
\subsubsection{什么是 SSR？}
\switchcolumn[0]*%%%%%%%
Vue.js is a framework for building client-side applications. By default,
Vue components produce and manipulate DOM in the browser as output.
However, it is also possible to render the same components into HTML
strings on the server, send them directly to the browser, and finally
"hydrate" the static markup into a fully interactive app on the client.
\switchcolumn
Vue.js 是一个用于构建客户端应用的框架。默认情况下，Vue
组件的职责是在浏览器中生成和操作 DOM。然而，Vue
也支持将组件在服务端直接渲染成 HTML
字符串，作为服务端响应返回给浏览器，最后在浏览器端将静态的
HTML``激活''(hydrate) 为能够交互的客户端应用。
\switchcolumn[0]*%%%%%%%
A server-rendered Vue.js app can also be considered "isomorphic" or
"universal", in the sense that the majority of your app's code runs on
both the server \textbf{and} the client.
\switchcolumn
一个由服务端渲染的 Vue.js 应用也可以被认为是``同构的''(Isomorphic)
或``通用的''(Universal)，因为应用的大部分代码同时运行在服务端\textbf{和}客户端。
\switchcolumn[0]*%%%%%%%
\subsubsection{Why SSR?}
\switchcolumn
\subsubsection{为什么要用 SSR？}
\switchcolumn[0]*%%%%%%%
Compared to a client-side Single-Page Application (SPA), the advantage
of SSR primarily lies in:
\switchcolumn
与客户端的单页应用 (SPA) 相比，SSR 的优势主要在于：
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  \textbf{Faster time-to-content}: this is more prominent on slow
  internet or slow devices. Server-rendered markup doesn't need to wait
  until all JavaScript has been downloaded and executed to be displayed,
  so your user will see a fully-rendered page sooner. In addition, data
  fetching is done on the server-side for the initial visit, which
  likely has a faster connection to your database than the client. This
  generally results in improved \href{https://web.dev/vitals/}{Core Web
  Vitals} metrics, better user experience, and can be critical for
  applications where time-to-content is directly associated with
  conversion rate.
\item
  \textbf{Unified mental model}: you get to use the same language and
  the same declarative, component-oriented mental model for developing
  your entire app, instead of jumping back and forth between a backend
  templating system and a frontend framework.
\item
  \textbf{Better SEO}: the search engine crawlers will directly see the
  fully rendered page.
\end{itemize}  
\switchcolumn
\begin{itemize}
\item
  \textbf{更快的首屏加载}：这一点在慢网速或者运行缓慢的设备上尤为重要。服务端渲染的
  HTML 无需等到所有的 JavaScript
  都下载并执行完成之后才显示，所以你的用户将会更快地看到完整渲染的页面。除此之外，数据获取过程在首次访问时在服务端完成，相比于从客户端获取，可能有更快的数据库连接。这通常可以带来更高的\href{https://web.dev/vitals/}{核心
  Web
  指标}评分、更好的用户体验，而对于那些``首屏加载速度与转化率直接相关''的应用来说，这点可能至关重要。
\item
  \textbf{统一的心智模型}：你可以使用相同的语言以及相同的声明式、面向组件的心智模型来开发整个应用，而不需要在后端模板系统和前端框架之间来回切换。
\item
  \textbf{更好的 SEO}：搜索引擎爬虫可以直接看到完全渲染的页面。
\end{itemize}  
  \switchcolumn[0]*%%%%%%%
  \begin{vueQuote}{TIP}
    As of now, Google and Bing can index synchronous JavaScript
    applications just fine. Synchronous being the key word there. If your
    app starts with a loading spinner, then fetches content via Ajax, the
    crawler will not wait for you to finish. This means if you have
    content fetched asynchronously on pages where SEO is important, SSR
    might be necessary.
  \end{vueQuote} 
  \switchcolumn
  \begin{vueQuote}{TIP}
    截至目前，Google 和 Bing 可以很好地对同步 JavaScript
    应用进行索引。这里的``同步''是关键词。如果你的应用以一个 loading
    动画开始，然后通过 Ajax
    获取内容，爬虫并不会等到内容加载完成再抓取。也就是说，如果 SEO
    对你的页面至关重要，而你的内容又是异步获取的，那么 SSR 可能是必需的。
  \end{vueQuote} 
  \switchcolumn[0]*%%%%%%%
  There are also some trade-offs to consider when using SSR:
  \switchcolumn
  使用 SSR 时还有一些权衡之处需要考量：
  \switchcolumn[0]*%%%%%%%
  \begin{itemize}
  \item
    Development constraints. Browser-specific code can only be used inside
    certain lifecycle hooks; some external libraries may need special
    treatment to be able to run in a server-rendered app.
  \item
    More involved build setup and deployment requirements. Unlike a fully
    static SPA that can be deployed on any static file server, a
    server-rendered app requires an environment where a Node.js server can
    run.
  \item
    More server-side load. Rendering a full app in Node.js is going to be
    more CPU-intensive than just serving static files, so if you expect
    high traffic, be prepared for corresponding server load and wisely
    employ caching strategies.
  \end{itemize}
  \switchcolumn
  \begin{itemize}
  \item
    开发中的限制。浏览器端特定的代码只能在某些生命周期钩子中使用；一些外部库可能需要特殊处理才能在服务端渲染的应用中运行。
  \item
    更多的与构建配置和部署相关的要求。服务端渲染的应用需要一个能让 Node.js
    服务器运行的环境，不像完全静态的 SPA
    那样可以部署在任意的静态文件服务器上。
  \item
    更高的服务端负载。在 Node.js
    中渲染一个完整的应用要比仅仅托管静态文件更加占用 CPU
    资源，因此如果你预期有高流量，请为相应的服务器负载做好准备，并采用合理的缓存策略。
\end{itemize}

\switchcolumn[0]*%%%%%%%
Before using SSR for your app, the first question you should ask is
whether you actually need it. It mostly depends on how important
time-to-content is for your app. For example, if you are building an
internal dashboard where an extra few hundred milliseconds on initial
load doesn't matter that much, SSR would be an overkill. However, in
cases where time-to-content is absolutely critical, SSR can help you
achieve the best possible initial load performance.
\switchcolumn
在为你的应用使用 SSR
之前，你首先应该问自己是否真的需要它。这主要取决于首屏加载速度对应用的重要程度。例如，如果你正在开发一个内部的管理面板，初始加载时的那额外几百毫秒对你来说并不重要，这种情况下使用
SSR 就没有太多必要了。然而，在内容展示速度极其重要的场景下，SSR
可以尽可能地帮你实现最优的初始加载性能。
\end{paracol}


\columnratio{0.55}
\begin{paracol}{2} 
\switchcolumn[0]*%%%%%%%
\subsubsection{SSR vs. SSG}
\switchcolumn
\subsubsection{SSR vs. SSG}
\switchcolumn[0]*%%%%%%%
\textbf{Static Site Generation (SSG)}, also referred to as
pre-rendering, is another popular technique for building fast websites.
If the data needed to server-render a page is the same for every user,
then instead of rendering the page every time a request comes in, we can
render it only once, ahead of time, during the build process.
Pre-rendered pages are generated and served as static HTML files.
\switchcolumn
\textbf{静态站点生成} (Static-Site Generation，缩写为
SSG)，也被称为预渲染，是另一种流行的构建快速网站的技术。如果用服务端渲染一个页面所需的数据对每个用户来说都是相同的，那么我们可以只渲染一次，提前在构建过程中完成，而不是每次请求进来都重新渲染页面。预渲染的页面生成后作为静态
HTML 文件被服务器托管。
\switchcolumn[0]*%%%%%%%
SSG retains the same performance characteristics of SSR apps: it
provides great time-to-content performance. At the same time, it is
cheaper and easier to deploy than SSR apps because the output is static
HTML and assets. The keyword here is \textbf{static}: SSG can only be
applied to pages consuming static data, i.e. data that is known at build
time and does not change between deploys. Every time the data changes, a
new deployment is needed.
\switchcolumn
SSG 保留了和 SSR
应用相同的性能表现：它带来了优秀的首屏加载性能。同时，它比 SSR
应用的花销更小，也更容易部署，因为它输出的是静态 HTML
和资源文件。这里的关键词是\textbf{静态}：SSG
仅可以用于消费静态数据的页面，即数据在构建期间就是已知的，并且在多次部署期间不会改变。每当数据变化时，都需要重新部署。
\switchcolumn[0]*%%%%%%%
If you're only investigating SSR to improve the SEO of a handful of
marketing pages (e.g. \texttt{/}, \texttt{/about}, \texttt{/contact},
etc.), then you probably want SSG instead of SSR. SSG is also great for
content-based websites such as documentation sites or blogs. In fact,
this website you are reading right now is statically generated using
\href{https://vitepress.dev/}{VitePress}, a Vue-powered static site
generator.
\switchcolumn
如果你调研 SSR 只是为了优化为数不多的营销页面的 SEO (例如
\texttt{/}、\texttt{/about} 和 \texttt{/contact} 等)，那么你可能需要 SSG
而不是 SSR。SSG
也非常适合构建基于内容的网站，比如文档站点或者博客。事实上，你现在正在阅读的这个网站就是使用
\href{https://vitepress.dev/}{VitePress} 静态生成的，它是一个由 Vue
驱动的静态站点生成器。
\switchcolumn[0]*%%%%%%%
\subsection{Basic Tutorial}
\switchcolumn
\subsection{基础教程}
\end{paracol}

 
\columnratio{0.55}
\begin{paracol}{2}
 
\switchcolumn[0]*%%%%%%%
\subsubsection{Rendering an App}
\switchcolumn
\subsubsection{渲染一个应用}
\switchcolumn[0]*%%%%%%%
Let's take a look at the most bare-bones example of Vue SSR in action.
\switchcolumn
让我们来看一个 Vue SSR 最基础的实战示例。
\switchcolumn[0]*%%%%%%%
\begin{enumerate}
\item
  Create a new directory and \texttt{cd} into it
\item
  Run \texttt{npm\ init\ -y}
\item
  Add \texttt{"type":\ "module"} in \texttt{package.json} so that
  Node.js runs in
  \href{https://nodejs.org/api/esm.html\#modules-ecmascript-modules}{ES
  modules mode}.
\item
  Run \texttt{npm\ install\ vue}
\item
  Create an \texttt{example.js} file:
\end{enumerate}
\switchcolumn
\begin{enumerate}
\item
  创建一个新的文件夹，\texttt{cd} 进入
\item
  执行 \texttt{npm\ init\ -y}
\item
  在 \texttt{package.json} 中添加 \texttt{"type":\ "module"} 使 Node.js
  以
  \href{https://nodejs.org/api/esm.html\#modules-ecmascript-modules}{ES
  modules mode} 运行
\item
  执行 \texttt{npm\ install\ vue}
\item
  创建一个 \texttt{example.js} 文件：
\end{enumerate}
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// 此文件运行在 Node.js 服务器上
import { createSSRApp } from 'vue'
// Vue 的服务端渲染 API 位于 `vue/server-renderer` 路径下
import { renderToString } from 'vue/server-renderer'
const app = createSSRApp({
  data: () => ({ count: 1 }),
  template: `<button @click="count++">{{ count }}</button>`
})
renderToString(app).then((html) => {
  console.log(html)
})
\end{codeJs}
\switchcolumn
\begin{codeJs}
// 此文件运行在 Node.js 服务器上
import { createSSRApp } from 'vue'
// Vue 的服务端渲染 API 位于 `vue/server-renderer` 路径下
import { renderToString } from 'vue/server-renderer'
const app = createSSRApp({
  data: () => ({ count: 1 }),
  template: `<button @click="count++">{{ count }}</button>`
})
renderToString(app).then((html) => {
  console.log(html)
})
\end{codeJs}
\switchcolumn[0]*%%%%%%%
Then run:
\begin{codeShell}
node example.js
\end{codeShell}  
\switchcolumn
接着运行：
\begin{codeShell}
node example.js
\end{codeShell}  
\switchcolumn[0]*%%%%%%%
It should print the following to the command line:
\switchcolumn
它应该会在命令行中打印出如下内容：
\switchcolumn[0]*%%%%%%%
\begin{verbatim}
<button>1</button>
\end{verbatim}
\switchcolumn
\begin{verbatim}
<button>1</button>
\end{verbatim}
\switchcolumn[0]*%%%%%%%
\href{https://vuejs.org/api/ssr.html\#rendertostring}{\texttt{renderToString()}}
takes a Vue app instance and returns a Promise that resolves to the
rendered HTML of the app. It is also possible to stream rendering using
the \href{https://nodejs.org/api/stream.html}{Node.js Stream API} or
\href{https://developer.mozilla.org/en-US/docs/Web/API/Streams_API}{Web
Streams API}. Check out the \href{https://vuejs.org/api/ssr.html}{SSR
API Reference} for full details.
\switchcolumn
\href{https://cn.vuejs.org/api/ssr.html\#rendertostring}{\texttt{renderToString()}}
接收一个 Vue 应用实例作为参数，返回一个 Promise，当 Promise resolve
时得到应用渲染的 HTML。当然你也可以使用
\href{https://nodejs.org/api/stream.html}{Node.js Stream API} 或者
\href{https://developer.mozilla.org/zh-CN/docs/Web/API/Streams_API}{Web
Streams API} 来执行流式渲染。查看
\href{https://cn.vuejs.org/api/ssr.html}{SSR API
参考}获取完整的相关细节。
\switchcolumn[0]*%%%%%%%
We can then move the Vue SSR code into a server request handler, which
wraps the application markup with the full page HTML. We will be using
\href{https://expressjs.com/}{\texttt{express}} for the next steps:
\switchcolumn
然后我们可以把 Vue SSR 的代码移动到一个服务器请求处理函数里，它将应用的
HTML 片段包装为完整的页面 HTML。接下来的几步我们将会使用
\href{https://expressjs.com/}{\texttt{express}}：
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  Run \texttt{npm\ install\ express}
\item
  Create the following \texttt{server.js} file:
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  执行 \texttt{npm\ install\ express}
\item
  创建下面的 \texttt{server.js} 文件：
\end{itemize}
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
import express from 'express'
import { createSSRApp } from 'vue'
import { renderToString } from 'vue/server-renderer'
const server = express()
server.get('/', (req, res) => {
  const app = createSSRApp({
    data: () => ({ count: 1 }),
    template: `<button @click="count++">{{ count }}</button>`
  })
  renderToString(app).then((html) => {
    res.send(`
    <!DOCTYPE html>
    <html>
      <head>
        <title>Vue SSR Example</title>
      </head>
      <body>
        <div id="app">${html}</div>
      </body>
    </html>
    `)
  })
})
server.listen(3000, () => {
  console.log('ready')
})
\end{codeJs}
\switchcolumn
\begin{codeJs}
import express from 'express'
import { createSSRApp } from 'vue'
import { renderToString } from 'vue/server-renderer'
const server = express()
server.get('/', (req, res) => {
  const app = createSSRApp({
    data: () => ({ count: 1 }),
    template: `<button @click="count++">{{ count }}</button>`
  })
  renderToString(app).then((html) => {
    res.send(`
    <!DOCTYPE html>
    <html>
      <head>
        <title>Vue SSR Example</title>
      </head>
      <body>
        <div id="app">${html}</div>
      </body>
    </html>
    `)
  })
})
server.listen(3000, () => {
  console.log('ready')
})
\end{codeJs}
\end{paracol}


\columnratio{0.55}
\begin{paracol}{2}
 
\switchcolumn[0]*%%%%%%%
Finally, run \texttt{node\ server.js} and visit
\texttt{http://localhost:3000}. You should see the page working with the
button.
\switchcolumn
最后，执行 \texttt{node\ server.js}，访问
\texttt{http://localhost:3000}。你应该可以看到页面中的按钮了。
\switchcolumn[0]*%%%%%%%
\href{https://stackblitz.com/fork/vue-ssr-example-basic?file=index.js}{Try
it on StackBlitz}
\switchcolumn
\href{https://stackblitz.com/fork/vue-ssr-example-basic?file=index.js}{在
StackBlitz 上试试}
\switchcolumn[0]*%%%%%%%
\subsubsection{Client Hydration}
\switchcolumn
\subsubsection{客户端激活}
\switchcolumn[0]*%%%%%%%
If you click the button, you'll notice the number doesn't change. The
HTML is completely static on the client since we are not loading Vue in
the browser.
\switchcolumn
如果你点击该按钮，你会发现数字并没有改变。这段 HTML
在客户端是完全静态的，因为我们没有在浏览器中加载 Vue。
\switchcolumn[0]*%%%%%%%
To make the client-side app interactive, Vue needs to perform the
\textbf{hydration} step. During hydration, it creates the same Vue
application that was run on the server, matches each component to the
DOM nodes it should control, and attaches DOM event listeners.
\switchcolumn
为了使客户端的应用可交互，Vue
需要执行一个\textbf{激活}步骤。在激活过程中，Vue
会创建一个与服务端完全相同的应用实例，然后将每个组件与它应该控制的 DOM
节点相匹配，并添加 DOM 事件监听器。
\switchcolumn[0]*%%%%%%%
To mount an app in hydration mode, we need to use
\href{https://vuejs.org/api/application.html\#createssrapp}{\texttt{createSSRApp()}}
instead of \texttt{createApp()}:
\switchcolumn
为了在激活模式下挂载应用，我们应该使用
\href{https://cn.vuejs.org/api/application.html\#createssrapp}{\texttt{createSSRApp()}}
而不是 \texttt{createApp()}：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// 该文件运行在浏览器中
import { createSSRApp } from 'vue'
const app = createSSRApp({
  // ...和服务端完全一致的应用实例
})
// 在客户端挂载一个 SSR 应用时会假定
// HTML 是预渲染的，然后执行激活过程，
// 而不是挂载新的 DOM 节点
app.mount('#app')
\end{codeJs}
\switchcolumn
\begin{codeJs}
// 该文件运行在浏览器中
import { createSSRApp } from 'vue'
const app = createSSRApp({
  // ...和服务端完全一致的应用实例
})
// 在客户端挂载一个 SSR 应用时会假定
// HTML 是预渲染的，然后执行激活过程，
// 而不是挂载新的 DOM 节点
app.mount('#app')
\end{codeJs}
\switchcolumn[0]*%%%%%%%
\subsubsection{Code Structure}
\switchcolumn
\subsubsection{代码结构}
\switchcolumn[0]*%%%%%%%
Notice how we need to reuse the same app implementation as on the
server. This is where we need to start thinking about code structure in
an SSR app - how do we share the same application code between the
server and the client?
\switchcolumn
想想我们该如何在客户端复用服务端的应用实现。这时我们就需要开始考虑 SSR
应用中的代码结构了------我们如何在服务器和客户端之间共享相同的应用代码呢？
\switchcolumn[0]*%%%%%%%
Here we will demonstrate the most bare-bones setup. First, let's split
the app creation logic into a dedicated file, \texttt{app.js}:
\switchcolumn
这里我们将演示最基础的设置。首先，让我们将应用的创建逻辑拆分到一个单独的文件
\texttt{app.js} 中：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// app.js (在服务器和客户端之间共享)
import { createSSRApp } from 'vue'
export function createApp() {
  return createSSRApp({
    data: () => ({ count: 1 }),
    template: `<button @click="count++">{{ count }}</button>`
  })
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
// app.js (在服务器和客户端之间共享)
import { createSSRApp } from 'vue'
export function createApp() {
  return createSSRApp({
    data: () => ({ count: 1 }),
    template: `<button @click="count++">{{ count }}</button>`
  })
}
\end{codeJs}
\switchcolumn[0]*%%%%%%%
This file and its dependencies are shared between the server and the
client - we call them \textbf{universal code}. There are a number of
things you need to pay attention to when writing universal code, as we
will
\href{https://vuejs.org/guide/scaling-up/ssr.html\#writing-ssr-friendly-code}{discuss
below}.
\switchcolumn
该文件及其依赖项在服务器和客户端之间共享------我们称它们为\textbf{通用代码}。编写通用代码时有一些注意事项，我们将\href{https://cn.vuejs.org/guide/scaling-up/ssr.html\#writing-ssr-friendly-code}{在下面讨论}。
\switchcolumn[0]*%%%%%%%
Our client entry imports the universal code, creates the app, and
performs the mount:
\switchcolumn
我们在客户端入口导入通用代码，创建应用并执行挂载：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// client.js
import { createApp } from './app.js'
createApp().mount('#app')
\end{codeJs}
\switchcolumn
\begin{codeJs}
// client.js
import { createApp } from './app.js'
createApp().mount('#app')
\end{codeJs}
\switchcolumn[0]*%%%%%%%
And the server uses the same app creation logic in the request handler:
\switchcolumn
服务器在请求处理函数中使用相同的应用创建逻辑：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// server.js (不相关的代码省略)
import { createApp } from './app.js'
server.get('/', (req, res) => {
  const app = createApp()
  renderToString(app).then(html => {
    // ...
  })
})
\end{codeJs}
\switchcolumn
\begin{codeJs}
// server.js (不相关的代码省略)
import { createApp } from './app.js'
server.get('/', (req, res) => {
  const app = createApp()
  renderToString(app).then(html => {
    // ...
  })
})
\end{codeJs}
\switchcolumn[0]*%%%%%%%
In addition, in order to load the client files in the browser, we also
need to:
\switchcolumn
此外，为了在浏览器中加载客户端文件，我们还需要：
\switchcolumn[0]*%%%%%%%
\begin{enumerate}
\item
  Serve client files by adding
  \texttt{server.use(express.static(\textquotesingle{}.\textquotesingle{}))}
  in \texttt{server.js}.
\item
  Load the client entry by adding
  \texttt{\textless{}script\ type="module"\ src="/client.js"\textgreater{}\textless{}/script\textgreater{}}
  to the HTML shell.
\item
  Support usage like
  \texttt{import\ *\ from\ \textquotesingle{}vue\textquotesingle{}} in
  the browser by adding an
  \href{https://github.com/WICG/import-maps}{Import Map} to the HTML
  shell.
\end{enumerate}
\switchcolumn
\begin{enumerate}
\item
  在 \texttt{server.js} 中添加
  \texttt{server.use(express.static(\textquotesingle{}.\textquotesingle{}))}
  来托管客户端文件。
\item
  将
  \texttt{\textless{}script\ type="module"\ src="/client.js"\textgreater{}\textless{}/script\textgreater{}}
  添加到 HTML 外壳以加载客户端入口文件。
\item
  通过在 HTML 外壳中添加
  \href{https://github.com/WICG/import-maps}{Import Map}
  以支持在浏览器中使用
  \texttt{import\ *\ from\ \textquotesingle{}vue\textquotesingle{}}。
\end{enumerate}
\switchcolumn[0]*%%%%%%%
\href{https://stackblitz.com/fork/vue-ssr-example?file=index.js}{Try the
completed example on StackBlitz}. The button is now interactive!
\switchcolumn
\href{https://stackblitz.com/fork/vue-ssr-example?file=index.js}{在
StackBlitz 上尝试完整的示例}。按钮现在可以交互了！
\switchcolumn[0]*%%%%%%%
\subsection{Higher Level Solutions}
\switchcolumn
\subsection{更通用的解决方案}
\switchcolumn[0]*%%%%%%%
Moving from the example to a production-ready SSR app involves a lot
more. We will need to:
\switchcolumn
从上面的例子到一个生产就绪的 SSR 应用还需要很多工作。我们将需要：
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  Support Vue SFCs and other build step requirements. In fact, we will
  need to coordinate two builds for the same app: one for the client,
  and one for the server.
\begin{vueQuote}{TIP}
  Vue components are compiled differently when used for SSR - templates
  are compiled into string concatenations instead of Virtual DOM render
  functions for more efficient rendering performance.
\end{vueQuote} 
\item
  In the server request handler, render the HTML with the correct
  client-side asset links and optimal resource hints. We may also need
  to switch between SSR and SSG mode, or even mix both in the same app.
\item
  Manage routing, data fetching, and state management stores in a
  universal manner.
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  支持 Vue SFC
  且满足其他构建步骤要求。事实上，我们需要为同一个应用执行两次构建过程：一次用于客户端，一次用于服务器。
\begin{vueQuote}{TIP}
  Vue 组件用在 SSR 时的编译产物不同------模板被编译为字符串拼接而不是
  render 函数，以此提高渲染性能。
\end{vueQuote} 
\item
  在服务器请求处理函数中，确保返回的 HTML
  包含正确的客户端资源链接和最优的资源加载提示 (如 prefetch 和
  preload)。我们可能还需要在 SSR 和 SSG
  模式之间切换，甚至在同一个应用中混合使用这两种模式。
\item
  以一种通用的方式管理路由、数据获取和状态存储。
\end{itemize}
\switchcolumn[0]*%%%%%%%
A complete implementation would be quite complex and depends on the
build toolchain you have chosen to work with. Therefore, we highly
recommend going with a higher-level, opinionated solution that abstracts
away the complexity for you. Below we will introduce a few recommended
SSR solutions in the Vue ecosystem.
\switchcolumn
完整的实现会非常复杂，并且取决于你选择使用的构建工具链。因此，我们强烈建议你使用一种更通用的、更集成化的解决方案，帮你抽象掉那些复杂的东西。下面推荐几个
Vue 生态中的 SSR 解决方案。
\switchcolumn[0]*%%%%%%%
\subsubsection{Nuxt}
\switchcolumn
\subsubsection{Nuxt}
\switchcolumn[0]*%%%%%%%
\href{https://nuxt.com/}{Nuxt} is a higher-level framework built on top
of the Vue ecosystem which provides a streamlined development experience
for writing universal Vue applications. Better yet, you can also use it
as a static site generator! We highly recommend giving it a try.
\switchcolumn
\href{https://nuxt.com/}{Nuxt} 是一个构建于 Vue
生态系统之上的全栈框架，它为编写 Vue SSR
应用提供了丝滑的开发体验。更棒的是，你还可以把它当作一个静态站点生成器来用！我们强烈建议你试一试。
\end{paracol}


\columnratio{0.55}
\begin{paracol}{2}
\switchcolumn[0]*%%%%%%%
\subsubsection{Quasar}
\switchcolumn
\subsubsection{Quasar} 
\switchcolumn[0]*%%%%%%%
\href{https://quasar.dev/}{Quasar} is a complete Vue-based solution that
allows you to target SPA, SSR, PWA, mobile app, desktop app, and browser
extension all using one codebase. It not only handles the build setup,
but also provides a full collection of Material Design compliant UI
components.
\switchcolumn
\href{https://quasar.dev/}{Quasar} 是一个基于 Vue
的完整解决方案，它可以让你用同一套代码库构建不同目标的应用，如
SPA、SSR、PWA、移动端应用、桌面端应用以及浏览器插件。除此之外，它还提供了一整套
Material Design 风格的组件库。
\switchcolumn[0]*%%%%%%%
\subsubsection{Vite SSR}
\switchcolumn
\subsubsection{Vite SSR}
\switchcolumn[0]*%%%%%%%
Vite provides built-in \href{https://vitejs.dev/guide/ssr.html}{support
for Vue server-side rendering}, but it is intentionally low-level. If
you wish to go directly with Vite, check out
\href{https://vite-plugin-ssr.com/}{vite-plugin-ssr}, a community plugin
that abstracts away many challenging details for you.
\switchcolumn
Vite 提供了内置的 \href{https://cn.vitejs.dev/guide/ssr.html}{Vue
服务端渲染支持}，但它在设计上是偏底层的。如果你想要直接使用
Vite，可以看看
\href{https://vite-plugin-ssr.com/}{vite-plugin-ssr}，一个帮你抽象掉许多复杂细节的社区插件。
\switchcolumn[0]*%%%%%%%
You can also find an example Vue + Vite SSR project using manual setup
\href{https://github.com/vitejs/vite-plugin-vue/tree/main/playground/ssr-vue}{here},
which can serve as a base to build upon. Note this is only recommended
if you are experienced with SSR / build tools and really want to have
complete control over the higher-level architecture.
\switchcolumn
你也可以在\href{https://github.com/vitejs/vite-plugin-vue/tree/main/playground/ssr-vue}{这里}查看一个使用手动配置的
Vue + Vite SSR
的示例项目，以它作为基础来构建。请注意，这种方式只有在你有丰富的 SSR
和构建工具经验，并希望对应用的架构做深入的定制时才推荐使用。
\switchcolumn[0]*%%%%%%%
\subsection{Writing SSR-friendly Code}
\switchcolumn
\subsection{书写 SSR 友好的代码}
\switchcolumn[0]*%%%%%%%
Regardless of your build setup or higher-level framework choice, there
are some principles that apply in all Vue SSR applications.
\switchcolumn
无论你的构建配置或顶层框架的选择如何，下面的原则在所有 Vue SSR
应用中都适用。
\switchcolumn[0]*%%%%%%%
\subsubsection{Reactivity on the Server}
\switchcolumn
\subsubsection{服务端的响应性}
\switchcolumn[0]*%%%%%%%
During SSR, each request URL maps to a desired state of our application.
There is no user interaction and no DOM updates, so reactivity is
unnecessary on the server. By default, reactivity is disabled during SSR
for better performance.
\switchcolumn
在 SSR 期间，每一个请求 URL
都会映射到我们应用中的一个期望状态。因为没有用户交互和 DOM
更新，所以响应性在服务端是不必要的。为了更好的性能，默认情况下响应性在
SSR 期间是禁用的。
\switchcolumn[0]*%%%%%%%
\subsubsection{Component Lifecycle Hooks}
\switchcolumn
\subsubsection{组件生命周期钩子}
\switchcolumn[0]*%%%%%%%
Since there are no dynamic updates, lifecycle hooks such as
\texttt{onMounted} or \texttt{onUpdated} will \textbf{NOT} be called
during SSR and will only be executed on the client.
\switchcolumn
因为没有任何动态更新，所以像 \texttt{onMounted} 或者 \texttt{onUpdated}
这样的生命周期钩子\textbf{不会}在 SSR 期间被调用，而只会在客户端运行。
\switchcolumn[0]*%%%%%%%
You should avoid code that produces side effects that need cleanup in
\texttt{setup()} or the root scope of
\texttt{\textless{}script\ setup\textgreater{}}. An example of such side
effects is setting up timers with \texttt{setInterval}. In client-side
only code we may setup a timer and then tear it down in
\texttt{onBeforeUnmount} or \texttt{onUnmounted}. However, because the
unmount hooks will never be called during SSR, the timers will stay
around forever. To avoid this, move your side-effect code into
\texttt{onMounted} instead.
\switchcolumn
你应该避免在 \texttt{setup()} 或者
\texttt{\textless{}script\ setup\textgreater{}}
的根作用域中使用会产生副作用且需要被清理的代码。这类副作用的常见例子是使用
\texttt{setInterval}
设置定时器。我们可能会在客户端特有的代码中设置定时器，然后在
\texttt{onBeforeUnmount} 或 \texttt{onUnmounted} 中清除。然而，由于
unmount 钩子不会在 SSR
期间被调用，所以定时器会永远存在。为了避免这种情况，请将含有副作用的代码放到
\texttt{onMounted} 中。
\switchcolumn[0]*%%%%%%%
\subsubsection{Access to Platform-Specific APIs}
\switchcolumn
\subsubsection{访问平台特有 API}
\switchcolumn[0]*%%%%%%%
Universal code cannot assume access to platform-specific APIs, so if
your code directly uses browser-only globals like \texttt{window} or
\texttt{document}, they will throw errors when executed in Node.js, and
vice-versa.
\switchcolumn
通用代码不能访问平台特有的
API，如果你的代码直接使用了浏览器特有的全局变量，比如 \texttt{window} 或
\texttt{document}，他们会在 Node.js 运行时报错，反过来也一样。
\switchcolumn[0]*%%%%%%%
For tasks that are shared between server and client but with different
platform APIs, it's recommended to wrap the platform-specific
implementations inside a universal API, or use libraries that do this
for you. For example, you can use
\href{https://github.com/node-fetch/node-fetch}{\texttt{node-fetch}} to
use the same fetch API on both server and client.
\switchcolumn
对于在服务器和客户端之间共享，但使用了不同的平台 API
的任务，建议将平台特定的实现封装在一个通用的 API
中，或者使用能为你做这件事的库。例如你可以使用
\href{https://github.com/node-fetch/node-fetch}{\texttt{node-fetch}}
在服务端和客户端使用相同的 fetch API。
\switchcolumn[0]*%%%%%%%
For browser-only APIs, the common approach is to lazily access them
inside client-only lifecycle hooks such as \texttt{onMounted}.
\switchcolumn
对于浏览器特有的
API，通常的方法是在仅客户端特有的生命周期钩子中惰性地访问它们，例如
\texttt{onMounted}。
\switchcolumn[0]*%%%%%%%
Note that if a third-party library is not written with universal usage
in mind, it could be tricky to integrate it into a server-rendered app.
You \emph{might} be able to get it working by mocking some of the
globals, but it would be hacky and may interfere with the environment
detection code of other libraries.
\switchcolumn
请注意，如果一个第三方库编写时没有考虑到通用性，那么要将它集成到一个 SSR
应用中可能会很棘手。你\emph{或许}可以通过模拟一些全局变量来让它工作，但这只是一种
hack 手段并且可能会影响到其他库的环境检测代码。
\switchcolumn[0]*%%%%%%%
\subsubsection{Cross-Request State Pollution}
\switchcolumn
\subsubsection{跨请求状态污染}
\switchcolumn[0]*%%%%%%%
In the State Management chapter, we introduced a
\href{https://vuejs.org/guide/scaling-up/state-management.html\#simple-state-management-with-reactivity-api}{simple
state management pattern using Reactivity APIs}. In an SSR context, this
pattern requires some additional adjustments.
\switchcolumn
在状态管理一章中，我们介绍了一种\href{https://cn.vuejs.org/guide/scaling-up/state-management.html\#simple-state-management-with-reactivity-api}{使用响应式
API 的简单状态管理模式}。而在 SSR 环境中，这种模式需要一些额外的调整。
\switchcolumn[0]*%%%%%%%
The pattern declares shared state in a JavaScript module's root scope.
This makes them \textbf{singletons} - i.e. there is only one instance of
the reactive object throughout the entire lifecycle of our application.
This works as expected in a pure client-side Vue application, since the
modules in our application are initialized fresh for each browser page
visit.
\switchcolumn
上述模式在一个 JavaScript
模块的根作用域中声明共享的状态。这是一种\textbf{单例模式}------即在应用的整个生命周期中只有一个响应式对象的实例。这在纯客户端的
Vue
应用中是可以的，因为对于浏览器的每一个页面访问，应用模块都会重新初始化。
\switchcolumn[0]*%%%%%%%
However, in an SSR context, the application modules are typically
initialized only once on the server, when the server boots up. The same
module instances will be reused across multiple server requests, and so
will our singleton state objects. If we mutate the shared singleton
state with data specific to one user, it can be accidentally leaked to a
request from another user. We call this \textbf{cross-request state
pollution.}
\switchcolumn
然而，在 SSR
环境下，应用模块通常只在服务器启动时初始化一次。同一个应用模块会在多个服务器请求之间被复用，而我们的单例状态对象也一样。如果我们用单个用户特定的数据对共享的单例状态进行修改，那么这个状态可能会意外地泄露给另一个用户的请求。我们把这种情况称为\textbf{跨请求状态污染}。
\switchcolumn[0]*%%%%%%%
We can technically re-initialize all the JavaScript modules on each
request, just like we do in browsers. However, initializing JavaScript
modules can be costly, so this would significantly affect server
performance.
\switchcolumn
从技术上讲，我们可以在每个请求上重新初始化所有 JavaScript
模块，就像我们在浏览器中所做的那样。但是，初始化 JavaScript
模块的成本可能很高，因此这会显著影响服务器性能。
\switchcolumn[0]*%%%%%%%
The recommended solution is to create a new instance of the entire
application - including the router and global stores - on each request.
Then, instead of directly importing it in our components, we provide the
shared state using
\href{https://vuejs.org/guide/components/provide-inject.html\#app-level-provide}{app-level
provide} and inject it in components that need it:
\switchcolumn
推荐的解决方案是在每个请求中为整个应用创建一个全新的实例，包括 router
和全局
store。然后，我们使用\href{https://cn.vuejs.org/guide/components/provide-inject.html\#app-level-provide}{应用层级的
provide
方法}来提供共享状态，并将其注入到需要它的组件中，而不是直接在组件中将其导入：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// app.js （在服务端和客户端间共享）
import { createSSRApp } from 'vue'
import { createStore } from './store.js'
// 每次请求时调用
export function createApp() {
  const app = createSSRApp(/* ... */)
  // 对每个请求都创建新的 store 实例
  const store = createStore(/* ... */)
  // 提供应用级别的 store
  app.provide('store', store)
  // 也为激活过程暴露出 store
  return { app, store }
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
// app.js （在服务端和客户端间共享）
import { createSSRApp } from 'vue'
import { createStore } from './store.js'
// 每次请求时调用
export function createApp() {
  const app = createSSRApp(/* ... */)
  // 对每个请求都创建新的 store 实例
  const store = createStore(/* ... */)
  // 提供应用级别的 store
  app.provide('store', store)
  // 也为激活过程暴露出 store
  return { app, store }
}
\end{codeJs}
\switchcolumn[0]*%%%%%%%
State Management libraries like Pinia are designed with this in mind.
Consult \href{https://pinia.vuejs.org/ssr/}{Pinia's SSR guide} for more
details.
\switchcolumn
像 Pinia 这样的状态管理库在设计时就考虑到了这一点。请参考
\href{https://pinia.vuejs.org/zh/ssr/}{Pinia 的 SSR
指南}以了解更多细节。
\end{paracol}


\columnratio{0.55}
\begin{paracol}{2} 
 
\switchcolumn[0]*%%%%%%%
\subsubsection{Hydration Mismatch}
\switchcolumn
\subsubsection{激活不匹配}
\switchcolumn[0]*%%%%%%%
If the DOM structure of the pre-rendered HTML does not match the
expected output of the client-side app, there will be a hydration
mismatch error. Hydration mismatch is most commonly introduced by the
following causes:
\switchcolumn
如果预渲染的 HTML 的 DOM
结构不符合客户端应用的期望，就会出现激活不匹配。最常见的激活不匹配是以下几种原因导致的：
\end{paracol}





\begin{enumerate}
\columnratio{0.55}
\begin{paracol}{2} 
\switchcolumn[0]*%%%%%%%
\item
  The template contains invalid HTML nesting structure, and the rendered
  HTML got "corrected" by the browser's native HTML parsing behavior.
  For example, a common gotcha is that
  \href{https://stackoverflow.com/questions/8397852/why-cant-the-p-tag-contain-a-div-tag-inside-it}{\texttt{cannot\ be\ placed\ inside}}:
\begin{codeHtml}
<p><div>hi</div></p>
\end{codeHtml}
If we produce this in our server-rendered HTML, the browser will
terminate the first \texttt{\textless{}p\textgreater{}} when
\texttt{\textless{}div\textgreater{}} is encountered and parse it into
the following DOM structure:
\begin{codeHtml}
    <p></p>
    <div>hi</div>
    <p></p>
    \end{codeHtml}
\switchcolumn
\item
  组件模板中存在不符合规范的 HTML 结构，渲染后的 HTML 被浏览器原生的
  HTML 解析行为纠正导致不匹配。举例来说，一个常见的错误是
  \href{https://stackoverflow.com/questions/8397852/why-cant-the-p-tag-contain-a-div-tag-inside-it}{\texttt{不能被放在}
  中}：
\begin{codeHtml}
<p><div>hi</div></p>
\end{codeHtml}
如果我们在服务器渲染的 HTML 中出现这样的代码，当遇到
\texttt{\textless{}div\textgreater{}} 时，浏览器会结束第一个
\texttt{\textless{}p\textgreater{}}，并解析为以下 DOM 结构：
\begin{codeHtml}
<p></p>
<div>hi</div>
<p></p>
\end{codeHtml}


\switchcolumn[0]*%%%%%%%
\item
  The data used during render contains randomly generated values. Since
  the same application will run twice - once on the server, and once on
  the client - the random values are not guaranteed to be the same
  between the two runs. There are two ways to avoid random-value-induced
mismatches:
\begin{enumerate}
\item
    Use \texttt{v-if} + \texttt{onMounted} to render the part that
    depends on random values only on the client. Your framework may also
    have built-in features to make this easier, for example the
    \texttt{\textless{}ClientOnly\textgreater{}} component in VitePress.
\item
    Use a random number generator library that supports generating with
    seeds, and guarantee the server run and the client run are using the
    same seed (e.g. by including the seed in serialized state and
    retrieving it on the client).
\end{enumerate}
\switchcolumn
\item
渲染所用的数据中包含随机生成的值。由于同一个应用会在服务端和客户端执行两次，每次执行生成的随机数都不能保证相同。避免随机数不匹配有两种选择：
\begin{enumerate}
\item
    利用 \texttt{v-if} + \texttt{onMounted}
    让需要用到随机数的模板只在客户端渲染。你所用的上层框架可能也会提供简化这个用例的内置
    API，比如 VitePress 的 \texttt{\textless{}ClientOnly\textgreater{}}
    组件。
\item
    使用一个能够接受随机种子的随机数生成库，并确保服务端和客户端使用同样的随机数种子
    (比如把种子包含在序列化的状态中，然后在客户端取回)。
\end{enumerate}
\switchcolumn[0]*%%%%%%%
\item
  The server and the client are in different time zones. Sometimes, we
  may want to convert a timestamp into the user's local time. However,
  the timezone during the server run and the timezone during the client
  run are not always the same, and we may not reliably know the user's
  timezone during the server run. In such cases, the local time
  conversion should also be performed as a client-only operation.
\switchcolumn
\item
  服务端和客户端的时区不一致。有时候我们可能会想要把一个时间转换为用户的当地时间，但在服务端的时区跟用户的时区可能并不一致，我们也并不能可靠的在服务端预先知道用户的时区。这种情况下，当地时间的转换也应该作为纯客户端逻辑去执行。

\end{paracol}
\end{enumerate}

\columnratio{0.55}
\begin{paracol}{2} 
   
\switchcolumn[0]*%%%%%%%
When Vue encounters a hydration mismatch, it will attempt to
automatically recover and adjust the pre-rendered DOM to match the
client-side state. This will lead to some rendering performance loss due
to incorrect nodes being discarded and new nodes being mounted, but in
most cases, the app should continue to work as expected. That said, it
is still best to eliminate hydration mismatches during development.
\switchcolumn
当 Vue 遇到激活不匹配时，它将尝试自动恢复并调整预渲染的 DOM
以匹配客户端的状态。这将导致一些渲染性能的损失，因为需要丢弃不匹配的节点并渲染新的节点，但大多数情况下，应用应该会如预期一样继续工作。尽管如此，最好还是在开发过程中发现并避免激活不匹配。
\switchcolumn[0]*%%%%%%%
\subsubsection{Custom Directives}
\switchcolumn
\subsubsection{自定义指令}
\switchcolumn[0]*%%%%%%%
Since most custom directives involve direct DOM manipulation, they are
ignored during SSR. However, if you want to specify how a custom
directive should be rendered (i.e. what attributes it should add to the
rendered element), you can use the \texttt{getSSRProps} directive hook:
\switchcolumn
因为大多数的自定义指令都包含了对 DOM 的直接操作，所以它们会在 SSR
时被忽略。但如果你想要自己控制一个自定义指令在 SSR 时应该如何被渲染
(即应该在渲染的元素上添加哪些 attribute)，你可以使用
\texttt{getSSRProps} 指令钩子：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
const myDirective = {
  mounted(el, binding) {
    // 客户端实现：
    // 直接更新 DOM
    el.id = binding.value
  },
  getSSRProps(binding) {
    // 服务端实现：
    // 返回需要渲染的 prop
    // getSSRProps 只接收一个 binding 参数
    return {
      id: binding.value
    }
  }
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
const myDirective = {
  mounted(el, binding) {
    // 客户端实现：
    // 直接更新 DOM
    el.id = binding.value
  },
  getSSRProps(binding) {
    // 服务端实现：
    // 返回需要渲染的 prop
    // getSSRProps 只接收一个 binding 参数
    return {
      id: binding.value
    }
  }
}
\end{codeJs}
\end{paracol}



\columnratio{0.55}
\begin{paracol}{2} 
  
\switchcolumn[0]*%%%%%%%
\subsubsection{Teleports}
\switchcolumn
\subsubsection{Teleports}
\switchcolumn[0]*%%%%%%%
Teleports require special handling during SSR. If the rendered app
contains Teleports, the teleported content will not be part of the
rendered string. An easier solution is to conditionally render the
Teleport on mount.
\switchcolumn
在 SSR 的过程中 Teleport 需要特殊处理。如果渲染的应用包含
Teleport，那么其传送的内容将不会包含在主应用渲染出的字符串中。在大多数情况下，更推荐的方案是在客户端挂载时条件式地渲染
Teleport。
\switchcolumn[0]*%%%%%%%
If you do need to hydrate teleported content, they are exposed under the
\texttt{teleports} property of the ssr context object:
\switchcolumn
如果你需要激活 Teleport 内容，它们会暴露在服务端渲染上下文对象的
\texttt{teleports} 属性下：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
const ctx = {}
const html = await renderToString(app, ctx)
console.log(ctx.teleports) // { '#teleported': 'teleported content' }
\end{codeJs}
\switchcolumn
\begin{codeJs}
const ctx = {}
const html = await renderToString(app, ctx)
console.log(ctx.teleports) // { '#teleported': 'teleported content' }
\end{codeJs}
\switchcolumn[0]*%%%%%%%
You need to inject the teleport markup into the correct location in your
final page HTML similar to how you need to inject the main app markup.
\switchcolumn
跟主应用的 HTML 一样，你需要自己将 Teleport 对应的 HTML
嵌入到最终页面上的正确位置处。
\switchcolumn[0]*%%%%%%%
\begin{vueQuote}{TIP}
Avoid targeting \texttt{body} when using Teleports and SSR together -
usually, \texttt{\textless{}body\textgreater{}} will contain other
server-rendered content which makes it impossible for Teleports to
determine the correct starting location for hydration.
\end{vueQuote} 
\switchcolumn
\begin{vueQuote}{TIP}
请避免在 SSR 的同时把 Teleport 的目标设为 \texttt{body}------通常
\texttt{\textless{}body\textgreater{}}
会包含其他服务端渲染出来的内容，这会使得 Teleport
无法确定激活的正确起始位置。
\end{vueQuote} 
\switchcolumn[0]*%%%%%%%
Instead, prefer a dedicated container, e.g.
\texttt{\textless{}div\ id="teleported"\textgreater{}\textless{}/div\textgreater{}}
which contains only teleported content.
\switchcolumn
推荐用一个独立的只包含 teleport 的内容的容器，例如
\texttt{\textless{}div\ id="teleported"\textgreater{}\textless{}/div\textgreater{}}。
\end{paracol}

