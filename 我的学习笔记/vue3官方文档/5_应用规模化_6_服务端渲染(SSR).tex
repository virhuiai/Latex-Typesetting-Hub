\columnratio{0.55}
\begin{paracol}{2}
 
\switchcolumn[0]*%%%%%%%
\section{Server-Side Rendering (SSR)}
\switchcolumn
\section{服务端渲染 (SSR)}
\switchcolumn[0]*%%%%%%%
\subsection{Overview}
\switchcolumn
\subsection{总览}
\switchcolumn[0]*%%%%%%%
\subsubsection{What is SSR?}
\switchcolumn
\subsubsection{什么是 SSR？}
\switchcolumn[0]*%%%%%%%
Vue.js is a framework for building client-side applications. By default,
Vue components produce and manipulate DOM in the browser as output.
However, it is also possible to render the same components into HTML
strings on the server, send them directly to the browser, and finally
"hydrate" the static markup into a fully interactive app on the client.
\switchcolumn
Vue.js 是一个用于构建客户端应用的框架。默认情况下，Vue
组件的职责是在浏览器中生成和操作 DOM。然而，Vue
也支持将组件在服务端直接渲染成 HTML
字符串，作为服务端响应返回给浏览器，最后在浏览器端将静态的
HTML``激活''(hydrate) 为能够交互的客户端应用。
\switchcolumn[0]*%%%%%%%
A server-rendered Vue.js app can also be considered "isomorphic" or
"universal", in the sense that the majority of your app's code runs on
both the server \textbf{and} the client.
\switchcolumn
一个由服务端渲染的 Vue.js 应用也可以被认为是``同构的''(Isomorphic)
或``通用的''(Universal)，因为应用的大部分代码同时运行在服务端\textbf{和}客户端。
\switchcolumn[0]*%%%%%%%
\subsubsection{Why SSR?}
\switchcolumn
\subsubsection{为什么要用 SSR？}
\switchcolumn[0]*%%%%%%%
Compared to a client-side Single-Page Application (SPA), the advantage
of SSR primarily lies in:
\switchcolumn
与客户端的单页应用 (SPA) 相比，SSR 的优势主要在于：
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  \textbf{Faster time-to-content}: this is more prominent on slow
  internet or slow devices. Server-rendered markup doesn't need to wait
  until all JavaScript has been downloaded and executed to be displayed,
  so your user will see a fully-rendered page sooner. In addition, data
  fetching is done on the server-side for the initial visit, which
  likely has a faster connection to your database than the client. This
  generally results in improved \href{https://web.dev/vitals/}{Core Web
  Vitals} metrics, better user experience, and can be critical for
  applications where time-to-content is directly associated with
  conversion rate.
\item
  \textbf{Unified mental model}: you get to use the same language and
  the same declarative, component-oriented mental model for developing
  your entire app, instead of jumping back and forth between a backend
  templating system and a frontend framework.
\item
  \textbf{Better SEO}: the search engine crawlers will directly see the
  fully rendered page.
\end{itemize}  
\switchcolumn
\begin{itemize}
\item
  \textbf{更快的首屏加载}：这一点在慢网速或者运行缓慢的设备上尤为重要。服务端渲染的
  HTML 无需等到所有的 JavaScript
  都下载并执行完成之后才显示，所以你的用户将会更快地看到完整渲染的页面。除此之外，数据获取过程在首次访问时在服务端完成，相比于从客户端获取，可能有更快的数据库连接。这通常可以带来更高的\href{https://web.dev/vitals/}{核心
  Web
  指标}评分、更好的用户体验，而对于那些``首屏加载速度与转化率直接相关''的应用来说，这点可能至关重要。
\item
  \textbf{统一的心智模型}：你可以使用相同的语言以及相同的声明式、面向组件的心智模型来开发整个应用，而不需要在后端模板系统和前端框架之间来回切换。
\item
  \textbf{更好的 SEO}：搜索引擎爬虫可以直接看到完全渲染的页面。
\end{itemize}  
  \switchcolumn[0]*%%%%%%%
  \begin{vueQuote}{TIP}
    As of now, Google and Bing can index synchronous JavaScript
    applications just fine. Synchronous being the key word there. If your
    app starts with a loading spinner, then fetches content via Ajax, the
    crawler will not wait for you to finish. This means if you have
    content fetched asynchronously on pages where SEO is important, SSR
    might be necessary.
  \end{vueQuote} 
  \switchcolumn
  \begin{vueQuote}{TIP}
    截至目前，Google 和 Bing 可以很好地对同步 JavaScript
    应用进行索引。这里的``同步''是关键词。如果你的应用以一个 loading
    动画开始，然后通过 Ajax
    获取内容，爬虫并不会等到内容加载完成再抓取。也就是说，如果 SEO
    对你的页面至关重要，而你的内容又是异步获取的，那么 SSR 可能是必需的。
  \end{vueQuote} 
  \switchcolumn[0]*%%%%%%%
  There are also some trade-offs to consider when using SSR:
  \switchcolumn
  使用 SSR 时还有一些权衡之处需要考量：
  \switchcolumn[0]*%%%%%%%
  \begin{itemize}
  \item
    Development constraints. Browser-specific code can only be used inside
    certain lifecycle hooks; some external libraries may need special
    treatment to be able to run in a server-rendered app.
  \item
    More involved build setup and deployment requirements. Unlike a fully
    static SPA that can be deployed on any static file server, a
    server-rendered app requires an environment where a Node.js server can
    run.
  \item
    More server-side load. Rendering a full app in Node.js is going to be
    more CPU-intensive than just serving static files, so if you expect
    high traffic, be prepared for corresponding server load and wisely
    employ caching strategies.
  \end{itemize}
  \switchcolumn
  \begin{itemize}
  \item
    开发中的限制。浏览器端特定的代码只能在某些生命周期钩子中使用；一些外部库可能需要特殊处理才能在服务端渲染的应用中运行。
  \item
    更多的与构建配置和部署相关的要求。服务端渲染的应用需要一个能让 Node.js
    服务器运行的环境，不像完全静态的 SPA
    那样可以部署在任意的静态文件服务器上。
  \item
    更高的服务端负载。在 Node.js
    中渲染一个完整的应用要比仅仅托管静态文件更加占用 CPU
    资源，因此如果你预期有高流量，请为相应的服务器负载做好准备，并采用合理的缓存策略。
\end{itemize}

\switchcolumn[0]*%%%%%%%
Before using SSR for your app, the first question you should ask is
whether you actually need it. It mostly depends on how important
time-to-content is for your app. For example, if you are building an
internal dashboard where an extra few hundred milliseconds on initial
load doesn't matter that much, SSR would be an overkill. However, in
cases where time-to-content is absolutely critical, SSR can help you
achieve the best possible initial load performance.
\switchcolumn
在为你的应用使用 SSR
之前，你首先应该问自己是否真的需要它。这主要取决于首屏加载速度对应用的重要程度。例如，如果你正在开发一个内部的管理面板，初始加载时的那额外几百毫秒对你来说并不重要，这种情况下使用
SSR 就没有太多必要了。然而，在内容展示速度极其重要的场景下，SSR
可以尽可能地帮你实现最优的初始加载性能。
\end{paracol}


\columnratio{0.55}
\begin{paracol}{2} 
\switchcolumn[0]*%%%%%%%
\subsubsection{SSR vs. SSG}
\switchcolumn
\subsubsection{SSR vs. SSG}
\switchcolumn[0]*%%%%%%%
\textbf{Static Site Generation (SSG)}, also referred to as
pre-rendering, is another popular technique for building fast websites.
If the data needed to server-render a page is the same for every user,
then instead of rendering the page every time a request comes in, we can
render it only once, ahead of time, during the build process.
Pre-rendered pages are generated and served as static HTML files.
\switchcolumn
\textbf{静态站点生成} (Static-Site Generation，缩写为
SSG)，也被称为预渲染，是另一种流行的构建快速网站的技术。如果用服务端渲染一个页面所需的数据对每个用户来说都是相同的，那么我们可以只渲染一次，提前在构建过程中完成，而不是每次请求进来都重新渲染页面。预渲染的页面生成后作为静态
HTML 文件被服务器托管。
\switchcolumn[0]*%%%%%%%
SSG retains the same performance characteristics of SSR apps: it
provides great time-to-content performance. At the same time, it is
cheaper and easier to deploy than SSR apps because the output is static
HTML and assets. The keyword here is \textbf{static}: SSG can only be
applied to pages consuming static data, i.e. data that is known at build
time and does not change between deploys. Every time the data changes, a
new deployment is needed.
\switchcolumn
SSG 保留了和 SSR
应用相同的性能表现：它带来了优秀的首屏加载性能。同时，它比 SSR
应用的花销更小，也更容易部署，因为它输出的是静态 HTML
和资源文件。这里的关键词是\textbf{静态}：SSG
仅可以用于消费静态数据的页面，即数据在构建期间就是已知的，并且在多次部署期间不会改变。每当数据变化时，都需要重新部署。
\switchcolumn[0]*%%%%%%%
If you're only investigating SSR to improve the SEO of a handful of
marketing pages (e.g. \texttt{/}, \texttt{/about}, \texttt{/contact},
etc.), then you probably want SSG instead of SSR. SSG is also great for
content-based websites such as documentation sites or blogs. In fact,
this website you are reading right now is statically generated using
\href{https://vitepress.dev/}{VitePress}, a Vue-powered static site
generator.
\switchcolumn
如果你调研 SSR 只是为了优化为数不多的营销页面的 SEO (例如
\texttt{/}、\texttt{/about} 和 \texttt{/contact} 等)，那么你可能需要 SSG
而不是 SSR。SSG
也非常适合构建基于内容的网站，比如文档站点或者博客。事实上，你现在正在阅读的这个网站就是使用
\href{https://vitepress.dev/}{VitePress} 静态生成的，它是一个由 Vue
驱动的静态站点生成器。
\switchcolumn[0]*%%%%%%%
\subsection{Basic Tutorial}
\switchcolumn
\subsection{基础教程}
\end{paracol}


\columnratio{0.55}
\begin{paracol}{2}
 
\switchcolumn[0]*%%%%%%%
\subsubsection{Rendering an App}
\switchcolumn
\subsubsection{渲染一个应用}
\switchcolumn[0]*%%%%%%%
Let's take a look at the most bare-bones example of Vue SSR in action.
\switchcolumn
让我们来看一个 Vue SSR 最基础的实战示例。
\switchcolumn[0]*%%%%%%%
\begin{enumerate}
\item
  Create a new directory and \texttt{cd} into it
\item
  Run \texttt{npm\ init\ -y}
\item
  Add \texttt{"type":\ "module"} in \texttt{package.json} so that
  Node.js runs in
  \href{https://nodejs.org/api/esm.html\#modules-ecmascript-modules}{ES
  modules mode}.
\item
  Run \texttt{npm\ install\ vue}
\item
  Create an \texttt{example.js} file:
\end{enumerate}
\switchcolumn
\begin{enumerate}
\item
  创建一个新的文件夹，\texttt{cd} 进入
\item
  执行 \texttt{npm\ init\ -y}
\item
  在 \texttt{package.json} 中添加 \texttt{"type":\ "module"} 使 Node.js
  以
  \href{https://nodejs.org/api/esm.html\#modules-ecmascript-modules}{ES
  modules mode} 运行
\item
  执行 \texttt{npm\ install\ vue}
\item
  创建一个 \texttt{example.js} 文件：
\end{enumerate}
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// 此文件运行在 Node.js 服务器上
import { createSSRApp } from 'vue'
// Vue 的服务端渲染 API 位于 `vue/server-renderer` 路径下
import { renderToString } from 'vue/server-renderer'
const app = createSSRApp({
  data: () => ({ count: 1 }),
  template: `<button @click="count++">{{ count }}</button>`
})
renderToString(app).then((html) => {
  console.log(html)
})
\end{codeJs}
\switchcolumn
\begin{codeJs}
// 此文件运行在 Node.js 服务器上
import { createSSRApp } from 'vue'
// Vue 的服务端渲染 API 位于 `vue/server-renderer` 路径下
import { renderToString } from 'vue/server-renderer'
const app = createSSRApp({
  data: () => ({ count: 1 }),
  template: `<button @click="count++">{{ count }}</button>`
})
renderToString(app).then((html) => {
  console.log(html)
})
\end{codeJs}
\switchcolumn[0]*%%%%%%%
Then run:
\begin{codeShell}
node example.js
\end{codeShell}  
\switchcolumn
接着运行：
\begin{codeShell}
node example.js
\end{codeShell}  
\switchcolumn[0]*%%%%%%%
It should print the following to the command line:
\switchcolumn
它应该会在命令行中打印出如下内容：
\switchcolumn[0]*%%%%%%%
\begin{verbatim}
<button>1</button>
\end{verbatim}
\switchcolumn
\begin{verbatim}
<button>1</button>
\end{verbatim}
\switchcolumn[0]*%%%%%%%
\href{https://vuejs.org/api/ssr.html\#rendertostring}{\texttt{renderToString()}}
takes a Vue app instance and returns a Promise that resolves to the
rendered HTML of the app. It is also possible to stream rendering using
the \href{https://nodejs.org/api/stream.html}{Node.js Stream API} or
\href{https://developer.mozilla.org/en-US/docs/Web/API/Streams_API}{Web
Streams API}. Check out the \href{https://vuejs.org/api/ssr.html}{SSR
API Reference} for full details.
\switchcolumn
\href{https://cn.vuejs.org/api/ssr.html\#rendertostring}{\texttt{renderToString()}}
接收一个 Vue 应用实例作为参数，返回一个 Promise，当 Promise resolve
时得到应用渲染的 HTML。当然你也可以使用
\href{https://nodejs.org/api/stream.html}{Node.js Stream API} 或者
\href{https://developer.mozilla.org/zh-CN/docs/Web/API/Streams_API}{Web
Streams API} 来执行流式渲染。查看
\href{https://cn.vuejs.org/api/ssr.html}{SSR API
参考}获取完整的相关细节。
\switchcolumn[0]*%%%%%%%
We can then move the Vue SSR code into a server request handler, which
wraps the application markup with the full page HTML. We will be using
\href{https://expressjs.com/}{\texttt{express}} for the next steps:
\switchcolumn
然后我们可以把 Vue SSR 的代码移动到一个服务器请求处理函数里，它将应用的
HTML 片段包装为完整的页面 HTML。接下来的几步我们将会使用
\href{https://expressjs.com/}{\texttt{express}}：
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  Run \texttt{npm\ install\ express}
\item
  Create the following \texttt{server.js} file:
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  执行 \texttt{npm\ install\ express}
\item
  创建下面的 \texttt{server.js} 文件：
\end{itemize}
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
import express from 'express'
import { createSSRApp } from 'vue'
import { renderToString } from 'vue/server-renderer'
const server = express()
server.get('/', (req, res) => {
  const app = createSSRApp({
    data: () => ({ count: 1 }),
    template: `<button @click="count++">{{ count }}</button>`
  })
  renderToString(app).then((html) => {
    res.send(`
    <!DOCTYPE html>
    <html>
      <head>
        <title>Vue SSR Example</title>
      </head>
      <body>
        <div id="app">${html}</div>
      </body>
    </html>
    `)
  })
})
server.listen(3000, () => {
  console.log('ready')
})
\end{codeJs}
\switchcolumn
\begin{codeJs}
import express from 'express'
import { createSSRApp } from 'vue'
import { renderToString } from 'vue/server-renderer'
const server = express()
server.get('/', (req, res) => {
  const app = createSSRApp({
    data: () => ({ count: 1 }),
    template: `<button @click="count++">{{ count }}</button>`
  })
  renderToString(app).then((html) => {
    res.send(`
    <!DOCTYPE html>
    <html>
      <head>
        <title>Vue SSR Example</title>
      </head>
      <body>
        <div id="app">${html}</div>
      </body>
    </html>
    `)
  })
})
server.listen(3000, () => {
  console.log('ready')
})
\end{codeJs}
\end{paracol}


\columnratio{0.55}
\begin{paracol}{2}

\end{paracol}


\columnratio{0.55}
\begin{paracol}{2}

\end{paracol}
