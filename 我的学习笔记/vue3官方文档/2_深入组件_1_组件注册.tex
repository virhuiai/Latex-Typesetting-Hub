\columnratio{0.55}
\begin{paracol}{2}

\switchcolumn[0]*%%%%%%%
\section{Component Registration}
\switchcolumn
\section{组件注册}
\switchcolumn[0]*%%%%%%%
\begin{quote}
This page assumes you've already read the
\href{https://vuejs.org/guide/essentials/component-basics.html}{Components
Basics}. Read that first if you are new to components.
\end{quote}
\switchcolumn
\begin{quote}
此章节假设你已经看过了\href{https://cn.vuejs.org/guide/essentials/component-basics.html}{组件基础}。若你还不了解组件是什么，请先阅读该章节。
\end{quote}
\switchcolumn[0]*%%%%%%%
A Vue component needs to be "registered" so that Vue knows where to
locate its implementation when it is encountered in a template. There
are two ways to register components: global and local.
\switchcolumn
一个 Vue 组件在使用前需要先被``注册''，这样 Vue
才能在渲染模板时找到其对应的实现。组件注册有两种方式：全局注册和局部注册。
\switchcolumn[0]*%%%%%%%
\subsection{Global Registration}
\switchcolumn
\subsection{全局注册}
\switchcolumn[0]*%%%%%%%
We can make components available globally in the current
\href{https://vuejs.org/guide/essentials/application.html}{Vue
application} using the \texttt{.component()} method:
\switchcolumn
我们可以使用
\href{https://cn.vuejs.org/guide/essentials/application.html}{Vue
应用实例}的 \texttt{.component()} 方法，让组件在当前 Vue
应用中全局可用。


\switchcolumn[0]*%%%%%%%
\begin{codeJs}
import { createApp } from 'vue'
//
const app = createApp({})
//
app.component(
  // 注册的名字
  'MyComponent',
  // 组件的实现
  {
    /* ... */
  }
)
\end{codeJs}
\switchcolumn
\begin{codeJs}
import { createApp } from 'vue'
//
const app = createApp({})
//
app.component(
  // 注册的名字
  'MyComponent',
  // 组件的实现
  {
    /* ... */
  }
)
\end{codeJs}
\switchcolumn[0]*%%%%%%%
If using SFCs, you will be registering the imported \texttt{.vue} files:
\switchcolumn
如果使用单文件组件，你可以注册被导入的 \texttt{.vue} 文件：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
import MyComponent from './App.vue'
app.component('MyComponent', MyComponent)
\end{codeJs}
\switchcolumn
\begin{codeJs}
import MyComponent from './App.vue'
app.component('MyComponent', MyComponent)
\end{codeJs}


\switchcolumn[0]*%%%%%%%
The \texttt{.component()} method can be chained:
\switchcolumn
\texttt{.component()} 方法可以被链式调用：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
app
  .component('ComponentA', ComponentA)
  .component('ComponentB', ComponentB)
  .component('ComponentC', ComponentC)
\end{codeJs}
\switchcolumn
\begin{codeJs}
app
  .component('ComponentA', ComponentA)
  .component('ComponentB', ComponentB)
  .component('ComponentC', ComponentC)
\end{codeJs}
\switchcolumn[0]*%%%%%%%
Globally registered components can be used in the template of any
component within this application:
\switchcolumn
全局注册的组件可以在此应用的任意组件的模板中使用：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<!-- 这在当前应用的任意组件中都可用 -->
<ComponentA/>
<ComponentB/>
<ComponentC/>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<!-- 这在当前应用的任意组件中都可用 -->
<ComponentA/>
<ComponentB/>
<ComponentC/>
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
This even applies to all subcomponents, meaning all three of these
components will also be available \emph{inside each other}.
\switchcolumn
所有的子组件也可以使用全局注册的组件，这意味着这三个组件也都可以在\emph{彼此内部}使用。
\end{paracol}

\columnratio{0.55}
\begin{paracol}{2}

\switchcolumn[0]*%%%%%%%
\subsection{Local Registration}
\switchcolumn
\subsection{局部注册}
\switchcolumn[0]*%%%%%%%
While convenient, global registration has a few drawbacks:
\switchcolumn
全局注册虽然很方便，但有以下几个问题：
\switchcolumn[0]*%%%%%%%
\begin{enumerate}
\item
    Global registration prevents build systems from removing unused
    components (a.k.a "tree-shaking"). If you globally register a
    component but end up not using it anywhere in your app, it will still
    be included in the final bundle.
\item
    Global registration makes dependency relationships less explicit in
    large applications. It makes it difficult to locate a child
    component's implementation from a parent component using it. This can
    affect long-term maintainability similar to using too many global
    variables.
\end{enumerate}
\switchcolumn
\begin{enumerate}
\item
    全局注册，但并没有被使用的组件无法在生产打包时被自动移除
    (也叫``tree-shaking'')。如果你全局注册了一个组件，即使它并没有被实际使用，它仍然会出现在打包后的
    JS 文件中。
\item
    全局注册在大型项目中使项目的依赖关系变得不那么明确。在父组件中使用子组件时，不太容易定位子组件的实现。和使用过多的全局变量一样，这可能会影响应用长期的可维护性。
\end{enumerate}


\switchcolumn[0]*%%%%%%%
Local registration scopes the availability of the registered components
to the current component only. It makes the dependency relationship more
explicit, and is more tree-shaking friendly.
\switchcolumn
相比之下，局部注册的组件需要在使用它的父组件中显式导入，并且只能在该父组件中使用。它的优点是使组件之间的依赖关系更加明确，并且对
tree-shaking 更加友好。
\switchcolumn[0]*%%%%%%%
When using SFC with \texttt{\textless{}script\ setup\textgreater{}},
imported components can be locally used without registration:
\switchcolumn
在使用 \texttt{\textless{}script\ setup\textgreater{}}
的单文件组件中，导入的组件可以直接在模板中使用，无需注册：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<script setup>
import ComponentA from './ComponentA.vue'
</script>
<template>
  <ComponentA />
</template>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<script setup>
import ComponentA from './ComponentA.vue'
</script>
<template>
  <ComponentA />
</template>
\end{codeHtml}


\switchcolumn[0]*%%%%%%%
In non-\texttt{\textless{}script\ setup\textgreater{}}, you will need to
use the \texttt{components} option:
\switchcolumn
如果没有使用 \texttt{\textless{}script\ setup\textgreater{}}，则需要使用
\texttt{components} 选项来显式注册：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
import ComponentA from './ComponentA.js'
export default {
  components: {
    ComponentA
  },
  setup() {
    // ...
  }
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
import ComponentA from './ComponentA.js'
export default {
  components: {
    ComponentA
  },
  setup() {
    // ...
  }
}
\end{codeJs}
\switchcolumn[0]*%%%%%%%
For each property in the \texttt{components} object, the key will be the
registered name of the component, while the value will contain the
implementation of the component. The above example is using the ES2015
property shorthand and is equivalent to:
\switchcolumn
对于每个 \texttt{components} 对象里的属性，它们的 key
名就是注册的组件名，而值就是相应组件的实现。上面的例子中使用的是 ES2015
的缩写语法，等价于：


\switchcolumn[0]*%%%%%%%
\begin{codeJs}
export default {
  components: {
    ComponentA: ComponentA
  }
  // ...
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
export default {
  components: {
    ComponentA: ComponentA
  }
  // ...
}
\end{codeJs}
\switchcolumn[0]*%%%%%%%
Note that \textbf{locally registered components are *not* also available
in descendant components}. In this case, \texttt{ComponentA} will be
made available to the current component only, not any of its child or
descendant components.
\switchcolumn
请注意：\textbf{局部注册的组件在后代组件中并*不*可用}。在这个例子中，\texttt{ComponentA}
注册后仅在当前组件可用，而在任何的子组件或更深层的子组件中都不可用。
\end{paracol}

\columnratio{0.55}
\begin{paracol}{2}

\switchcolumn[0]*%%%%%%%
\subsection{Component Name Casing}
\switchcolumn
\subsection{组件名格式}
\switchcolumn[0]*%%%%%%%
Throughout the guide, we are using PascalCase names when registering
components. This is because:
\switchcolumn
在整个指引中，我们都使用 PascalCase 作为组件名的注册格式，这是因为：
\switchcolumn[0]*%%%%%%%
\begin{enumerate}
\item
    PascalCase names are valid JavaScript identifiers. This makes it
    easier to import and register components in JavaScript. It also helps
    IDEs with auto-completion.
\item
    \texttt{\textless{}PascalCase\ /\textgreater{}} makes it more obvious
    that this is a Vue component instead of a native HTML element in
    templates. It also differentiates Vue components from custom elements
    (web components).
\end{enumerate}
\switchcolumn
\begin{enumerate}
\item
    PascalCase 是合法的 JavaScript 标识符。这使得在 JavaScript
    中导入和注册组件都很容易，同时 IDE 也能提供较好的自动补全。
\item
    \texttt{\textless{}PascalCase\ /\textgreater{}}
    在模板中更明显地表明了这是一个 Vue 组件，而不是原生 HTML
    元素。同时也能够将 Vue 组件和自定义元素 (web components) 区分开来。
\end{enumerate}


\switchcolumn[0]*%%%%%%%
This is the recommended style when working with SFC or string templates.
However, as discussed in
\href{https://vuejs.org/guide/essentials/component-basics.html\#in-dom-template-parsing-caveats}{in-DOM
Template Parsing Caveats}, PascalCase tags are not usable in in-DOM
templates.
\switchcolumn
在单文件组件和内联字符串模板中，我们都推荐这样做。但是，PascalCase
的标签名在 DOM 内模板中是不可用的，详情参见
\href{https://cn.vuejs.org/guide/essentials/component-basics.html\#in-dom-template-parsing-caveats}{DOM
内模板解析注意事项}。
\switchcolumn[0]*%%%%%%%
Luckily, Vue supports resolving kebab-case tags to components registered
using PascalCase. This means a component registered as
\texttt{MyComponent} can be referenced in the template via both
\\ \texttt{\textless{}MyComponent\textgreater{}} and
\texttt{\textless{}my-component\textgreater{}}. This allows us to use
the same JavaScript component registration code regardless of template
source.
\switchcolumn
为了方便，Vue 支持将模板中使用 kebab-case 的标签解析为使用 PascalCase
注册的组件。这意味着一个以 \texttt{MyComponent}
为名注册的组件，在模板中可以通过
\texttt{\textless{}MyComponent\textgreater{}} 或
\texttt{\textless{}my-component\textgreater{}}
引用。这让我们能够使用同样的 JavaScript
组件注册代码来配合不同来源的模板。

\end{paracol}
