\columnratio{0.55}
\begin{paracol}{2}

\switchcolumn[0]*%%%%%%%
\section{Template Refs}
\switchcolumn
\section{模板引用}
\switchcolumn[0]*%%%%%%%
While Vue's declarative rendering model abstracts away most of the
direct DOM operations for you, there may still be cases where we need
direct access to the underlying DOM elements. To achieve this, we can
use the special \texttt{ref} attribute:
\switchcolumn
虽然 Vue 的声明性渲染模型为你抽象了大部分对 DOM
的直接操作，但在某些情况下，我们仍然需要直接访问底层 DOM
元素。要实现这一点，我们可以使用特殊的 \texttt{ref} attribute：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<input ref="input">
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<input ref="input">
\end{codeHtml}

\switchcolumn[0]*%%%%%%%
\texttt{ref} is a special attribute, similar to the \texttt{key}
attribute discussed in the \texttt{v-for} chapter. It allows us to
obtain a direct reference to a specific DOM element or child component
instance after it's mounted. This may be useful when you want to, for
example, programmatically focus an input on component mount, or
initialize a 3rd party library on an element.
\switchcolumn
\texttt{ref} 是一个特殊的 attribute，和 \texttt{v-for} 章节中提到的
\texttt{key} 类似。它允许我们在一个特定的 DOM
元素或子组件实例被挂载后，获得对它的直接引用。这可能很有用，比如说在组件挂载时将焦点设置到一个
input 元素上，或在一个元素上初始化一个第三方库。


\switchcolumn[0]*%%%%%%%
\subsection{Accessing the Refs}
\switchcolumn
\subsection{访问模板引用}
\switchcolumn[0]*%%%%%%%
To obtain the reference with Composition API, we need to declare a ref
with the same name:
\switchcolumn
为了通过组合式 API 获得该模板引用，我们需要声明一个同名的 ref：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<script setup>
import { ref, onMounted } from 'vue'
//
// 声明一个 ref 来存放该元素的引用
// 必须和模板里的 ref 同名
const input = ref(null)
//
onMounted(() => {
  input.value.focus()
})
</script>
//
<template>
  <input ref="input" />
</template>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<script setup>
import { ref, onMounted } from 'vue'
//
// 声明一个 ref 来存放该元素的引用
// 必须和模板里的 ref 同名
const input = ref(null)
//
onMounted(() => {
  input.value.focus()
})
</script>
//
<template>
  <input ref="input" />
</template>
\end{codeHtml}


\switchcolumn[0]*%%%%%%%
If not using \texttt{\textless{}script\ setup\textgreater{}}, make sure
to also return the ref from \texttt{setup()}:
\switchcolumn
如果不使用 \texttt{\textless{}script\ setup\textgreater{}}，需确保从
\texttt{setup()} 返回 ref：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
export default {
  setup() {
    const input = ref(null)
    // ...
    return {
      input
    }
  }
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
export default {
  setup() {
    const input = ref(null)
    // ...
    return {
      input
    }
  }
}
\end{codeJs}
\switchcolumn[0]*%%%%%%%
Note that you can only access the ref \textbf{after the component is
mounted.} If you try to access \texttt{input} in a template expression,
it will be \texttt{null} on the first render. This is because the
element doesn't exist until after the first render!
\switchcolumn
注意，你只可以\textbf{在组件挂载后}才能访问模板引用。如果你想在模板中的表达式上访问
\texttt{input}，在初次渲染时会是
\texttt{null}。这是因为在初次渲染前这个元素还不存在呢！


\switchcolumn[0]*%%%%%%%
If you are trying to watch the changes of a template ref, make sure to
account for the case where the ref has \texttt{null} value:
\switchcolumn
如果你需要侦听一个模板引用 ref 的变化，确保考虑到其值为 \texttt{null}
的情况：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
watchEffect(() => {
  if (input.value) {
    input.value.focus()
  } else {
    // 此时还未挂载，或此元素已经被卸载（例如通过 v-if 控制）
  }
})
\end{codeJs}
\switchcolumn
\begin{codeJs}
watchEffect(() => {
  if (input.value) {
    input.value.focus()
  } else {
    // 此时还未挂载，或此元素已经被卸载（例如通过 v-if 控制）
  }
})
\end{codeJs}
\switchcolumn[0]*%%%%%%%
See also:
\href{https://vuejs.org/guide/typescript/composition-api.html\#typing-template-refs}{Typing
Template Refs}
\switchcolumn
也可参考：\href{https://cn.vuejs.org/guide/typescript/composition-api.html\#typing-template-refs}{为模板引用标注类型}


\switchcolumn[0]*%%%%%%%
\subsection{Refs inside v-for}
\switchcolumn
\subsection{v-for 中的模板引用}
\switchcolumn[0]*%%%%%%%
\begin{quote}
Requires v3.2.25 or above
\end{quote}
\switchcolumn
\begin{quote}
需要 v3.2.25 及以上版本
\end{quote}
\switchcolumn[0]*%%%%%%%
When \texttt{ref} is used inside \texttt{v-for}, the corresponding ref
should contain an Array value, which will be populated with the elements
after mount:
\switchcolumn
当在 \texttt{v-for} 中使用模板引用时，对应的 ref
中包含的值是一个数组，它将在元素被挂载后包含对应整个列表的所有元素：


\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<script setup>
import { ref, onMounted } from 'vue'
//
const list = ref([
  /* ... */
])
//
const itemRefs = ref([])
//
onMounted(() => console.log(itemRefs.value))
</script>
<!-- -->
<template>
  <ul>
    <li v-for="item in list" ref="itemRefs">
      {{ item }}
    </li>
  </ul>
</template>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<script setup>
import { ref, onMounted } from 'vue'
//
const list = ref([
  /* ... */
])
//
const itemRefs = ref([])
//
onMounted(() => console.log(itemRefs.value))
</script>
<!-- -->
<template>
  <ul>
    <li v-for="item in list" ref="itemRefs">
      {{ item }}
    </li>
  </ul>
</template>
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
\href{https://play.vuejs.org/\#eNpFjs1qwzAQhF9l0CU2uDZtb8UOlJ576bXqwaQyCGRJyCsTEHr3rGwnOehnd2e+nSQ+vW/XqMSH6JdL0J6wKIr+LK2evQuEhKCmBs5+u2hJ/SNjCm7GiV0naaW9OLsQjOZrKNrq97XBW4P3v/o51qTmHzUtd8k+e0CrqsZwRpIWGI0KVN0N7TqaqNp59JUuEt2SutKXY5elmimZT9/t2Tk1F+z0ZiTFFdBHs738Mxrry+TCIEWhQ9sttRQl0tEsK6U4HEBKW3LkfDA6o3dst3H77rFM5BtTfm/P}{Try
it in the Playground}
\switchcolumn
\href{https://play.vuejs.org/\#eNpFjs1qwzAQhF9l0CU2uDZtb8UOlJ576bXqwaQyCGRJyCsTEHr3rGwnOehnd2e+nSQ+vW/XqMSH6JdL0J6wKIr+LK2evQuEhKCmBs5+u2hJ/SNjCm7GiV0naaW9OLsQjOZrKNrq97XBW4P3v/o51qTmHzUtd8k+e0CrqsZwRpIWGI0KVN0N7TqaqNp59JUuEt2SutKXY5elmimZT9/t2Tk1F+z0ZiTFFdBHs738Mxrry+TCIEWhQ9sttRQl0tEsK6U4HEBKW3LkfDA6o3dst3H77rFM5BtTfm/P}{在演练场中尝试一下}
\switchcolumn[0]*%%%%%%%
It should be noted that the ref array does \textbf{not} guarantee the
same order as the source array.
\switchcolumn
应该注意的是，ref 数组\textbf{并不}保证与源数组相同的顺序。


\switchcolumn[0]*%%%%%%% 
\subsection{Function Refs}
\switchcolumn
\subsection{函数模板引用}
\switchcolumn[0]*%%%%%%%
Instead of a string key, the \texttt{ref} attribute can also be bound to
a function, which will be called on each component update and gives you
full flexibility on where to store the element reference. The function
receives the element reference as the first argument:
\switchcolumn
除了使用字符串值作名字，\texttt{ref} attribute
还可以绑定为一个函数，会在每次组件更新时都被调用。该函数会收到元素引用作为其第一个参数：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<input :ref="(el) => { /* 将 el 赋值给一个数据属性或 ref 变量 */ }">
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<input :ref="(el) => { /* 将 el 赋值给一个数据属性或 ref 变量 */ }">
\end{codeHtml}


\switchcolumn[0]*%%%%%%%
Note we are using a dynamic \texttt{:ref} binding so we can pass it a
function instead of a ref name string. When the element is unmounted,
the argument will be \texttt{null}. You can, of course, use a method
instead of an inline function.
\switchcolumn
注意我们这里需要使用动态的 \texttt{:ref}
绑定才能够传入一个函数。当绑定的元素被卸载时，函数也会被调用一次，此时的
\texttt{el} 参数会是
\texttt{null}。你当然也可以绑定一个组件方法而不是内联函数。
\switchcolumn[0]*%%%%%%%
\subsection{Ref on Component}
\switchcolumn
\subsection{组件上的 ref}
\switchcolumn[0]*%%%%%%%
\begin{quote}
This section assumes knowledge of
\href{https://vuejs.org/guide/essentials/component-basics.html}{Components}.
Feel free to skip it and come back later.
\end{quote}
\switchcolumn
\begin{quote}
这一小节假设你已了解\href{https://cn.vuejs.org/guide/essentials/component-basics.html}{组件}的相关知识，或者你也可以先跳过这里，之后再回来看。
\end{quote}


\switchcolumn[0]*%%%%%%%
\texttt{ref} can also be used on a child component. In this case the
reference will be that of a component instance:
\switchcolumn
模板引用也可以被用在一个子组件上。这种情况下引用中获得的值是组件实例：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<script setup>
import { ref, onMounted } from 'vue'
import Child from './Child.vue'
<!-- -->
const child = ref(null)
<!-- -->
onMounted(() => {
  // child.value 是 <Child /> 组件的实例
})
</script>
<!-- -->
<template>
  <Child ref="child" />
</template>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<script setup>
import { ref, onMounted } from 'vue'
import Child from './Child.vue'
<!-- -->
const child = ref(null)
<!-- -->
onMounted(() => {
  // child.value 是 <Child /> 组件的实例
})
</script>
<!-- -->
<template>
  <Child ref="child" />
</template>
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
If the child component is using Options API or not using
\texttt{\textless{}script\ setup\textgreater{}}, the referenced instance
will be identical to the child component's \texttt{this}, which means
the parent component will have full access to every property and method
of the child component. This makes it easy to create tightly coupled
implementation details between the parent and the child, so component
refs should be only used when absolutely needed - in most cases, you
should try to implement parent / child interactions using the standard
props and emit interfaces first.
\switchcolumn
如果一个子组件使用的是选项式 API 或没有使用
\texttt{\textless{}script\ setup\textgreater{}}，被引用的组件实例和该子组件的
\texttt{this}
完全一致，这意味着父组件对子组件的每一个属性和方法都有完全的访问权。这使得在父组件和子组件之间创建紧密耦合的实现细节变得很容易，当然也因此，应该只在绝对需要时才使用组件引用。大多数情况下，你应该首先使用标准的
props 和 emit 接口来实现父子组件交互。


\switchcolumn[0]*%%%%%%%
An exception here is that components using
\texttt{\textless{}script\ setup\textgreater{}} are \textbf{private by
default}: a parent component referencing a child component using
\texttt{\textless{}script\ setup\textgreater{}} won't be able to access
anything unless the child component chooses to expose a public interface
using the \texttt{defineExpose} macro:
\switchcolumn
有一个例外的情况，使用了 \texttt{\textless{}script\ setup\textgreater{}}
的组件是\textbf{默认私有}的：一个父组件无法访问到一个使用了
\texttt{\textless{}script\ setup\textgreater{}}
的子组件中的任何东西，除非子组件在其中通过 \texttt{defineExpose}
宏显式暴露：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<script setup>
import { ref } from 'vue'
<!-- -->
const a = 1
const b = ref(2)
<!-- -->
// 像 defineExpose 这样的编译器宏不需要导入
defineExpose({
  a,
  b
})
</script>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<script setup>
import { ref } from 'vue'
<!-- -->
const a = 1
const b = ref(2)
<!-- -->
// 像 defineExpose 这样的编译器宏不需要导入
defineExpose({
  a,
  b
})
</script>
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
When a parent gets an instance of this component via template refs, the
retrieved instance will be of the shape
\texttt{\{\ a:\ number,\ b:\ number\ \}} (refs are automatically
unwrapped just like on normal instances).
\switchcolumn
当父组件通过模板引用获取到了该组件的实例时，得到的实例类型为
\texttt{\{\ a:\ number,\ b:\ number\ \}} (ref
都会自动解包，和一般的实例一样)。


\switchcolumn[0]*%%%%%%%
See also:
\href{https://vuejs.org/guide/typescript/composition-api.html\#typing-component-template-refs}{Typing
Component Template Refs}
\switchcolumn
TypeScript
用户请参考：\href{https://cn.vuejs.org/guide/typescript/composition-api.html\#typing-component-template-refs}{为组件的模板引用标注类型}
\end{paracol}
