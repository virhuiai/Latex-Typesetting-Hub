
\columnratio{0.55}
\begin{paracol}{2}
 
\switchcolumn[0]*%%%%%%%
\section{Testing}
\switchcolumn
\section{测试}
\switchcolumn[0]*%%%%%%%
\subsection{Why Test?}
\switchcolumn
\subsection{为什么需要测试}
\switchcolumn[0]*%%%%%%%
Automated tests help you and your team build complex Vue applications
quickly and confidently by preventing regressions and encouraging you to
break apart your application into testable functions, modules, classes,
and components. As with any application, your new Vue app can break in
many ways, and it's important that you can catch these issues and fix
them before releasing.
\switchcolumn
自动化测试能够预防无意引入的
bug，并鼓励开发者将应用分解为可测试、可维护的函数、模块、类和组件。这能够帮助你和你的团队更快速、自信地构建复杂的
Vue 应用。与任何应用一样，新的 Vue
应用可能会以多种方式崩溃，因此，在发布前发现并解决这些问题就变得十分重要。
\switchcolumn[0]*%%%%%%%
In this guide, we'll cover basic terminology and provide our
recommendations on which tools to choose for your Vue 3 application.
\switchcolumn
在本篇指引中，我们将介绍一些基本术语，并就你的 Vue 3
应用应选择哪些工具提供一些建议。
\switchcolumn[0]*%%%%%%%
There is one Vue-specific section covering composables. See
\href{https://vuejs.org/guide/scaling-up/testing.html\#testing-composables}{Testing
Composables} below for more details.
\switchcolumn
还有一个特定用于 Vue
的小节，介绍了组合式函数的测试，详情请参阅\href{https://cn.vuejs.org/guide/scaling-up/testing.html\#testing-composables}{测试组合式函数}。
\switchcolumn[0]*%%%%%%%
\subsection{When to Test}
\switchcolumn
\subsection{何时测试}
\switchcolumn[0]*%%%%%%%
Start testing early! We recommend you begin writing tests as soon as you
can. The longer you wait to add tests to your application, the more
dependencies your application will have, and the harder it will be to
start.
\switchcolumn
越早越好！我们建议你尽快开始编写测试。拖得越久，应用就会有越多的依赖和复杂性，想要开始添加测试也就越困难。
\switchcolumn[0]*%%%%%%%
\subsection{Testing Types}
\switchcolumn
\subsection{测试的类型}
\switchcolumn[0]*%%%%%%%
When designing your Vue application's testing strategy, you should
leverage the following testing types:
\switchcolumn
当设计你的 Vue 应用的测试策略时，你应该利用以下几种测试类型：
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  \textbf{Unit}: Checks that inputs to a given function, class, or
  composable are producing the expected output or side effects.
\item
  \textbf{Component}: Checks that your component mounts, renders, can be
  interacted with, and behaves as expected. These tests import more code
  than unit tests, are more complex, and require more time to execute.
\item
  \textbf{End-to-end}: Checks features that span multiple pages and
  makes real network requests against your production-built Vue
  application. These tests often involve standing up a database or other
  backend.
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  \textbf{单元测试}：检查给定函数、类或组合式函数的输入是否产生预期的输出或副作用。
\item
  \textbf{组件测试}：检查你的组件是否正常挂载和渲染、是否可以与之互动，以及表现是否符合预期。这些测试比单元测试导入了更多的代码，更复杂，需要更多时间来执行。
\item
  \textbf{端到端测试}：检查跨越多个页面的功能，并对生产构建的 Vue
  应用进行实际的网络请求。这些测试通常涉及到建立一个数据库或其他后端。
\end{itemize}
\switchcolumn[0]*%%%%%%%
Each testing type plays a role in your application's testing strategy,
and each will protect you against different types of issues.
\switchcolumn
每种测试类型在你的应用的测试策略中都发挥着作用，保护你免受不同类型的问题的影响。
\switchcolumn[0]*%%%%%%%
\subsection{Overview}
\switchcolumn
\subsection{总览}
\switchcolumn[0]*%%%%%%%
We will briefly discuss what each of these are, how they can be
implemented for Vue applications, and provide some general
recommendations.
\switchcolumn
我们将简要地讨论这些测试是什么，以及如何在 Vue
应用中实现它们，并提供一些普适性建议。
\switchcolumn[0]*%%%%%%%
\subsection{Unit Testing}
\switchcolumn
\subsection{单元测试}
\switchcolumn[0]*%%%%%%%
Unit tests are written to verify that small, isolated units of code are
working as expected. A unit test usually covers a single function,
class, composable, or module. Unit tests focus on logical correctness
and only concern themselves with a small portion of the application's
overall functionality. They may mock large parts of your application's
environment (e.g. initial state, complex classes, 3rd party modules, and
network requests).
\switchcolumn
编写单元测试是为了验证小的、独立的代码单元是否按预期工作。一个单元测试通常覆盖一个单个函数、类、组合式函数或模块。单元测试侧重于逻辑上的正确性，只关注应用整体功能的一小部分。他们可能会模拟你的应用环境的很大一部分（如初始状态、复杂的类、第三方模块和网络请求）。
\switchcolumn[0]*%%%%%%%
In general, unit tests will catch issues with a function's business
logic and logical correctness.
\switchcolumn
一般来说，单元测试将捕获函数的业务逻辑和逻辑正确性的问题。
\switchcolumn[0]*%%%%%%%
Take for example this \texttt{increment} function:
\switchcolumn
以这个 \texttt{increment} 函数为例：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// helpers.js
export function increment (current, max = 10) {
  if (current < max) {
    return current + 1
  }
  return current
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
// helpers.js
export function increment (current, max = 10) {
  if (current < max) {
    return current + 1
  }
  return current
}
\end{codeJs}
\switchcolumn[0]*%%%%%%%
Because it's very self-contained, it'll be easy to invoke the increment
function and assert that it returns what it's supposed to, so we'll
write a Unit Test.
\switchcolumn
因为它很独立，可以很容易地调用 \texttt{increment}
函数并断言它是否返回了所期望的内容，所以我们将编写一个单元测试。
\switchcolumn[0]*%%%%%%%
If any of these assertions fail, it's clear that the issue is contained
within the \texttt{increment} function.
\switchcolumn
如果任何一条断言失败了，那么问题一定是出在 \texttt{increment} 函数上。
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// helpers.spec.js
import { increment } from './helpers'
describe('increment', () => {
  test('increments the current number by 1', () => {
    expect(increment(0, 10)).toBe(1)
  })
  test('does not increment the current number over the max', () => {
    expect(increment(10, 10)).toBe(10)
  })
  test('has a default max of 10', () => {
    expect(increment(10)).toBe(10)
  })
})
\end{codeJs}
\switchcolumn
\begin{codeJs}
// helpers.spec.js
import { increment } from './helpers'
describe('increment', () => {
  test('increments the current number by 1', () => {
    expect(increment(0, 10)).toBe(1)
  })
  test('does not increment the current number over the max', () => {
    expect(increment(10, 10)).toBe(10)
  })
  test('has a default max of 10', () => {
    expect(increment(10)).toBe(10)
  })
})
\end{codeJs}
\switchcolumn[0]*%%%%%%%
As mentioned previously, unit testing is typically applied to
self-contained business logic, components, classes, modules, or
functions that do not involve UI rendering, network requests, or other
environmental concerns.
\switchcolumn
如前所述，单元测试通常适用于独立的业务逻辑、组件、类、模块或函数，不涉及
UI 渲染、网络请求或其他环境问题。
\switchcolumn[0]*%%%%%%%
These are typically plain JavaScript / TypeScript modules unrelated to
Vue. In general, writing unit tests for business logic in Vue
applications does not differ significantly from applications using other
frameworks.
\switchcolumn
这些通常是与 Vue 无关的纯 JavaScript/TypeScript 模块。一般来说，在 Vue
应用中为业务逻辑编写单元测试与使用其他框架的应用没有明显区别。
\switchcolumn[0]*%%%%%%%
There are two instances where you DO unit test Vue-specific features:
\switchcolumn
但有两种情况，你必须对 Vue 的特定功能进行单元测试：
\switchcolumn[0]*%%%%%%%
\begin{enumerate}
\item
  Composables
\item
  Components
\end{enumerate}
\switchcolumn
\begin{enumerate}
\item
  组合式函数
\item
  组件
\end{enumerate}
\switchcolumn[0]*%%%%%%%
\subsubsection{Composables}
\switchcolumn
\subsubsection{组合式函数}
\switchcolumn[0]*%%%%%%%
One category of functions specific to Vue applications is
\href{https://vuejs.org/guide/reusability/composables.html}{Composables},
which may require special handling during tests. See
\href{https://vuejs.org/guide/scaling-up/testing.html\#testing-composables}{Testing
Composables} below for more details.
\switchcolumn
有一类 Vue 应用中特有的函数被称为
\href{https://cn.vuejs.org/guide/reusability/composables.html}{组合式函数}，在测试过程中可能需要特殊处理。
你可以跳转到下方查看
\href{https://cn.vuejs.org/guide/scaling-up/testing.html\#testing-composables}{测试组合式函数}
了解更多细节。
\end{paracol}

\columnratio{0.55}
\begin{paracol}{2}
\switchcolumn[0]*%%%%%%%
\subsubsection{Unit Testing Components}
\switchcolumn
\subsubsection{组件的单元测试}
\switchcolumn[0]*%%%%%%%
A component can be tested in two ways:
\switchcolumn
一个组件可以通过两种方式测试：
\switchcolumn[0]*%%%%%%%
\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Whitebox: Unit Testing\\
  Tests that are "Whitebox tests" are aware of the implementation
  details and dependencies of a component. They are focused on
  \textbf{isolating} the component under test. These tests will usually
  involve mocking some, if not all of your component's children, as well
  as setting up plugin state and dependencies (e.g. Pinia).
\item
  Blackbox: Component Testing\\
  Tests that are "Blackbox tests" are unaware of the implementation
  details of a component. These tests mock as little as possible to test
  the integration of your component and the entire system. They usually
  render all child components and are considered more of an "integration
  test". See the
  \href{https://vuejs.org/guide/scaling-up/testing.html\#component-testing}{Component
  Testing recommendations} below.
\end{enumerate}
\switchcolumn
\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  白盒：单元测试\\
  白盒测试知晓一个组件的实现细节和依赖关系。它们更专注于将组件进行更
  \textbf{独立}
  的测试。这些测试通常会涉及到模拟一些组件的部分子组件，以及设置插件的状态和依赖性（例如
  Pinia）。
\item
  黑盒：组件测试\\
  黑盒测试不知晓一个组件的实现细节。这些测试尽可能少地模拟，以测试组件在整个系统中的集成情况。它们通常会渲染所有子组件，因而会被认为更像一种``集成测试''。请查看下方的\href{https://cn.vuejs.org/guide/scaling-up/testing.html\#component-testing}{组件测试建议}作进一步了解。
\end{enumerate}
\switchcolumn[0]*%%%%%%%
\subsubsection{Recommendation}
\switchcolumn
\subsubsection{推荐方案}
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  \href{https://vitest.dev/}{Vitest}\\
  Since the official setup created by \texttt{create-vue} is based on
  \href{https://vitejs.dev/}{Vite}, we recommend using a unit testing
  framework that can leverage the same configuration and transform
  pipeline directly from Vite. \href{https://vitest.dev/}{Vitest} is a
  unit testing framework designed specifically for this purpose, created
  and maintained by Vue / Vite team members. It integrates with
  Vite-based projects with minimal effort, and is blazing fast.
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  \href{https://vitest.dev/}{Vitest}\\
  因为由 \texttt{create-vue} 创建的官方项目配置是基于
  \href{https://cn.vitejs.dev/}{Vite}
  的，所以我们推荐你使用一个可以利用同一套 Vite
  配置和转换管道的单元测试框架。\href{https://cn.vitest.dev/}{Vitest}
  正是一个针对此目标设计的单元测试框架，它由 Vue / Vite
  团队成员开发和维护。在 Vite 的项目集成它会非常简单，而且速度非常快。
\end{itemize}
\switchcolumn[0]*%%%%%%%
\subsubsection{Other Options}
\switchcolumn
\subsubsection{其他选择}
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  \href{https://peeky.dev/}{Peeky} is another fast unit test runner with
  first-class Vite integration. It is also created by a Vue core team
  member and offers a GUI-based testing interface.
\item
  \href{https://jestjs.io/}{Jest} is a popular unit testing framework,
  and can be made to work with Vite via the
  \href{https://github.com/sodatea/vite-jest}{vite-jest} package.
  However, we only recommend Jest if you have an existing Jest test
  suite that needs to be migrated over to a Vite-based project, as
  Vitest offers a more seamless integration and better performance.
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  \href{https://peeky.dev/}{Peeky} 是另一速度极快的单元测试运行器，对
  Vite 集成提供第一优先级支持。它也是由 Vue
  核心团队成员创建的，并提供了一个基于图形用户界面（GUI）的测试界面。
\item
  \href{https://jestjs.io/}{Jest} 是一个广受欢迎的单元测试框架，并可通过
  \href{https://github.com/sodatea/vite-jest}{vite-jest} 这个包在 Vite
  中使用。不过，我们只推荐你在已有一套 Jest 测试配置、且需要迁移到基于
  Vite 的项目时使用它，因为 Vitest 提供了更无缝的集成和更好的性能。
\end{itemize}
\end{paracol}

\columnratio{0.55}
\begin{paracol}{2}
 
\switchcolumn[0]*%%%%%%%
\subsection{Component Testing}
\switchcolumn
\subsection{组件测试}
\switchcolumn[0]*%%%%%%%
In Vue applications, components are the main building blocks of the UI.
Components are therefore the natural unit of isolation when it comes to
validating your application's behavior. From a granularity perspective,
component testing sits somewhere above unit testing and can be
considered a form of integration testing. Much of your Vue Application
should be covered by a component test and we recommend that each Vue
component has its own spec file.
\switchcolumn
在 Vue
应用中，主要用组件来构建用户界面。因此，当验证应用的行为时，组件是一个很自然的独立单元。从粒度的角度来看，组件测试位于单元测试之上，可以被认为是集成测试的一种形式。你的
Vue 应用中大部分内容都应该由组件测试来覆盖，我们建议每个 Vue
组件都应有自己的组件测试文件。
\switchcolumn[0]*%%%%%%%
Component tests should catch issues relating to your component's props,
events, slots that it provides, styles, classes, lifecycle hooks, and
more.
\switchcolumn
组件测试应该捕捉组件中的 prop、事件、提供的插槽、样式、CSS class
名、生命周期钩子，和其他相关的问题。
\switchcolumn[0]*%%%%%%%
Component tests should not mock child components, but instead test the
interactions between your component and its children by interacting with
the components as a user would. For example, a component test should
click on an element like a user would instead of programmatically
interacting with the component.
\switchcolumn
组件测试不应该模拟子组件，而应该像用户一样，通过与组件互动来测试组件和其子组件之间的交互。例如，组件测试应该像用户那样点击一个元素，而不是编程式地与组件进行交互。
\switchcolumn[0]*%%%%%%%
Component tests should focus on the component's public interfaces rather
than internal implementation details. For most components, the public
interface is limited to: events emitted, props, and slots. When testing,
remember to \textbf{test what a component does, not how it does it}.
\switchcolumn
组件测试主要需要关心组件的公开接口而不是内部实现细节。对于大部分的组件来说，公开接口包括触发的事件、prop
和插槽。当进行测试时，请记住，\textbf{测试这个组件做了什么，而不是测试它是怎么做到的}。
\switchcolumn[0]*%%%%%%%
\textbf{DO}
\switchcolumn
\textbf{推荐的做法}
\end{paracol}

\begin{itemize}
\columnratio{0.55}
\begin{paracol}{2}
\switchcolumn[0]*%%%%%%%
\item
    For \textbf{Visual} logic: assert correct render output based on
    inputted props and slots.
\switchcolumn
    \item
    对于 \textbf{视图} 的测试：根据输入 prop
    和插槽断言渲染输出是否正确。
\switchcolumn[0]*%%%%%%%
\item
    For \textbf{Behavioral} logic: assert correct render updates or
    emitted events in response to user input events.
\switchcolumn
    \item
    对于 \textbf{交互}
    的测试：断言渲染的更新是否正确或触发的事件是否正确地响应了用户输入事件。
\end{paracol}
\end{itemize}    


\columnratio{0.55}
\begin{paracol}{2}
\switchcolumn[0]*%%%%%%%
In the below example, we demonstrate a Stepper component that has a
DOM element labeled "increment" and can be clicked. We pass a prop
called \texttt{max} that prevents the Stepper from being incremented
past \texttt{2}, so if we click the button 3 times, the UI should
still say \texttt{2}.
\switchcolumn
在下面的例子中，我们展示了一个步进器（Stepper）组件，它拥有一个标记为
\texttt{increment} 的可点击的 DOM 元素。我们还传入了一个名为
\texttt{max} 的 prop 防止步进器增长超过
\texttt{2}，因此如果我们点击了按钮 3 次，视图将仍然显示 \texttt{2}。
\switchcolumn[0]*%%%%%%%
We know nothing about the implementation of Stepper, only that the
"input" is the \texttt{max} prop and the "output" is the state of the
DOM as the user will see it.
\switchcolumn
我们不了解这个步进器的实现细节，只知道``输入''是这个 \texttt{max}
prop，``输出''是这个组件状态所呈现出的视图。
\end{paracol}

\begin{codeJs*}{label={Vue Test Utils}}

\end{codeJs*}    

\begin{codeJs*}{label={Cypress}}
const valueSelector = '[data-testid=stepper-value]'
const buttonSelector = '[data-testid=increment]'

mount(Stepper, {
    props: {
    max: 1
    }
})

cy.get(valueSelector).should('be.visible').and('contain.text', '0')
    .get(buttonSelector).click()
    .get(valueSelector).should('contain.text', '1')
\end{codeJs*}    

\begin{codeJs*}{label={Testing Library}}
const { getByText } = render(Stepper, {
props: {
    max: 1
}
})

getByText('0') // 隐式断言 "0" 在这个组件中

const button = getByText('increment')

// 向我们的增长按钮发送一个点击事件。
await fireEvent.click(button)

getByText('1')

await fireEvent.click(button)
\end{codeJs*}    

\columnratio{0.55}
\begin{paracol}{2}

\switchcolumn[0]*%%%%%%%
\textbf{DON'T}
\switchcolumn
\textbf{应避免的做法}
\switchcolumn[0]*%%%%%%%
Don't assert the private state of a component instance or test the
private methods of a component. Testing implementation details makes
the tests brittle, as they are more likely to break and require
updates when the implementation changes.
\switchcolumn
不要去断言一个组件实例的私有状态或测试一个组件的私有方法。测试实现细节会使测试代码太脆弱，因为当实现发生变化时，它们更有可能失败并需要更新重写。
\switchcolumn[0]*%%%%%%%
  The component's ultimate job is rendering the correct DOM output, so
  tests focusing on the DOM output provide the same level of correctness
  assurance (if not more) while being more robust and resilient to
  change.
\switchcolumn
  组件的最终工作是渲染正确的 DOM 输出，所以专注于 DOM
  输出的测试提供了足够的正确性保证（如果你不需要更多其他方面测试的话），同时更加健壮、需要的改动更少。
\switchcolumn[0]*%%%%%%%
  Don't rely exclusively on snapshot tests. Asserting HTML strings does
  not describe correctness. Write tests with intentionality.
\switchcolumn
  不要完全依赖快照测试。断言 HTML
  字符串并不能完全说明正确性。应当编写有意图的测试。
\switchcolumn[0]*%%%%%%%
  If a method needs to be tested thoroughly, consider extracting it into
  a standalone utility function and write a dedicated unit test for it.
  If it cannot be extracted cleanly, it may be tested as a part of a
  component, integration, or end-to-end test that covers it.
\switchcolumn
  如果一个方法需要测试，把它提取到一个独立的实用函数中，并为它写一个专门的单元测试。如果它不能被直截了当地抽离出来，那么对它的调用应该作为交互测试的一部分。
\end{paracol}


\columnratio{0.55}
\begin{paracol}{2}
 
\switchcolumn[0]*%%%%%%%
\subsubsection{Recommendation}
\switchcolumn
\subsubsection{推荐方案}
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  \href{https://vitest.dev/}{Vitest} for components or composables that
  render headlessly (e.g. the
  \href{https://vueuse.org/core/useFavicon/\#usefavicon}{\texttt{useFavicon}}
  function in VueUse). Components and DOM can be tested using
  \href{https://github.com/vuejs/test-utils}{\texttt{@vue/test-utils}}.
\item
  \href{https://on.cypress.io/component}{Cypress Component Testing} for
  components whose expected behavior depends on properly rendering
  styles or triggering native DOM events. It can be used with Testing
  Library via
  \href{https://testing-library.com/docs/cypress-testing-library/intro}{@testing-library/cypress}.
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  \href{https://vitest.dev/}{Vitest}
  对于组件和组合式函数都采用无头渲染的方式 (例如 VueUse 中的
  \href{https://vueuse.org/core/useFavicon/\#usefavicon}{\texttt{useFavicon}}
  函数)。组件和 DOM 都可以通过
  \href{https://github.com/vuejs/test-utils}{@vue/test-utils} 来测试。
\item
  \href{https://on.cypress.io/component}{Cypress 组件测试}
  会预期其准确地渲染样式或者触发原生 DOM 事件。可以搭配
  \href{https://testing-library.com/docs/cypress-testing-library/intro}{@testing-library/cypress}
  这个库一同进行测试。
\end{itemize}
\switchcolumn[0]*%%%%%%%
The main differences between Vitest and browser-based runners are speed
and execution context. In short, browser-based runners, like Cypress,
can catch issues that node-based runners, like Vitest, cannot (e.g.
style issues, real native DOM events, cookies, local storage, and
network failures), but browser-based runners are \emph{orders of
magnitude slower than Vitest} because they do open a browser, compile
your stylesheets, and more. Cypress is a browser-based runner that
supports component testing. Please read
\href{https://vitest.dev/guide/comparisons.html\#cypress}{Vitest's
comparison page} for the latest information comparing Vitest and
Cypress.
\switchcolumn
Vitest
和基于浏览器的运行器之间的主要区别是速度和执行上下文。简而言之，基于浏览器的运行器，如
Cypress，可以捕捉到基于 Node 的运行器（如
Vitest）所不能捕捉的问题（比如样式问题、原生 DOM
事件、Cookies、本地存储和网络故障），但基于浏览器的运行器比 Vitest
\emph{慢几个数量级}，因为它们要执行打开浏览器，编译样式表以及其他步骤。Cypress
是一个基于浏览器的运行器，支持组件测试。请阅读
\href{https://vitest.dev/guide/comparisons.html\#cypress}{Vitest
文档的``比较''这一章} 了解 Vitest 和 Cypress 最新的比较信息。
\end{paracol}



\columnratio{0.55}
\begin{paracol}{2}
 
\switchcolumn[0]*%%%%%%%
\subsubsection{Mounting Libraries}
\switchcolumn
\subsubsection{组件挂载库}
\switchcolumn[0]*%%%%%%%
Component testing often involves mounting the component being tested in
isolation, triggering simulated user input events, and asserting on the
rendered DOM output. There are dedicated utility libraries that make
these tasks simpler.
\switchcolumn
组件测试通常涉及到单独挂载被测试的组件，触发模拟的用户输入事件，并对渲染的
DOM 输出进行断言。有一些专门的工具库可以使这些任务变得更简单。
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  \href{https://github.com/vuejs/test-utils}{\texttt{@vue/test-utils}}
  is the official low-level component testing library that was written
  to provide users access to Vue specific APIs. It's also the
  lower-level library \texttt{@testing-library/vue} is built on top of.
\item
  \href{https://github.com/testing-library/vue-testing-library}{\texttt{@testing-library/vue}}
  is a Vue testing library focused on testing components without relying
  on implementation details. Its guiding principle is that the more
  tests resemble the way software is used, the more confidence they can
  provide.
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  \href{https://github.com/vuejs/test-utils}{\texttt{@vue/test-utils}}
  是官方的底层组件测试库，用来提供给用户访问 Vue 特有的
  API。\texttt{@testing-library/vue} 也是基于此库构建的。
\item
  \href{https://github.com/testing-library/vue-testing-library}{\texttt{@testing-library/vue}}
  是一个专注于测试组件而不依赖于实现细节的 Vue
  测试库。它的指导原则是：测试越是类似于软件的使用方式，它们就能提供越多的信心。
\end{itemize}
\switchcolumn[0]*%%%%%%%
We recommend using \texttt{@vue/test-utils} for testing components in
applications. \texttt{@testing-library/vue} has issues with testing
asynchronous component with Suspense, so it should be used with caution.
\switchcolumn
我们推荐在应用中使用 \texttt{@vue/test-utils}
测试组件。\texttt{@testing-library/vue} 在测试带有 Suspense
的异步组件时存在问题，在使用时需要谨慎。
\switchcolumn[0]*%%%%%%%
\subsubsection{Other Options}
\switchcolumn
\subsubsection{其他选择}
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  \href{https://nightwatchjs.org/}{Nightwatch} is an E2E test runner
  with Vue Component Testing support.
  (\href{https://github.com/nightwatchjs-community/todo-vue}{Example
  Project})
\item
  \href{https://webdriver.io/docs/component-testing/vue}{WebdriverIO}
  for cross-browser component testing that relies on native user
  interaction based on standardized automation. It can also be used with
  Testing Library.
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  \href{https://v2.nightwatchjs.org/}{Nightwatch}
  是一个端到端测试运行器，支持 Vue 的组件测试。(Nightwatch v2 版本的
  \href{https://github.com/nightwatchjs-community/todo-vue}{示例项目})
\item
  \href{https://webdriver.io/docs/component-testing/vue}{WebdriverIO}
  用于跨浏览器组件测试，该测试依赖于基于标准自动化的原生用户交互。也可以与测试库一起使用。
\end{itemize}
\end{paracol}


\columnratio{0.55}
\begin{paracol}{2}
 
\switchcolumn[0]*%%%%%%%
\subsection{E2E Testing}
\switchcolumn
\subsection{端到端（E2E）测试}
\switchcolumn[0]*%%%%%%%
While unit tests provide developers with some degree of confidence, unit
and component tests are limited in their abilities to provide holistic
coverage of an application when deployed to production. As a result,
end-to-end (E2E) tests provide coverage on what is arguably the most
important aspect of an application: what happens when users actually use
your applications.
\switchcolumn
虽然单元测试为所写的代码提供了一定程度的验证，但单元测试和组件测试在部署到生产时，对应用整体覆盖的能力有限。因此，端到端测试针对的可以说是应用最重要的方面：当用户实际使用你的应用时发生了什么。
\switchcolumn[0]*%%%%%%%
End-to-end tests focus on multi-page application behavior that makes
network requests against your production-built Vue application. They
often involve standing up a database or other backend and may even be
run against a live staging environment.
\switchcolumn
端到端测试的重点是多页面的应用表现，针对你的应用在生产环境下进行网络请求。他们通常需要建立一个数据库或其他形式的后端，甚至可能针对一个预备上线的环境运行。
\switchcolumn[0]*%%%%%%%
End-to-end tests will often catch issues with your router, state
management library, top-level components (e.g. an App or Layout), public
assets, or any request handling. As stated above, they catch critical
issues that may be impossible to catch with unit tests or component
tests.
\switchcolumn
端到端测试通常会捕捉到路由、状态管理库、顶级组件（常见为 App 或
Layout）、公共资源或任何请求处理方面的问题。如上所述，它们可以捕捉到单元测试或组件测试无法捕捉的关键问题。
\switchcolumn[0]*%%%%%%%
End-to-end tests do not import any of your Vue application's code but
instead rely completely on testing your application by navigating
through entire pages in a real browser.
\switchcolumn
端到端测试不导入任何 Vue
应用的代码，而是完全依靠在真实浏览器中浏览整个页面来测试你的应用。
\switchcolumn[0]*%%%%%%%
End-to-end tests validate many of the layers in your application. They
can either target your locally built application or even a live Staging
environment. Testing against your Staging environment not only includes
your frontend code and static server but all associated backend services
and infrastructure.
\switchcolumn
端到端测试验证了你的应用中的许多层。可以在你的本地构建的应用中，甚至是一个预上线的环境中运行。针对预上线环境的测试不仅包括你的前端代码和静态服务器，还包括所有相关的后端服务和基础设施。
\switchcolumn[0]*%%%%%%%
\begin{quote}
The more your tests resemble how your software is used, the more
confidence they can give you. -
\href{https://twitter.com/kentcdodds/status/977018512689455106}{Kent C.
Dodds} - Author of the Testing Library
\end{quote}
\switchcolumn
\begin{quote}
你的测试越是类似于你的软件的使用方式，它们就越能值得你信赖。-
\href{https://twitter.com/kentcdodds/status/977018512689455106}{Kent C.
Dodds} - Testing Library 的作者
\end{quote}
\switchcolumn[0]*%%%%%%%
By testing how user actions impact your application, E2E tests are often
the key to higher confidence in whether an application is functioning
properly or not.
\switchcolumn
通过测试用户操作如何影响你的应用，端到端测试通常是提高应用能否正常运行的置信度的关键。
\end{paracol}


\columnratio{0.55}
\begin{paracol}{2}
 
\switchcolumn[0]*%%%%%%%
\subsubsection{Choosing an E2E Testing Solution}
\switchcolumn
\subsubsection{选择一个端到端测试解决方案}
\switchcolumn[0]*%%%%%%%
While end-to-end (E2E) testing on the web has gained a negative
reputation for unreliable (flaky) tests and slowing down development
processes, modern E2E tools have made strides forward to create more
reliable, interactive, and useful tests. When choosing an E2E testing
framework, the following sections provide some guidance on things to
keep in mind when choosing a testing framework for your application.
\switchcolumn
虽然因为不可靠且拖慢了开发过程，市面上对 Web
上的端到端测试的评价并不好，但现代端到端工具已经在创建更可靠、更有用和交互性更好的测试方面取得了很大进步。在选择端到端测试框架时，以下小节会为你给应用选择测试框架时需要注意的事项提供一些指导。
\switchcolumn[0]*%%%%%%%
\paragraph{Cross-browser testing}
\switchcolumn
\paragraph{跨浏览器测试}
\switchcolumn[0]*%%%%%%%
One of the primary benefits that end-to-end (E2E) testing is known for
is its ability to test your application across multiple browsers. While
it may seem desirable to have 100\% cross-browser coverage, it is
important to note that cross browser testing has diminishing returns on
a team's resources due to the additional time and machine power required
to run them consistently. As a result, it is important to be mindful of
this trade-off when choosing the amount of cross-browser testing your
application needs.
\switchcolumn
端到端测试的一个主要优点是你可以了解你的应用在多个不同浏览器上运行的情况。尽管理想情况应该是
100\%
的跨浏览器覆盖率，但很重要的一点是跨浏览器测试对团队资源的回报是递减的，因为需要额外的时间和机器来持续运行它们。因此，在选择应用所需的跨浏览器测试的数量时，注意权衡是很有必要的。
\switchcolumn[0]*%%%%%%%
\paragraph{Faster feedback loops}
\switchcolumn
\paragraph{更快的反馈}
\switchcolumn[0]*%%%%%%%
One of the primary problems with end-to-end (E2E) tests and development
is that running the entire suite takes a long time. Typically, this is
only done in continuous integration and deployment (CI/CD) pipelines.
Modern E2E testing frameworks have helped to solve this by adding
features like parallelization, which allows for CI/CD pipelines to often
run magnitudes faster than before. In addition, when developing locally,
the ability to selectively run a single test for the page you are
working on while also providing hot reloading of tests can help boost a
developer's workflow and productivity.
\switchcolumn
端到端测试和相应开发过程的主要问题之一是，运行整个套件需要很长的时间。通常情况下，这只在持续集成和部署（CI/CD）管道中进行。现代的端到端测试框架通过增加并行化等功能来帮助解决这个问题，这使得
CI/CD
管道的运行速度比以前快了几倍。此外，在本地开发时，能够有选择地为你正在工作的页面运行单个测试，同时还提供测试的热重载，大大提高了开发者的工作流程和生产力。
\switchcolumn[0]*%%%%%%%
\paragraph{First-class debugging experience}
\switchcolumn
\paragraph{第一优先级的调试体验}
\switchcolumn[0]*%%%%%%%
While developers have traditionally relied on scanning logs in a
terminal window to help determine what went wrong in a test, modern
end-to-end (E2E) test frameworks allow developers to leverage tools they
are already familiar with, e.g. browser developer tools.
\switchcolumn
传统上，开发者依靠扫描终端窗口中的日志来帮助确定测试中出现的问题，而现代端到端测试框架允许开发者利用他们已经熟悉的工具，例如浏览器开发工具。
\switchcolumn[0]*%%%%%%%
\paragraph{Visibility in headless mode}
\switchcolumn
\paragraph{无头模式下的可见性}
\switchcolumn[0]*%%%%%%%
When end-to-end (E2E) tests are run in continuous integration/deployment
pipelines, they are often run in headless browsers (i.e., no visible
browser is opened for the user to watch). A critical feature of modern
E2E testing frameworks is the ability to see snapshots and/or videos of
the application during testing, providing some insight into why errors
are happening. Historically, it was tedious to maintain these
integrations.
\switchcolumn
当端到端测试在 CI/CD
管道中运行时，它们通常在无头浏览器（即不带界面的浏览器）中运行。因此，当错误发生时，现代端到端测试框架的一个关键特性是能够在不同的测试阶段查看应用的快照、视频，从而深入了解错误的原因。而在很早以前，要手动维护这些集成是非常繁琐的。
\switchcolumn[0]*%%%%%%%
\subsubsection{Recommendation}
\switchcolumn
\subsubsection{推荐方案}
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  \href{https://www.cypress.io/}{Cypress}\\
  Overall, we believe Cypress provides the most complete E2E solution
  with features like an informative graphical interface, excellent
  debuggability, built-in assertions and stubs, flake-resistance,
  parallelization, and snapshots. As mentioned above, it also provides
  support for
  \href{https://docs.cypress.io/guides/component-testing/introduction}{Component
  Testing}. However, it only supports Chromium-based browsers and
  Firefox.
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  \href{https://www.cypress.io/}{Cypress}\\
  总的来说，我们认为 Cypress
  提供了最完整的端到端解决方案，其具有信息丰富的图形界面、出色的调试性、内置断言和存根、抗剥落性、并行化和快照等诸多特性。而且如上所述，它还提供对
  \href{https://docs.cypress.io/guides/component-testing/introduction}{组件测试}
  的支持。不过，它只支持测试基于 Chromium 的浏览器和 Firefox。
\end{itemize}
\switchcolumn[0]*%%%%%%%
\subsubsection{Other Options}
\switchcolumn
\subsubsection{其他选项}
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  \href{https://playwright.dev/}{Playwright} is also a great E2E testing
  solution with a wider range of browser support (mainly WebKit). See
  \href{https://playwright.dev/docs/why-playwright}{Why Playwright} for
  more details.
\item
  \href{https://nightwatchjs.org/}{Nightwatch} is an E2E testing
  solution based on
  \href{https://www.npmjs.com/package/selenium-webdriver}{Selenium
  WebDriver}. This gives it the widest browser support range.
\item
  \href{https://webdriver.io/}{WebdriverIO} is a test automation
  framework for web and mobile testing based on the WebDriver protocol.
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  \href{https://playwright.dev/}{Playwright}
  也是一个非常好的端到端测试解决方案，支持测试范围更广的浏览器品类（主要是
  WebKit 型的）。查看这篇文章
  \href{https://playwright.dev/docs/why-playwright}{《为什么选择
  Playwright》} 了解更多细节。
\item
  \href{https://nightwatchjs.org/}{Nightwatch} 是一个基于
  \href{https://www.npmjs.com/package/selenium-webdriver}{Selenium
  WebDriver} 的端到端测试解决方案。它的浏览器品类支持范围是最广的。
\item
  \href{https://webdriver.io/}{WebdriverIO} 是一个基于 WebDriver
  协议的网络和移动测试的自动化测试框架。
\end{itemize}
\switchcolumn[0]*%%%%%%%
\subsection{Recipes}
\switchcolumn
\subsection{用例指南}
\end{paracol}


\columnratio{0.55}
\begin{paracol}{2}
 
\switchcolumn[0]*%%%%%%%
\subsubsection{Adding Vitest to a Project}
\switchcolumn
\subsubsection{添加 Vitest 到项目中}
\switchcolumn[0]*%%%%%%%
In a Vite-based Vue project, run:
\switchcolumn
在一个基于 Vite 的 Vue 项目中，运行如下命令：
\switchcolumn[0]*%%%%%%%
\begin{codeShell}
npm install -D vitest happy-dom @testing-library/vue
\end{codeShell}  
\switchcolumn
\begin{codeShell}
npm install -D vitest happy-dom @testing-library/vue
\end{codeShell}  
\switchcolumn[0]*%%%%%%%
Next, update the Vite configuration to add the \texttt{test} option
block:
\switchcolumn
接着，更新你的 Vite 配置，添加上 \texttt{test} 选项：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// vite.config.js
import { defineConfig } from 'vite'
export default defineConfig({
  // ...
  test: {
    // 启用类似 jest 的全局测试 API
    globals: true,
    // 使用 happy-dom 模拟 DOM
    // 这需要你安装 happy-dom 作为对等依赖（peer dependency）
    environment: 'happy-dom'
  }
})
\end{codeJs}
\switchcolumn
\begin{codeJs}
// vite.config.js
import { defineConfig } from 'vite'
export default defineConfig({
  // ...
  test: {
    // 启用类似 jest 的全局测试 API
    globals: true,
    // 使用 happy-dom 模拟 DOM
    // 这需要你安装 happy-dom 作为对等依赖（peer dependency）
    environment: 'happy-dom'
  }
})
\end{codeJs}
\switchcolumn[0]*%%%%%%%
\begin{vueQuote}{TIP}
If you use TypeScript, add \texttt{vitest/globals} to the \texttt{types}
field in your \texttt{tsconfig.json}.
\end{vueQuote} 
\switchcolumn
\begin{vueQuote}{TIP}
如果你在使用 TypeScript，请将 \texttt{vitest/globals} 添加到
\texttt{tsconfig.json} 的 \texttt{types} 字段当中。
\end{vueQuote} 
\switchcolumn[0]*%%%%%%%
\begin{codeJson}
// tsconfig.json
{
  "compilerOptions": {
    "types": ["vitest/globals"]
  }
}
\end{codeJson}
\switchcolumn
\begin{codeJson}
// tsconfig.json
{
  "compilerOptions": {
    "types": ["vitest/globals"]
  }
}
\end{codeJson}
\switchcolumn[0]*%%%%%%%
Then, create a file ending in \texttt{*.test.js} in your project. You
can place all test files in a test directory in the project root or in
test directories next to your source files. Vitest will automatically
search for them using the naming convention.
\switchcolumn
接着在你的项目中创建名字以 \texttt{*.test.js}
结尾的文件。你可以把所有的测试文件放在项目根目录下的 \texttt{test}
目录中，或者放在源文件旁边的 \texttt{test} 目录中。Vitest
会使用命名规则自动搜索它们。
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// MyComponent.test.js
import { render } from '@testing-library/vue'
import MyComponent from './MyComponent.vue'
test('it should work', () => {
  const { getByText } = render(MyComponent, {
    props: {
      /* ... */
    }
  })
  // 断言输出
  getByText('...')
})
\end{codeJs}
\switchcolumn
\begin{codeJs}
// MyComponent.test.js
import { render } from '@testing-library/vue'
import MyComponent from './MyComponent.vue'
test('it should work', () => {
  const { getByText } = render(MyComponent, {
    props: {
      /* ... */
    }
  })
  // 断言输出
  getByText('...')
})
\end{codeJs}
\switchcolumn[0]*%%%%%%%
Finally, update \texttt{package.json} to add the test script and run it:
\switchcolumn
最后，在 \texttt{package.json} 之中添加测试命令，然后运行它：
\switchcolumn[0]*%%%%%%%
\begin{codeJson}
{
  // ...
  "scripts": {
    "test": "vitest"
  }
}
\end{codeJson}  
\switchcolumn
\begin{codeJson}
{
  // ...
  "scripts": {
    "test": "vitest"
  }
}
\end{codeJson}  
\switchcolumn[0]*%%%%%%%
\begin{codeShell}
npm test
\end{codeShell}  
\switchcolumn
\begin{codeShell}
npm test
\end{codeShell}  
\end{paracol}


\columnratio{0.55}
\begin{paracol}{2}
 
\switchcolumn[0]*%%%%%%%
\subsubsection{Testing Composables}
\switchcolumn
\subsubsection{测试组合式函数}
\switchcolumn[0]*%%%%%%%
\begin{quote}
This section assumes you have read the
\href{https://vuejs.org/guide/reusability/composables.html}{Composables}
section.
\end{quote}
\switchcolumn
\begin{quote}
这一小节假设你已经读过了\href{https://cn.vuejs.org/guide/reusability/composables.html}{组合式函数}这一章。
\end{quote}
\switchcolumn[0]*%%%%%%%
When it comes to testing composables, we can divide them into two
categories: composables that do not rely on a host component instance,
and composables that do.
\switchcolumn
当涉及到测试组合式函数时，我们可以根据是否依赖宿主组件实例把它们分为两类。
\switchcolumn[0]*%%%%%%%
A composable depends on a host component instance when it uses the
following APIs:
\switchcolumn
当一个组合式函数使用以下 API 时，它依赖于一个宿主组件实例：
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  Lifecycle hooks
\item
  Provide / Inject
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  生命周期钩子
\item
  供给/注入
\end{itemize}
\switchcolumn[0]*%%%%%%%
If a composable only uses Reactivity APIs, then it can be tested by
directly invoking it and asserting its returned state/methods:
\switchcolumn
如果一个组合式程序只使用响应式
API，那么它可以通过直接调用并断言其返回的状态或方法来进行测试。
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// counter.js
import { ref } from 'vue'
export function useCounter() {
  const count = ref(0)
  const increment = () => count.value++
  return {
    count,
    increment
  }
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
// counter.js
import { ref } from 'vue'
export function useCounter() {
  const count = ref(0)
  const increment = () => count.value++
  return {
    count,
    increment
  }
}
\end{codeJs}
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// counter.test.js
import { useCounter } from './counter.js'
test('useCounter', () => {
  const { count, increment } = useCounter()
  expect(count.value).toBe(0)
  increment()
  expect(count.value).toBe(1)
})
\end{codeJs}
\switchcolumn
\begin{codeJs}
// counter.test.js
import { useCounter } from './counter.js'
test('useCounter', () => {
  const { count, increment } = useCounter()
  expect(count.value).toBe(0)
  increment()
  expect(count.value).toBe(1)
})
\end{codeJs}
\switchcolumn[0]*%%%%%%%
A composable that relies on lifecycle hooks or Provide / Inject needs to
be wrapped in a host component to be tested. We can create a helper like
the following:
\switchcolumn
一个依赖生命周期钩子或供给/注入的组合式函数需要被包装在一个宿主组件中才可以测试。我们可以创建下面这样的帮手函数：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// test-utils.js
import { createApp } from 'vue'
export function withSetup(composable) {
  let result
  const app = createApp({
    setup() {
      result = composable()
      // 忽略模板警告
      return () => {}
    }
  })
  app.mount(document.createElement('div'))
  // 返回结果与应用实例
  // 用来测试供给和组件卸载
  return [result, app]
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
// test-utils.js
import { createApp } from 'vue'
export function withSetup(composable) {
  let result
  const app = createApp({
    setup() {
      result = composable()
      // 忽略模板警告
      return () => {}
    }
  })
  app.mount(document.createElement('div'))
  // 返回结果与应用实例
  // 用来测试供给和组件卸载
  return [result, app]
}
\end{codeJs}
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
import { withSetup } from './test-utils'
import { useFoo } from './foo'
test('useFoo', () => {
  const [result, app] = withSetup(() => useFoo(123))
  // 为注入的测试模拟一方供给
  app.provide(...)
  // 执行断言
  expect(result.foo.value).toBe(1)
  // 如果需要的话可以这样触发
  app.unmount()
})
\end{codeJs}
\switchcolumn
\begin{codeJs}
import { withSetup } from './test-utils'
import { useFoo } from './foo'
test('useFoo', () => {
  const [result, app] = withSetup(() => useFoo(123))
  // 为注入的测试模拟一方供给
  app.provide(...)
  // 执行断言
  expect(result.foo.value).toBe(1)
  // 如果需要的话可以这样触发
  app.unmount()
})
\end{codeJs}
\switchcolumn[0]*%%%%%%%
For more complex composables, it could also be easier to test it by
writing tests against the wrapper component using
\href{https://vuejs.org/guide/scaling-up/testing.html\#component-testing}{Component
Testing} techniques.
\switchcolumn
对于更复杂的组合式函数，通过使用\href{https://cn.vuejs.org/guide/scaling-up/testing.html\#component-testing}{组件测试}编写针对这个包装器组件的测试，这会容易很多。
\end{paracol}
