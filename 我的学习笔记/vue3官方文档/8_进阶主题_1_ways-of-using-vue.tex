
\columnratio{0.55}
\begin{paracol}{2} 
 
\switchcolumn[0]*%%%%%%%
\section{Ways of Using Vue}
\switchcolumn
\section{使用 Vue 的多种方式}
\switchcolumn[0]*%%%%%%%
We believe there is no "one size fits all" story for the web. This is
why Vue is designed to be flexible and incrementally adoptable.
Depending on your use case, Vue can be used in different ways to strike
the optimal balance between stack complexity, developer experience and
end performance.
\switchcolumn
我们相信在 Web 的世界里没有一种方案可以解决所有问题。正因如此，Vue
被设计成一个灵活的、可以渐进式集成的框架。根据使用场景的不同需要，相应地有多种不同的方式来使用
Vue，以此在技术栈复杂度、开发体验和性能表现间取得最佳平衡。
\switchcolumn[0]*%%%%%%%
\subsection{Standalone Script}
\switchcolumn
\subsection{独立脚本}
\switchcolumn[0]*%%%%%%%
Vue can be used as a standalone script file - no build step required! If
you have a backend framework already rendering most of the HTML, or your
frontend logic isn't complex enough to justify a build step, this is the
easiest way to integrate Vue into your stack. You can think of Vue as a
more declarative replacement of jQuery in such cases.
\switchcolumn
Vue 可以以一个单独 JS
文件的形式使用，无需构建步骤！如果你的后端框架已经渲染了大部分的
HTML，或者你的前端逻辑并不复杂，不需要构建步骤，这是最简单的使用 Vue
的方式。在这些场景中你可以将 Vue 看作一个更加声明式的 jQuery 替代品。
\switchcolumn[0]*%%%%%%%
Vue also provides an alternative distribution called
\href{https://github.com/vuejs/petite-vue}{petite-vue} that is
specifically optimized for progressively enhancing existing HTML. It has
a smaller feature set, but is extremely lightweight and uses an
implementation that is more efficient in no-build-step scenarios.
\switchcolumn
Vue 也提供了另一个更适用于此类无构建步骤场景的版本
\href{https://github.com/vuejs/petite-vue}{petite-vue}。它为渐进式增强已有的
HTML 作了特别的优化，功能更加精简，十分轻量。
\switchcolumn[0]*%%%%%%%
\subsection{Embedded Web Components}
\switchcolumn
\subsection{作为 Web Component 嵌入}
\switchcolumn[0]*%%%%%%%
You can use Vue to
\href{https://vuejs.org/guide/extras/web-components.html}{build standard
Web Components} that can be embedded in any HTML page, regardless of how
they are rendered. This option allows you to leverage Vue in a
completely consumer-agnostic fashion: the resulting web components can
be embedded in legacy applications, static HTML, or even applications
built with other frameworks.
\switchcolumn
你可以用 Vue
来\href{https://cn.vuejs.org/guide/extras/web-components.html}{构建标准的
Web Component}，这些 Web Component 可以嵌入到任何 HTML
页面中，无论它们是如何被渲染的。这个方式让你能够在不需要顾虑最终使用场景的情况下使用
Vue：因为生成的 Web Component 可以嵌入到旧应用、静态
HTML，甚至用其他框架构建的应用中。
\switchcolumn[0]*%%%%%%%
\subsection{Single-Page Application (SPA)}
\switchcolumn
\subsection{单页面应用 (SPA)}
\switchcolumn[0]*%%%%%%%
Some applications require rich interactivity, deep session depth, and
non-trivial stateful logic on the frontend. The best way to build such
applications is to use an architecture where Vue not only controls the
entire page, but also handles data updates and navigation without having
to reload the page. This type of application is typically referred to as
a Single-Page Application (SPA).
\switchcolumn
一些应用在前端需要具有丰富的交互性、较深的会话和复杂的状态逻辑。构建这类应用的最佳方法是使用这样一种架构：Vue
不仅控制整个页面，还负责处理抓取新数据，并在无需重新加载的前提下处理页面切换。这种类型的应用通常称为单页应用
(Single-Page application，缩写为 SPA)。
\switchcolumn[0]*%%%%%%%
Vue provides core libraries and
\href{https://vuejs.org/guide/scaling-up/tooling.html}{comprehensive
tooling support} with amazing developer experience for building modern
SPAs, including:
\switchcolumn
Vue
提供了核心功能库和\href{https://cn.vuejs.org/guide/scaling-up/tooling.html}{全面的工具链支持}，为现代
SPA 提供了极佳的开发体验，覆盖以下方面：
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  Client-side router
\item
  Blazing fast build tool chain
\item
  IDE support
\item
  Browser devtools
\item
  TypeScript integrations
\item
  Testing utilities
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  客户端路由
\item
  极其快速的构建工具
\item
  IDE 支持
\item
  浏览器开发工具
\item
  TypeScript 支持
\item
  测试工具
\end{itemize}
\switchcolumn[0]*%%%%%%%
SPAs typically require the backend to expose API endpoints - but you can
also pair Vue with solutions like
\href{https://inertiajs.com/}{Inertia.js} to get the SPA benefits while
retaining a server-centric development model.
\switchcolumn
SPA 一般要求后端提供 API 数据接口，但你也可以将 Vue 和如
\href{https://inertiajs.com/}{Inertia.js}
之类的解决方案搭配使用，在保留侧重服务端的开发模型的同时获得 SPA
的益处。
\end{paracol}



\columnratio{0.55}
\begin{paracol}{2} 
 
\switchcolumn[0]*%%%%%%%
\subsection{Fullstack / SSR}
\switchcolumn
\subsection{全栈 / SSR}
\switchcolumn[0]*%%%%%%%
Pure client-side SPAs are problematic when the app is sensitive to SEO
and time-to-content. This is because the browser will receive a largely
empty HTML page, and has to wait until the JavaScript is loaded before
rendering anything.
\switchcolumn
纯客户端的 SPA 在首屏加载和 SEO
方面有显著的问题，因为浏览器会收到一个巨大的 HTML 空页面，只有等到
JavaScript 加载完毕才会渲染出内容。
\switchcolumn[0]*%%%%%%%
Vue provides first-class APIs to "render" a Vue app into HTML strings on
the server. This allows the server to send back already-rendered HTML,
allowing end users to see the content immediately while the JavaScript
is being downloaded. Vue will then "hydrate" the application on the
client side to make it interactive. This is called
\href{https://vuejs.org/guide/scaling-up/ssr.html}{Server-Side Rendering
(SSR)} and it greatly improves Core Web Vital metrics such as
\href{https://web.dev/lcp/}{Largest Contentful Paint (LCP)}.
\switchcolumn
Vue 提供了一系列 API，支持将一个 Vue 应用在服务端渲染成 HTML
字符串。这能让服务器直接返回渲染好的 HTML，让用户在 JavaScript
下载完毕前就看到页面内容。Vue 之后会在客户端对应用进行``激活
(hydrate)''使其重获可交互性。这被称为\href{https://cn.vuejs.org/guide/scaling-up/ssr.html}{服务端渲染
(SSR)}，它能够极大地改善应用在 Web
核心指标上的性能表现，如\href{https://web.dev/lcp/}{最大内容绘制
(LCP)}。
\switchcolumn[0]*%%%%%%%
There are higher-level Vue-based frameworks built on top of this
paradigm, such as \href{https://nuxt.com/}{Nuxt}, which allow you to
develop a fullstack application using Vue and JavaScript.
\switchcolumn
Vue 生态中有一些针对此类场景的、基于 Vue 的上层框架，比如
\href{https://nuxt.com/}{NuxtJS}，能让你用 Vue 和 JavaScript
开发一个全栈应用。
\switchcolumn[0]*%%%%%%%
\subsection{JAMStack / SSG}
\switchcolumn
\subsection{JAMStack / SSG}
\switchcolumn[0]*%%%%%%%
Server-side rendering can be done ahead of time if the required data is
static. This means we can pre-render an entire application into HTML and
serve them as static files. This improves site performance and makes
deployment a lot simpler since we no longer need to dynamically render
pages on each request. Vue can still hydrate such applications to
provide rich interactivity on the client. This technique is commonly
referred to as Static-Site Generation (SSG), also known as
\href{https://jamstack.org/what-is-jamstack/}{JAMStack}.
\switchcolumn
如果所需的数据是静态的，那么服务端渲染可以提前完成。这意味着我们可以将整个应用预渲染为
HTML，并将其作为静态文件部署。这增强了站点的性能表现，也使部署变得更容易，因为我们无需根据请求动态地渲染页面。Vue
仍可通过激活在客户端提供交互。这一技术通常被称为静态站点生成
(SSG)，也被称为
\href{https://jamstack.org/what-is-jamstack/}{JAMStack}。
\switchcolumn[0]*%%%%%%%
There are two flavors of SSG: single-page and multi-page. Both flavors
pre-render the site into static HTML, the difference is that:
\switchcolumn
SSG 有两种风格：单页和多页。这两种风格都能将站点预渲染为静态
HTML，区别在于：
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  After the initial page load, a single-page SSG "hydrates" the page
  into an SPA. This requires more upfront JS payload and hydration cost,
  but subsequent navigations will be faster, since it only needs to
  partially update the page content instead of reloading the entire
  page.
\item
  A multi-page SSG loads a new page on every navigation. The upside is
  that it can ship minimal JS - or no JS at all if the page requires no
  interaction! Some multi-page SSG frameworks such as
  \href{https://astro.build/}{Astro} also support "partial hydration" -
  which allows you to use Vue components to create interactive "islands"
  inside static HTML.
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  单页 SSG 在初始页面加载后将其``激活''为 SPA。这需要更多的前期 JS
  加载和激活成本，但后续的导航将更快，因为它只需要部分地更新页面内容，而无需重新加载整个页面。
\item
  多页 SSG 每次导航都会加载一个新页面。好处是它可以仅需最少的
  JS------或者如果页面无需交互则根本不需要 JS！一些多页面 SSG 框架，如
  \href{https://astro.build/}{Astro}
  也支持``部分激活''------它允许你通过 Vue 组件在静态 HTML
  中创建交互式的``孤岛''。
\end{itemize}
\switchcolumn[0]*%%%%%%%
Single-page SSGs are better suited if you expect non-trivial
interactivity, deep session lengths, or persisted elements / state
across navigations. Otherwise, multi-page SSG would be the better
choice.
\switchcolumn
单页 SSG
更适合于重交互、深会话的场景，或需要在导航之间持久化元素或状态。否则，多页
SSG 将是更好的选择。
\switchcolumn[0]*%%%%%%%
The Vue team also maintains a static-site generator called
\href{https://vitepress.dev/}{VitePress}, which powers this website you
are reading right now! VitePress supports both flavors of SSG.
\href{https://nuxt.com/}{Nuxt} also supports SSG. You can even mix SSR
and SSG for different routes in the same Nuxt app.
\switchcolumn
Vue 团队也维护了一个名为 \href{https://vitepress.dev/}{VitePress}
的静态站点生成器，你正在阅读的文档就是基于它构建的！VitePress
支持两种形式的 SSG。另外，\href{https://nuxt.com/}{NuxtJS} 也支持
SSG。你甚至可以在同一个 Nuxt 应用中通过不同的路由提供 SSR 和 SSG。
\switchcolumn[0]*%%%%%%%
\subsection{Beyond the Web}
\switchcolumn
\subsection{Web 之外...}
\switchcolumn[0]*%%%%%%%
Although Vue is primarily designed for building web applications, it is
by no means limited to just the browser. You can:
\switchcolumn
尽管 Vue 主要是为构建 Web
应用而设计的，但它绝不仅仅局限于浏览器。你还可以：
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  Build desktop apps with \href{https://www.electronjs.org/}{Electron}
  or \href{https://tauri.studio/en/}{Tauri}
\item
  Build mobile apps with
  \href{https://ionicframework.com/docs/vue/overview}{Ionic Vue}
\item
  Build desktop and mobile apps from the same codebase with
  \href{https://quasar.dev/}{Quasar}
\item
  Use Vue's \href{https://vuejs.org/api/custom-renderer.html}{Custom
  Renderer API} to build custom renderers targeting
  \href{https://troisjs.github.io/}{WebGL} or even
  \href{https://github.com/vue-terminal/vue-termui}{the terminal}!
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  配合 \href{https://www.electronjs.org/}{Electron} 或
  \href{https://tauri.studio/en/}{Tauri} 构建桌面应用
\item
  配合 \href{https://ionicframework.com/docs/vue/overview}{Ionic Vue}
  构建移动端应用
\item
  使用 \href{https://quasar.dev/}{Quasar}
  用同一套代码同时开发桌面端和移动端应用
\item
  使用 Vue
  的\href{https://cn.vuejs.org/api/custom-renderer.html}{自定义渲染 API}
  来构建不同目标的渲染器，比如 \href{https://troisjs.github.io/}{WebGL}
  甚至是\href{https://github.com/vue-terminal/vue-termui}{终端命令行}！
\end{itemize}
\end{paracol}
 