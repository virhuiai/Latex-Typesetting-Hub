\columnratio{0.55}
\begin{paracol}{2} 
\switchcolumn[0]*%%%%%%%
\section{Performance}
\switchcolumn
\section{性能优化}
\switchcolumn[0]*%%%%%%%
\subsection{Overview}
\switchcolumn
\subsection{概述}
\switchcolumn[0]*%%%%%%%
Vue is designed to be performant for most common use cases without much
need for manual optimizations. However, there are always challenging
scenarios where extra fine-tuning is needed. In this section, we will
discuss what you should pay attention to when it comes to performance in
a Vue application.
\switchcolumn
Vue
在大多数常见场景下性能都是很优秀的，通常不需要手动优化。然而，总会有一些具有挑战性的场景需要进行针对性的微调。在本节中，我们将讨论用
Vue 开发的应用在性能方面该注意些什么。
\switchcolumn[0]*%%%%%%%
First, let's discuss the two major aspects of web performance:
\switchcolumn
首先，让我们区分一下 web 应用性能的两个主要方面： 
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  \textbf{Page Load Performance}: how fast the application shows content
  and becomes interactive on the initial visit. This is usually measured
  using web vital metrics like \href{https://web.dev/lcp/}{Largest
  Contentful Paint (LCP)} and \href{https://web.dev/fid/}{First Input
  Delay (FID)}.
\item
  \textbf{Update Performance}: how fast the application updates in
  response to user input. For example, how fast a list updates when the
  user types in a search box, or how fast the page switches when the
  user clicks a navigation link in a Single-Page Application (SPA).
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  \textbf{页面加载性能}：首次访问时，应用展示出内容与达到可交互状态的速度。这通常会用
  Google 所定义的一系列
  \href{https://web.dev/vitals/\#core-web-vitals}{Web 指标} (Web Vitals)
  来进行衡量，如\href{https://web.dev/lcp/}{最大内容绘制} (Largest
  Contentful Paint，缩写为 LCP)
  和\href{https://web.dev/fid/}{首次输入延迟} (First Input Delay，缩写为
  FID)。
\item
  \textbf{更新性能}：应用响应用户输入更新的速度。比如当用户在搜索框中输入时结果列表的更新速度，或者用户在一个单页面应用
  (SPA) 中点击链接跳转页面时的切换速度。
\end{itemize}
\switchcolumn[0]*%%%%%%%
While it would be ideal to maximize both, different frontend
architectures tend to affect how easy it is to attain desired
performance in these aspects. In addition, the type of application you
are building greatly influences what you should prioritize in terms of
performance. Therefore, the first step of ensuring optimal performance
is picking the right architecture for the type of application you are
building:
\switchcolumn
虽然最理想的情况是将两者都最大化，但是不同的前端架构往往会影响到在这些方面是否能达到更理想的性能。此外，你所构建的应用的类型极大地影响了你在性能方面应该优先考虑的问题。因此，优化性能的第一步是为你的应用类型确定合适的架构： 
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  Consult
  \href{https://vuejs.org/guide/extras/ways-of-using-vue.html}{Ways of
  Using Vue} to see how you can leverage Vue in different ways.
\item
  Jason Miller discusses the types of web applications and their
  respective ideal implementation / delivery in
  \href{https://jasonformat.com/application-holotypes/}{Application
  Holotypes}.
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  查看\href{https://cn.vuejs.org/guide/extras/ways-of-using-vue.html}{使用
  Vue 的多种方式}这一章看看如何用不同的方式围绕 Vue 组织架构。
\item
  Jason Miller 在
  \href{https://jasonformat.com/application-holotypes/}{Application
  Holotypes} 一文中讨论了 Web
  应用的类型以及它们各自的理想实现/交付方式。
\end{itemize}
\switchcolumn[0]*%%%%%%%
\subsection{Profiling Options}
\switchcolumn
\subsection{分析选项}
\switchcolumn[0]*%%%%%%%
To improve performance, we need to first know how to measure it. There
are a number of great tools that can help in this regard:
\switchcolumn
为了提高性能，我们首先需要知道如何衡量它。在这方面，有一些很棒的工具可以提供帮助：
\switchcolumn[0]*%%%%%%%
For profiling load performance of production deployments:
\switchcolumn
用于生产部署的负载性能分析：
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  \href{https://pagespeed.web.dev/}{PageSpeed Insights}
\item
  \href{https://www.webpagetest.org/}{WebPageTest}
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  \href{https://pagespeed.web.dev/}{PageSpeed Insights}
\item
  \href{https://www.webpagetest.org/}{WebPageTest}
\end{itemize}
\switchcolumn[0]*%%%%%%%
For profiling performance during local development:
\switchcolumn
用于本地开发期间的性能分析：
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  Chrome DevTools Performance Panel
  \begin{itemize}
  \item
    \href{https://vuejs.org/api/application.html\#app-config-performance}{\texttt{app.config.performance}}
    enables Vue-specific performance markers in Chrome DevTools'
    performance timeline.
  \end{itemize}
\item
  \href{https://vuejs.org/guide/scaling-up/tooling.html\#browser-devtools}{Vue
  DevTools Extension} also provides a performance profiling feature.
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  Chrome 开发者工具``性能''面板
  \begin{itemize}
  \item
    \href{https://cn.vuejs.org/api/application.html\#app-config-performance}{\texttt{app.config.performance}}
    将会开启 Vue 特有的性能标记，标记在 Chrome
    开发者工具的性能时间线上。
  \end{itemize}
\item
  \href{https://cn.vuejs.org/guide/scaling-up/tooling.html\#browser-devtools}{Vue
  开发者扩展}也提供了性能分析的功能。
\end{itemize}
\switchcolumn[0]*%%%%%%%
\subsection{Page Load Optimizations}
\switchcolumn
\subsection{页面加载优化}
\switchcolumn[0]*%%%%%%%
There are many framework-agnostic aspects for optimizing page load
performance - check out \href{https://web.dev/fast/}{this web.dev guide}
for a comprehensive round up. Here, we will primarily focus on
techniques that are specific to Vue.
\switchcolumn
页面加载优化有许多跟框架无关的方面 - 这份
\href{https://web.dev/fast/}{web.dev
指南}提供了一个全面的总结。这里，我们将主要关注和 Vue 相关的技巧。
\switchcolumn[0]*%%%%%%%
\subsubsection{Choosing the Right Architecture}
\switchcolumn
\subsubsection{选用正确的架构}
\switchcolumn[0]*%%%%%%%
If your use case is sensitive to page load performance, avoid shipping
it as a pure client-side SPA. You want your server to be directly
sending HTML containing the content the users want to see. Pure
client-side rendering suffers from slow time-to-content. This can be
mitigated with
\href{https://vuejs.org/guide/extras/ways-of-using-vue.html\#fullstack-ssr}{Server-Side
Rendering (SSR)} or
\href{https://vuejs.org/guide/extras/ways-of-using-vue.html\#jamstack-ssg}{Static
Site Generation (SSG)}. Check out the
\href{https://vuejs.org/guide/scaling-up/ssr.html}{SSR Guide} to learn
about performing SSR with Vue. If your app doesn't have rich
interactivity requirements, you can also use a traditional backend
server to render the HTML and enhance it with Vue on the client.
\switchcolumn
如果你的用例对页面加载性能很敏感，请避免将其部署为纯客户端的
SPA，而是让服务器直接发送包含用户想要查看的内容的 HTML
代码。纯客户端渲染存在首屏加载缓慢的问题，这可以通过\href{https://cn.vuejs.org/guide/extras/ways-of-using-vue.html\#fullstack-ssr}{服务器端渲染
(SSR)}
或\href{https://cn.vuejs.org/guide/extras/ways-of-using-vue.html\#jamstack-ssg}{静态站点生成
(SSG)} 来缓解。查看
\href{https://cn.vuejs.org/guide/scaling-up/ssr.html}{SSR
指南}以了解如何使用 Vue 实现
SSR。如果应用对交互性要求不高，你还可以使用传统的后端服务器来渲染
HTML，并在客户端使用 Vue 对其进行增强。
\switchcolumn[0]*%%%%%%%
If your main application has to be an SPA, but has marketing pages
(landing, about, blog), ship them separately! Your marketing pages
should ideally be deployed as static HTML with minimal JS, by using SSG.
\switchcolumn
如果你的主应用必须是 SPA，但还有其他的营销相关页面
(落地页、关于页、博客等)，请单独部署这些页面！理想情况下，营销页面应该是包含尽可能少
JS 的静态 HTML，并用 SSG 方式部署。
\end{paracol}



\columnratio{0.55}
\begin{paracol}{2} 
\switchcolumn[0]*%%%%%%%
\subsubsection{Bundle Size and Tree-shaking}
\switchcolumn
\subsubsection{包体积与 Tree-shaking 优化}
\switchcolumn[0]*%%%%%%%
One of the most effective ways to improve page load performance is
shipping smaller JavaScript bundles. Here are a few ways to reduce
bundle size when using Vue:
\switchcolumn
一个最有效的提升页面加载速度的方法就是压缩 JavaScript
打包产物的体积。当使用 Vue 时有下面一些办法来减小打包产物体积：
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
    Use a build step if possible.
    \begin{itemize}
    \item
    Many of Vue's APIs are
    \href{https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking}{"tree-shakable"}
    if bundled via a modern build tool. For example, if you don't use
    the built-in \texttt{\textless{}Transition\textgreater{}} component,
    it won't be included in the final production bundle. Tree-shaking
    can also remove other unused modules in your source code.
    \item
    When using a build step, templates are pre-compiled so we don't need
    to ship the Vue compiler to the browser. This saves \textbf{14kb}
    min+gzipped JavaScript and avoids the runtime compilation cost.
    \end{itemize}
\item
    Be cautious of size when introducing new dependencies! In real-world
    applications, bloated bundles are most often a result of introducing
    heavy dependencies without realizing it.
    \begin{itemize}
    \item
    If using a build step, prefer dependencies that offer ES module
    formats and are tree-shaking friendly. For example, prefer
    \texttt{lodash-es} over \texttt{lodash}.
    \item
    Check a dependency's size and evaluate whether it is worth the
    functionality it provides. Note if the dependency is tree-shaking
    friendly, the actual size increase will depend on the APIs you
    actually import from it. Tools like
    \href{https://bundlejs.com/}{bundlejs.com} can be used for quick
    checks, but measuring with your actual build setup will always be
    the most accurate.
    \end{itemize}
\item
    If you are using Vue primarily for progressive enhancement and prefer
    to avoid a build step, consider using
    \href{https://github.com/vuejs/petite-vue}{petite-vue} (only
    \textbf{6kb}) instead.
\end{itemize}
\switchcolumn
\begin{itemize}
\item
    尽可能地采用构建步骤
    \begin{itemize}
    \item
    如果使用的是相对现代的打包工具，许多 Vue 的 API 都是可以被
    \href{https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking}{tree-shake}
    的。举例来说，如果你根本没有使用到内置的
    \texttt{\textless{}Transition\textgreater{}}
    组件，它将不会被打包进入最终的产物里。Tree-shaking
    也可以移除你源代码中其他未使用到的模块。
    \item
    当使用了构建步骤时，模板会被预编译，因此我们无须在浏览器中载入 Vue
    编译器。这在同样最小化加上 gzip 优化下会相对缩小 \textbf{14kb}
    并避免运行时的编译开销。
    \end{itemize}
\item
    在引入新的依赖项时要小心包体积膨胀！在现实的应用中，包体积膨胀通常因为无意识地引入了过重的依赖导致的。
    \begin{itemize}
    \item
    如果使用了构建步骤，应当尽量选择提供 ES 模块格式的依赖，它们对
    tree-shaking 更友好。举例来说，选择 \texttt{lodash-es} 比
    \texttt{lodash} 更好。
    \item
    查看依赖的体积，并评估与其所提供的功能之间的性价比。如果依赖对
    tree-shaking 友好，实际增加的体积大小将取决于你从它之中导入的
    API。像 \href{https://bundlejs.com/}{bundlejs.com}
    这样的工具可以用来做快速的检查，但是根据实际的构建设置来评估总是最准确的。
    \end{itemize}
\item
    如果你只在渐进式增强的场景下使用
    Vue，并想要避免使用构建步骤，请考虑使用
    \href{https://github.com/vuejs/petite-vue}{petite-vue} (只有
    \textbf{6kb}) 来代替。
\end{itemize}
\end{paracol}



\columnratio{0.55}
\begin{paracol}{2} 
 
\switchcolumn[0]*%%%%%%%
\subsubsection{Code Splitting}
\switchcolumn
\subsubsection{代码分割}
\switchcolumn[0]*%%%%%%%
Code splitting is where a build tool splits the application bundle into
multiple smaller chunks, which can then be loaded on demand or in
parallel. With proper code splitting, features required at page load can
be downloaded immediately, with additional chunks being lazy loaded only
when needed, thus improving performance.
\switchcolumn
代码分割是指构建工具将构建后的 JavaScript
包拆分为多个较小的，可以按需或并行加载的文件。通过适当的代码分割，页面加载时需要的功能可以立即下载，而额外的块只在需要时才加载，从而提高性能。
\switchcolumn[0]*%%%%%%%
Bundlers like Rollup (which Vite is based upon) or webpack can
automatically create split chunks by detecting the ESM dynamic import
syntax:
\switchcolumn
像 Rollup (Vite 就是基于它之上开发的) 或者 webpack
这样的打包工具可以通过分析 ESM 动态导入的语法来自动进行代码分割：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// lazy.js 及其依赖会被拆分到一个单独的文件中
// 并只在 `loadLazy()` 调用时才加载
function loadLazy() {
  return import('./lazy.js')
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
// lazy.js 及其依赖会被拆分到一个单独的文件中
// 并只在 `loadLazy()` 调用时才加载
function loadLazy() {
  return import('./lazy.js')
}
\end{codeJs}
\switchcolumn[0]*%%%%%%%
Lazy loading is best used on features that are not immediately needed
after initial page load. In Vue applications, this can be used in
combination with Vue's
\href{https://vuejs.org/guide/components/async.html}{Async Component}
feature to create split chunks for component trees:
\switchcolumn
懒加载对于页面初次加载时的优化帮助极大，它帮助应用暂时略过了那些不是立即需要的功能。在
Vue 应用中，这可以与 Vue
的\href{https://cn.vuejs.org/guide/components/async.html}{异步组件}搭配使用，为组件树创建分离的代码块：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
import { defineAsyncComponent } from 'vue'
// 会为 Foo.vue 及其依赖创建单独的一个块
// 它只会按需加载
//（即该异步组件在页面中被渲染时）
const Foo = defineAsyncComponent(() => import('./Foo.vue'))
\end{codeJs}
\switchcolumn
\begin{codeJs}
import { defineAsyncComponent } from 'vue'
// 会为 Foo.vue 及其依赖创建单独的一个块
// 它只会按需加载
//（即该异步组件在页面中被渲染时）
const Foo = defineAsyncComponent(() => import('./Foo.vue'))
\end{codeJs}
\switchcolumn[0]*%%%%%%%
For applications using Vue Router, it is strongly recommended to use
lazy loading for route components. Vue Router has explicit support for
lazy loading, separate from \texttt{defineAsyncComponent}. See
\href{https://router.vuejs.org/guide/advanced/lazy-loading.html}{Lazy
Loading Routes} for more details.
\switchcolumn
对于使用了 Vue Router 的应用，强烈建议使用异步组件作为路由组件。Vue
Router 已经显性地支持了独立于 \texttt{defineAsyncComponent}
的懒加载。查看\href{https://router.vuejs.org/zh/guide/advanced/lazy-loading.html}{懒加载路由}了解更多细节。
\switchcolumn[0]*%%%%%%%
\subsection{Update Optimizations}
\switchcolumn
\subsection{更新优化}
\switchcolumn[0]*%%%%%%%
\subsubsection{Props Stability}
\switchcolumn
\subsubsection{Props 稳定性}
\switchcolumn[0]*%%%%%%%
In Vue, a child component only updates when at least one of its received
props has changed. Consider the following example:
\switchcolumn
在 Vue 之中，一个子组件只会在其至少一个 props
改变时才会更新。思考以下示例：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<ListItem
  v-for="item in list"
  :id="item.id"
  :active-id="activeId" />
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<ListItem
  v-for="item in list"
  :id="item.id"
  :active-id="activeId" />
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
Inside the \texttt{\textless{}ListItem\textgreater{}} component, it uses
its \texttt{id} and \texttt{activeId} props to determine whether it is
the currently active item. While this works, the problem is that
whenever \texttt{activeId} changes, \textbf{every}
\texttt{\textless{}ListItem\textgreater{}} in the list has to update!
\switchcolumn
在 \texttt{\textless{}ListItem\textgreater{}} 组件中，它使用了
\texttt{id} 和 \texttt{activeId} 两个 props
来确定它是否是当前活跃的那一项。虽然这是可行的，但问题是每当
\texttt{activeId} 更新时，列表中的\textbf{每一个}
\texttt{\textless{}ListItem\textgreater{}} 都会跟着更新！
\switchcolumn[0]*%%%%%%%
Ideally, only the items whose active status changed should update. We
can achieve that by moving the active status computation into the
parent, and make \texttt{\textless{}ListItem\textgreater{}} directly
accept an \texttt{active} prop instead:
\switchcolumn
理想情况下，只有活跃状态发生改变的项才应该更新。我们可以将活跃状态比对的逻辑移入父组件来实现这一点，然后让
\texttt{\textless{}ListItem\textgreater{}} 改为接收一个 \texttt{active}
prop：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<ListItem
  v-for="item in list"
  :id="item.id"
  :active="item.id === activeId" />
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<ListItem
  v-for="item in list"
  :id="item.id"
  :active="item.id === activeId" />
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
Now, for most components the \texttt{active} prop will remain the same
when \texttt{activeId} changes, so they no longer need to update. In
general, the idea is keeping the props passed to child components as
stable as possible.
\switchcolumn
现在，对于大多数的组件来说，\texttt{activeId} 改变时，它们的
\texttt{active} prop
都会保持不变，因此它们无需再更新。总结一下，这个技巧的核心思想就是让传给子组件的
props 尽量保持稳定。
\end{paracol}

\columnratio{0.55}
\begin{paracol}{2} 
 
\switchcolumn[0]*%%%%%%%
\subsubsection{v-once}
\switchcolumn
\subsubsection{v-once}
\switchcolumn[0]*%%%%%%%
\texttt{v-once} is a built-in directive that can be used to render
content that relies on runtime data but never needs to update. The
entire sub-tree it is used on will be skipped for all future updates.
Consult its
\href{https://vuejs.org/api/built-in-directives.html\#v-once}{API
reference} for more details.
\switchcolumn
\texttt{v-once}
是一个内置的指令，可以用来渲染依赖运行时数据但无需再更新的内容。它的整个子树都会在未来的更新中被跳过。查看它的
\href{https://cn.vuejs.org/api/built-in-directives.html\#v-once}{API
参考手册}可以了解更多细节。
\switchcolumn[0]*%%%%%%%
\subsubsection{v-memo}
\switchcolumn
\subsubsection{v-memo}
\switchcolumn[0]*%%%%%%%
\texttt{v-memo} is a built-in directive that can be used to
conditionally skip the update of large sub-trees or \texttt{v-for}
lists. Consult its
\href{https://vuejs.org/api/built-in-directives.html\#v-memo}{API
reference} for more details.
\switchcolumn
\texttt{v-memo} 是一个内置指令，可以用来有条件地跳过某些大型子树或者
\texttt{v-for} 列表的更新。查看它的
\href{https://cn.vuejs.org/api/built-in-directives.html\#v-memo}{API
参考手册}可以了解更多细节。
\switchcolumn[0]*%%%%%%%
\subsection{General Optimizations}
\switchcolumn
\subsection{通用优化}
\switchcolumn[0]*%%%%%%%
\begin{quote}
The following tips affect both page load and update performance.
\end{quote}
\switchcolumn
\begin{quote}
以下技巧能同时改善页面加载和更新性能。
\end{quote}
\switchcolumn[0]*%%%%%%%
\subsubsection{Virtualize Large Lists}
\switchcolumn
\subsubsection{大型虚拟列表}
\switchcolumn[0]*%%%%%%%
One of the most common performance issues in all frontend applications
is rendering large lists. No matter how performant a framework is,
rendering a list with thousands of items \textbf{will} be slow due to
the sheer number of DOM nodes that the browser needs to handle.
\switchcolumn
所有的前端应用中最常见的性能问题就是渲染大型列表。无论一个框架性能有多好，渲染成千上万个列表项\textbf{都会}变得很慢，因为浏览器需要处理大量的
DOM 节点。
\switchcolumn[0]*%%%%%%%
However, we don't necessarily have to render all these nodes upfront. In
most cases, the user's screen size can display only a small subset of
our large list. We can greatly improve the performance with \textbf{list
virtualization}, the technique of only rendering the items that are
currently in or close to the viewport in a large list.
\switchcolumn
但是，我们并不需要立刻渲染出全部的列表。在大多数场景中，用户的屏幕尺寸只会展示这个巨大列表中的一小部分。我们可以通过\textbf{列表虚拟化}来提升性能，这项技术使我们只需要渲染用户视口中能看到的部分。
\switchcolumn[0]*%%%%%%%
Implementing list virtualization isn't easy, luckily there are existing
community libraries that you can directly use:
\switchcolumn
要实现列表虚拟化并不简单，幸运的是，你可以直接使用现有的社区库：
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  \href{https://github.com/Akryum/vue-virtual-scroller}{vue-virtual-scroller}
\item
  \href{https://github.com/rocwang/vue-virtual-scroll-grid}{vue-virtual-scroll-grid}
\item
  \href{https://github.com/07akioni/vueuc}{vueuc/VVirtualList}
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  \href{https://github.com/Akryum/vue-virtual-scroller}{vue-virtual-scroller}
\item
  \href{https://github.com/rocwang/vue-virtual-scroll-grid}{vue-virtual-scroll-grid}
\item
  \href{https://github.com/07akioni/vueuc}{vueuc/VVirtualList}
\end{itemize}
\end{paracol}


\columnratio{0.55}
\begin{paracol}{2} 
 
\switchcolumn[0]*%%%%%%%
\subsubsection{Reduce Reactivity Overhead for Large Immutable Structures}
\switchcolumn
\subsubsection{减少大型不可变数据的响应性开销}
\switchcolumn[0]*%%%%%%%
Vue's reactivity system is deep by default. While this makes state
management intuitive, it does create a certain level of overhead when
the data size is large, because every property access triggers proxy
traps that perform dependency tracking. This typically becomes
noticeable when dealing with large arrays of deeply nested objects,
where a single render needs to access 100,000+ properties, so it should
only affect very specific use cases.
\switchcolumn
Vue
的响应性系统默认是深度的。虽然这让状态管理变得更直观，但在数据量巨大时，深度响应性也会导致不小的性能负担，因为每个属性访问都将触发代理的依赖追踪。好在这种性能负担通常只有在处理超大型数组或层级很深的对象时，例如一次渲染需要访问
100,000+ 个属性时，才会变得比较明显。因此，它只会影响少数特定的场景。
\switchcolumn[0]*%%%%%%%
Vue does provide an escape hatch to opt-out of deep reactivity by using
\href{https://vuejs.org/api/reactivity-advanced.html\#shallowref}{\texttt{shallowRef()}}
and
\href{https://vuejs.org/api/reactivity-advanced.html\#shallowreactive}{\texttt{shallowReactive()}}.
Shallow APIs create state that is reactive only at the root level, and
exposes all nested objects untouched. This keeps nested property access
fast, with the trade-off being that we must now treat all nested objects
as immutable, and updates can only be triggered by replacing the root
state:
\switchcolumn
Vue 确实也为此提供了一种解决方案，通过使用
\href{https://cn.vuejs.org/api/reactivity-advanced.html\#shallowref}{\texttt{shallowRef()}}
和
\href{https://cn.vuejs.org/api/reactivity-advanced.html\#shallowreactive}{\texttt{shallowReactive()}}
来绕开深度响应。浅层式 API
创建的状态只在其顶层是响应式的，对所有深层的对象不会做任何处理。这使得对深层级属性的访问变得更快，但代价是，我们现在必须将所有深层级对象视为不可变的，并且只能通过替换整个根状态来触发更新：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
const shallowArray = shallowRef([
  /* 巨大的列表，里面包含深层的对象 */
])
// 这不会触发更新...
shallowArray.value.push(newObject)
// 这才会触发更新
shallowArray.value = [...shallowArray.value, newObject]
// 这不会触发更新...
shallowArray.value[0].foo = 1
// 这才会触发更新
shallowArray.value = [
  {
    ...shallowArray.value[0],
    foo: 1
  },
  ...shallowArray.value.slice(1)
]
\end{codeJs}
\switchcolumn
\begin{codeJs}
const shallowArray = shallowRef([
  /* 巨大的列表，里面包含深层的对象 */
])
// 这不会触发更新...
shallowArray.value.push(newObject)
// 这才会触发更新
shallowArray.value = [...shallowArray.value, newObject]
// 这不会触发更新...
shallowArray.value[0].foo = 1
// 这才会触发更新
shallowArray.value = [
  {
    ...shallowArray.value[0],
    foo: 1
  },
  ...shallowArray.value.slice(1)
]
\end{codeJs}
\switchcolumn[0]*%%%%%%%
\subsubsection{Avoid Unnecessary Component Abstractions}
\switchcolumn
\subsubsection{避免不必要的组件抽象}
\switchcolumn[0]*%%%%%%%
Sometimes we may create
\href{https://vuejs.org/guide/components/slots.html\#renderless-components}{renderless
components} or higher-order components (i.e. components that render
other components with extra props) for better abstraction or code
organization. While there is nothing wrong with this, do keep in mind
that component instances are much more expensive than plain DOM nodes,
and creating too many of them due to abstraction patterns will incur
performance costs.
\switchcolumn
有些时候我们会去创建\href{https://cn.vuejs.org/guide/components/slots.html\#renderless-components}{无渲染组件}或高阶组件
(用来渲染具有额外 props 的其他组件)
来实现更好的抽象或代码组织。虽然这并没有什么问题，但请记住，组件实例比普通
DOM 节点要昂贵得多，而且为了逻辑抽象创建太多组件实例将会导致性能损失。
\switchcolumn[0]*%%%%%%%
Note that reducing only a few instances won't have noticeable effect, so
don't sweat it if the component is rendered only a few times in the app.
The best scenario to consider this optimization is again in large lists.
Imagine a list of 100 items where each item component contains many
child components. Removing one unnecessary component abstraction here
could result in a reduction of hundreds of component instances.
\switchcolumn
需要提醒的是，只减少几个组件实例对于性能不会有明显的改善，所以如果一个用于抽象的组件在应用中只会渲染几次，就不用操心去优化它了。考虑这种优化的最佳场景还是在大型列表中。想象一下一个有
100
项的列表，每项的组件都包含许多子组件。在这里去掉一个不必要的组件抽象，可能会减少数百个组件实例的无谓性能消耗。
\end{paracol}


