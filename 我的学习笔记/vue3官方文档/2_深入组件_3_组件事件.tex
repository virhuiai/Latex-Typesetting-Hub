\columnratio{0.55}
\begin{paracol}{2}

\switchcolumn[0]*%%%%%%%
\section{Component Events}
\switchcolumn
\section{组件事件}
\switchcolumn[0]*%%%%%%%
\begin{quote}
This page assumes you've already read the
\href{https://vuejs.org/guide/essentials/component-basics.html}{Components
Basics}. Read that first if you are new to components.
\end{quote}
\switchcolumn
\begin{quote}
此章节假设你已经看过了\href{https://cn.vuejs.org/guide/essentials/component-basics.html}{组件基础}。若你还不了解组件是什么，请先阅读该章节。
\end{quote}
\switchcolumn[0]*%%%%%%%
\subsection{Emitting and Listening to Events}
\switchcolumn
\subsection{触发与监听事件}
\switchcolumn[0]*%%%%%%%
A component can emit custom events directly in template expressions
(e.g. in a \texttt{v-on} handler) using the built-in \texttt{\$emit}
method:
\switchcolumn
在组件的模板表达式中，可以直接使用 \texttt{\$emit} 方法触发自定义事件
(例如：在 \texttt{v-on} 的处理函数中)：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<!-- MyComponent -->
<button @click="$emit('someEvent')">click me</button>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<!-- MyComponent -->
<button @click="$emit('someEvent')">click me</button>
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
The parent can then listen to it using \texttt{v-on}:
\switchcolumn
父组件可以通过 \texttt{v-on} (缩写为 \texttt{@}) 来监听事件：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<MyComponent @some-event="callback" />
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<MyComponent @some-event="callback" />
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
The \texttt{.once} modifier is also supported on component event
listeners:
\switchcolumn
同样，组件的事件监听器也支持 \texttt{.once} 修饰符：

\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<MyComponent @some-event.once="callback" />
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<MyComponent @some-event.once="callback" />
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
Like components and props, event names provide an automatic case
transformation. Notice we emitted a camelCase event, but can listen for
it using a kebab-cased listener in the parent. As with
\href{https://vuejs.org/guide/components/props.html\#prop-name-casing}{props
casing}, we recommend using kebab-cased event listeners in templates.
\switchcolumn
像组件与 prop
一样，事件的名字也提供了自动的格式转换。注意这里我们触发了一个以
camelCase 形式命名的事件，但在父组件中可以使用 kebab-case 形式来监听。与
\href{https://cn.vuejs.org/guide/components/props.html\#prop-name-casing}{prop
大小写格式}一样，在模板中我们也推荐使用 kebab-case 形式来编写监听器。
\switchcolumn[0]*%%%%%%%
\begin{vueQuote}{TIP}
Unlike native DOM events, component emitted events do \textbf{not}
bubble. You can only listen to the events emitted by a direct child
component. If there is a need to communicate between sibling or deeply
nested components, use an external event bus or a
\href{https://vuejs.org/guide/scaling-up/state-management.html}{global
state management solution}.
\end{vueQuote} 
\switchcolumn
\begin{vueQuote}{TIP}
和原生 DOM
事件不一样，组件触发的事件\textbf{没有冒泡机制}。你只能监听直接子组件触发的事件。平级组件或是跨越多层嵌套的组件间通信，应使用一个外部的事件总线，或是使用一个\href{https://cn.vuejs.org/guide/scaling-up/state-management.html}{全局状态管理方案}。
\end{vueQuote} 
\end{paracol}

\columnratio{0.55}
\begin{paracol}{2}

\switchcolumn[0]*%%%%%%%
\subsection{Event Arguments}
\switchcolumn
\subsection{事件参数}
\switchcolumn[0]*%%%%%%%
It's sometimes useful to emit a specific value with an event. For
example, we may want the \texttt{\textless{}BlogPost\textgreater{}}
component to be in charge of how much to enlarge the text by. In those
cases, we can pass extra arguments to \texttt{\$emit} to provide this
value:
\switchcolumn
有时候我们会需要在触发事件时附带一个特定的值。举例来说，我们想要
\texttt{\textless{}BlogPost\textgreater{}}
组件来管理文本会缩放得多大。在这个场景下，我们可以给 \texttt{\$emit}
提供一个额外的参数：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<button @click="$emit('increaseBy', 1)">
    Increase by 1
</button>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<button @click="$emit('increaseBy', 1)">
    Increase by 1
</button>
\end{codeHtml}

\switchcolumn[0]*%%%%%%%
Then, when we listen to the event in the parent, we can use an inline
arrow function as the listener, which allows us to access the event
argument:
\switchcolumn
然后我们在父组件中监听事件，我们可以先简单写一个内联的箭头函数作为监听器，此函数会接收到事件附带的参数：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<MyButton @increase-by="(n) => count += n" />
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<MyButton @increase-by="(n) => count += n" />
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
Or, if the event handler is a method:
\switchcolumn
或者，也可以用一个组件方法来作为事件处理函数：

\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<MyButton @increase-by="increaseCount" />
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<MyButton @increase-by="increaseCount" />
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
Then the value will be passed as the first parameter of that method:
\switchcolumn
该方法也会接收到事件所传递的参数：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
function increaseCount(n) {
  count.value += n
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
function increaseCount(n) {
  count.value += n
}
\end{codeJs}
\switchcolumn[0]*%%%%%%%
\begin{vueQuote}{TIP}
All extra arguments passed to \texttt{\$emit()} after the event name
will be forwarded to the listener. For example, with
\texttt{\$emit(\textquotesingle{}foo\textquotesingle{},\ 1,\ 2,\ 3)} the
listener function will receive three arguments.
\end{vueQuote} 
\switchcolumn
\begin{vueQuote}{TIP}
所有传入 \texttt{\$emit()}
的额外参数都会被直接传向监听器。举例来说，\texttt{\$emit(\textquotesingle{}foo\textquotesingle{},\ 1,\ 2,\ 3)}
触发后，监听器函数将会收到这三个参数值。
\end{vueQuote} 
\end{paracol}

\columnratio{0.55}
\begin{paracol}{2}

\switchcolumn[0]*%%%%%%%
\subsection{Declaring Emitted Events}
\switchcolumn
\subsection{声明触发的事件}
\switchcolumn[0]*%%%%%%%
A component can explicitly declare the events it will emit using the
\href{https://vuejs.org/api/sfc-script-setup.html\#defineprops-defineemits}{\texttt{defineEmits()}}
macro:
\switchcolumn
组件可以显式地通过
\href{https://cn.vuejs.org/api/sfc-script-setup.html\#defineprops-defineemits}{\texttt{defineEmits()}}
宏来声明它要触发的事件：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<script setup>
defineEmits(['inFocus', 'submit'])
</script>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<script setup>
defineEmits(['inFocus', 'submit'])
</script>
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
The \texttt{\$emit} method that we used in the
\texttt{\textless{}template\textgreater{}} isn't accessible within the
\texttt{\textless{}script\ setup\textgreater{}} section of a component,
but \texttt{defineEmits()} returns an equivalent function that we can
use instead:
\switchcolumn
我们在 \texttt{\textless{}template\textgreater{}} 中使用的
\texttt{\$emit} 方法不能在组件的
\texttt{\textless{}script\ setup\textgreater{}} 部分中使用，但
\texttt{defineEmits()} 会返回一个相同作用的函数供我们使用：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<script setup>
const emit = defineEmits(['inFocus', 'submit'])
function buttonClick() {
  emit('submit')
}
</script>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<script setup>
const emit = defineEmits(['inFocus', 'submit'])
function buttonClick() {
  emit('submit')
}
</script>
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
The \texttt{defineEmits()} macro \textbf{cannot} be used inside a
function, it must be placed directly within
\texttt{\textless{}script\ setup\textgreater{}}, as in the example
above.
\switchcolumn
\texttt{defineEmits()}
宏\textbf{不能}在子函数中使用。如上所示，它必须直接放置在
\texttt{\textless{}script\ setup\textgreater{}} 的顶级作用域下。
\switchcolumn[0]*%%%%%%%
If you're using an explicit \texttt{setup} function instead of
\texttt{\textless{}script\ setup\textgreater{}}, events should be
declared using the
\href{https://vuejs.org/api/options-state.html\#emits}{\texttt{emits}}
option, and the \texttt{emit} function is exposed on the
\texttt{setup()} context:
\switchcolumn
如果你显式地使用了 \texttt{setup} 函数而不是
\texttt{\textless{}script\ setup\textgreater{}}，则事件需要通过
\href{https://cn.vuejs.org/api/options-state.html\#emits}{\texttt{emits}}
选项来定义，\texttt{emit} 函数也被暴露在 \texttt{setup()}
的上下文对象上：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
export default {
  emits: ['inFocus', 'submit'],
  setup(props, ctx) {
    ctx.emit('submit')
  }
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
export default {
  emits: ['inFocus', 'submit'],
  setup(props, ctx) {
    ctx.emit('submit')
  }
}
\end{codeJs}
\switchcolumn[0]*%%%%%%%
As with other properties of the \texttt{setup()} context, \texttt{emit}
can safely be destructured:
\switchcolumn
与 \texttt{setup()} 上下文对象中的其他属性一样，\texttt{emit}
可以安全地被解构：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
export default {
  emits: ['inFocus', 'submit'],
  setup(props, { emit }) {
    emit('submit')
  }
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
export default {
  emits: ['inFocus', 'submit'],
  setup(props, { emit }) {
    emit('submit')
  }
}
\end{codeJs}
\switchcolumn[0]*%%%%%%%
The \texttt{emits} option and \texttt{defineEmits()} macro also support
an object syntax, which allows us to perform runtime validation of the
payload of the emitted events:
\switchcolumn
这个 \texttt{emits} 选项和 \texttt{defineEmits()}
宏还支持对象语法，它允许我们对触发事件的参数进行验证：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<script setup>
const emit = defineEmits({
  submit(payload) {
    // 通过返回值为 `true` 还是为 `false` 来判断
    // 验证是否通过
  }
})
</script>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<script setup>
const emit = defineEmits({
  submit(payload) {
    // 通过返回值为 `true` 还是为 `false` 来判断
    // 验证是否通过
  }
})
</script>
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
If you are using TypeScript with
\texttt{\textless{}script\ setup\textgreater{}}, it's also possible to
declare emitted events using pure type annotations:
\switchcolumn
如果你正在搭配 TypeScript 使用
\texttt{\textless{}script\ setup\textgreater{}}，也可以使用纯类型标注来声明触发的事件：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<script setup lang="ts">
const emit = defineEmits<{
  (e: 'change', id: number): void
  (e: 'update', value: string): void
}>()
</script>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<script setup lang="ts">
const emit = defineEmits<{
  (e: 'change', id: number): void
  (e: 'update', value: string): void
}>()
</script>
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
More details:
\href{https://vuejs.org/guide/typescript/composition-api.html\#typing-component-emits}{Typing
Component Emits}
\switchcolumn
TypeScript
用户请参考：\href{https://cn.vuejs.org/guide/typescript/composition-api.html\#typing-component-emits}{如何为组件所抛出事件标注类型}
\switchcolumn[0]*%%%%%%%
Although optional, it is recommended to define all emitted events in
order to better document how a component should work. It also allows Vue
to exclude known listeners from
\href{https://vuejs.org/guide/components/attrs.html\#v-on-listener-inheritance}{fallthrough
attributes}, avoiding edge cases caused by DOM events manually
dispatched by 3rd party code.
\switchcolumn
尽管事件声明是可选的，我们还是推荐你完整地声明所有要触发的事件，以此在代码中作为文档记录组件的用法。同时，事件声明能让
Vue
更好地将事件和\href{https://cn.vuejs.org/guide/components/attrs.html\#v-on-listener-inheritance}{透传
attribute} 作出区分，从而避免一些由第三方代码触发的自定义 DOM
事件所导致的边界情况。
\switchcolumn[0]*%%%%%%%
\begin{vueQuote}{TIP}
If a native event (e.g., \texttt{click}) is defined in the
\texttt{emits} option, the listener will now only listen to
component-emitted \texttt{click} events and no longer respond to native
\texttt{click} events.
\end{vueQuote} 
\switchcolumn
\begin{vueQuote}{TIP}
如果一个原生事件的名字 (例如 \texttt{click}) 被定义在 \texttt{emits}
选项中，则监听器只会监听组件触发的 \texttt{click} 事件而不会再响应原生的
\texttt{click} 事件。
\end{vueQuote}  
\end{paracol}


\columnratio{0.55}
\begin{paracol}{2}
\switchcolumn[0]*%%%%%%%
\subsection{Events Validation}
\switchcolumn
\subsection{事件校验}
\switchcolumn[0]*%%%%%%%
Similar to prop type validation, an emitted event can be validated if it
is defined with the object syntax instead of the array syntax.
\switchcolumn
和对 props
添加类型校验的方式类似，所有触发的事件也可以使用对象形式来描述。
\switchcolumn[0]*%%%%%%%
To add validation, the event is assigned a function that receives the
arguments passed to the \texttt{emit} call and returns a boolean to
indicate whether the event is valid or not.
\switchcolumn
要为事件添加校验，那么事件可以被赋值为一个函数，接受的参数就是抛出事件时传入
\texttt{emit} 的内容，返回一个布尔值来表明事件是否合法。
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<script setup>
const emit = defineEmits({
    // 没有校验
    click: null,
    // 校验 submit 事件
    submit: ({ email, password }) => {
    if (email && password) {
        return true
    } else {
        console.warn('Invalid submit event payload!')
        return false
    }
    }
})
function submitForm(email, password) {
    emit('submit', { email, password })
}
</script>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<script setup>
const emit = defineEmits({
    // 没有校验
    click: null,
    // 校验 submit 事件
    submit: ({ email, password }) => {
    if (email && password) {
        return true
    } else {
        console.warn('Invalid submit event payload!')
        return false
    }
    }
})
function submitForm(email, password) {
    emit('submit', { email, password })
}
</script>
\end{codeHtml}
\end{paracol}
