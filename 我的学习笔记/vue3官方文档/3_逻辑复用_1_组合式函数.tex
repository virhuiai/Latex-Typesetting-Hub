
\columnratio{0.55}
\begin{paracol}{2}
 
\switchcolumn[0]*%%%%%%%
\section{Composables}
\switchcolumn
\section{组合式函数}
\switchcolumn[0]*%%%%%%%
\begin{codeVue}{TIP}
This section assumes basic knowledge of Composition API. If you have
been learning Vue with Options API only, you can set the API Preference
to Composition API (using the toggle at the top of the left sidebar) and
re-read the
\href{https://vuejs.org/guide/essentials/reactivity-fundamentals.html}{Reactivity
Fundamentals} and
\href{https://vuejs.org/guide/essentials/lifecycle.html}{Lifecycle
Hooks} chapters.
\end{codeVue}
\switchcolumn
\begin{codeVue}{TIP}
此章节假设你已经对组合式 API 有了基本的了解。如果你只学习过选项式
API，你可以使用左侧边栏上方的切换按钮将 API 风格切换为组合式 API
后，重新阅读\href{https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html}{响应性基础}和\href{https://cn.vuejs.org/guide/essentials/lifecycle.html}{生命周期钩子}两个章节。
\end{codeVue}
\switchcolumn[0]*%%%%%%%
\subsection{What is a "Composable"?}
\switchcolumn
\subsection{什么是``组合式函数''？}
\switchcolumn[0]*%%%%%%%
In the context of Vue applications, a "composable" is a function that
leverages Vue's Composition API to encapsulate and reuse
\textbf{stateful logic}.
\switchcolumn
在 Vue 应用的概念中，``组合式函数''(Composables) 是一个利用 Vue 的组合式
API 来封装和复用\textbf{有状态逻辑}的函数。
\switchcolumn[0]*%%%%%%%
When building frontend applications, we often need to reuse logic for
common tasks. For example, we may need to format dates in many places,
so we extract a reusable function for that. This formatter function
encapsulates \textbf{stateless logic}: it takes some input and
immediately returns expected output. There are many libraries out there
for reusing stateless logic - for example
\href{https://lodash.com/}{lodash} and
\href{https://date-fns.org/}{date-fns}, which you may have heard of.
\switchcolumn
当构建前端应用时，我们常常需要复用公共任务的逻辑。例如为了在不同地方格式化时间，我们可能会抽取一个可复用的日期格式化函数。这个函数封装了\textbf{无状态的逻辑}：它在接收一些输入后立刻返回所期望的输出。复用无状态逻辑的库有很多，比如你可能已经用过的
\href{https://lodash.com/}{lodash} 或是
\href{https://date-fns.org/}{date-fns}。
\switchcolumn[0]*%%%%%%%
By contrast, stateful logic involves managing state that changes over
time. A simple example would be tracking the current position of the
mouse on a page. In real-world scenarios, it could also be more complex
logic such as touch gestures or connection status to a database.
\switchcolumn
相比之下，有状态逻辑负责管理会随时间而变化的状态。一个简单的例子是跟踪当前鼠标在页面中的位置。在实际应用中，也可能是像触摸手势或与数据库的连接状态这样的更复杂的逻辑。
\end{paracol}

\columnratio{0.55}
\begin{paracol}{2}
 
\switchcolumn[0]*%%%%%%%
\subsection{Mouse Tracker Example}
\switchcolumn
\subsection{鼠标跟踪器示例}
\switchcolumn[0]*%%%%%%%
If we were to implement the mouse tracking functionality using the
Composition API directly inside a component, it would look like this:
\switchcolumn
如果我们要直接在组件中使用组合式 API 实现鼠标跟踪功能，它会是这样的：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<script setup>
import { ref, onMounted, onUnmounted } from 'vue'
const x = ref(0)
const y = ref(0)
function update(event) {
  x.value = event.pageX
  y.value = event.pageY
}
onMounted(() => window.addEventListener('mousemove', update))
onUnmounted(() => window.removeEventListener('mousemove', update))
</script>
<template>Mouse position is at: {{ x }}, {{ y }}</template>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<script setup>
import { ref, onMounted, onUnmounted } from 'vue'
const x = ref(0)
const y = ref(0)
function update(event) {
  x.value = event.pageX
  y.value = event.pageY
}
onMounted(() => window.addEventListener('mousemove', update))
onUnmounted(() => window.removeEventListener('mousemove', update))
</script>
<template>Mouse position is at: {{ x }}, {{ y }}</template>
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
But what if we want to reuse the same logic in multiple components? We
can extract the logic into an external file, as a composable function:
\switchcolumn
但是，如果我们想在多个组件中复用这个相同的逻辑呢？我们可以把这个逻辑以一个组合式函数的形式提取到外部文件中：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// mouse.js
import { ref, onMounted, onUnmounted } from 'vue'
// 按照惯例，组合式函数名以“use”开头
export function useMouse() {
  // 被组合式函数封装和管理的状态
  const x = ref(0)
  const y = ref(0)
  // 组合式函数可以随时更改其状态。
  function update(event) {
    x.value = event.pageX
    y.value = event.pageY
  }
  // 一个组合式函数也可以挂靠在所属组件的生命周期上
  // 来启动和卸载副作用
  onMounted(() => window.addEventListener('mousemove', update))
  onUnmounted(() => window.removeEventListener('mousemove', update))
  // 通过返回值暴露所管理的状态
  return { x, y }
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
// mouse.js
import { ref, onMounted, onUnmounted } from 'vue'
// 按照惯例，组合式函数名以“use”开头
export function useMouse() {
  // 被组合式函数封装和管理的状态
  const x = ref(0)
  const y = ref(0)
  // 组合式函数可以随时更改其状态。
  function update(event) {
    x.value = event.pageX
    y.value = event.pageY
  }
  // 一个组合式函数也可以挂靠在所属组件的生命周期上
  // 来启动和卸载副作用
  onMounted(() => window.addEventListener('mousemove', update))
  onUnmounted(() => window.removeEventListener('mousemove', update))
  // 通过返回值暴露所管理的状态
  return { x, y }
}
\end{codeJs}
\switchcolumn[0]*%%%%%%%
And this is how it can be used in components:
\switchcolumn
下面是它在组件中使用的方式：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<script setup>
import { useMouse } from './mouse.js'
const { x, y } = useMouse()
</script>
<template>Mouse position is at: {{ x }}, {{ y }}</template>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<script setup>
import { useMouse } from './mouse.js'
const { x, y } = useMouse()
</script>
<template>Mouse position is at: {{ x }}, {{ y }}</template>
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
\href{https://play.vuejs.org/\#eNqNkj1rwzAQhv/KocUOGKVzSAIdurVjoQUvJj4XlfgkJNmxMfrvPcmJkkKHLrbu69H7SlrEszFyHFDsxN6drDIeHPrBHGtSvdHWwwKDwzfNHwjQWd1DIbd9jOW3K2qq6aTJxb6pgpl7Dnmg3NS0365YBnLgsTfnxiNHACvUaKe80gTKQeN3sDAIQqjignEhIvKYqMRta1acFVrsKtDEQPLYxuU7cV8Msmg2mdTilIa6gU5p27tYWKKq1c3ENphaPrGFW25+yMXsHWFaFlfiiOSvFIBJjs15QJ5JeWmaL/xYS/Mfpc9YYrPxl52ULOpwhIuiVl9k07Yvsf9VOY+EtizSWfR6xKK6itgkvQ/+fyNs6v4XJXIsPwVL+WprCiL8AEUxw5s=}{Try
it in the Playground}
\switchcolumn
\href{https://play.vuejs.org/\#eNqNkj1rwzAQhv/KocUOGKVzSAIdurVjoQUvJj4XlfgkJNmxMfrvPcmJkkKHLrbu69H7SlrEszFyHFDsxN6drDIeHPrBHGtSvdHWwwKDwzfNHwjQWd1DIbd9jOW3K2qq6aTJxb6pgpl7Dnmg3NS0365YBnLgsTfnxiNHACvUaKe80gTKQeN3sDAIQqjignEhIvKYqMRta1acFVrsKtDEQPLYxuU7cV8Msmg2mdTilIa6gU5p27tYWKKq1c3ENphaPrGFW25+yMXsHWFaFlfiiOSvFIBJjs15QJ5JeWmaL/xYS/Mfpc9YYrPxl52ULOpwhIuiVl9k07Yvsf9VOY+EtizSWfR6xKK6itgkvQ/+fyNs6v4XJXIsPwVL+WprCiL8AEUxw5s=}{在演练场中尝试一下}

\switchcolumn[0]*%%%%%%%
As we can see, the core logic remains identical - all we had to do was
move it into an external function and return the state that should be
exposed. Just like inside a component, you can use the full range of
\href{https://vuejs.org/api/\#composition-api}{Composition API
functions} in composables. The same \texttt{useMouse()} functionality
can now be used in any component.
\switchcolumn
如你所见，核心逻辑完全一致，我们做的只是把它移到一个外部函数中去，并返回需要暴露的状态。和在组件中一样，你也可以在组合式函数中使用所有的\href{https://cn.vuejs.org/api/\#composition-api}{组合式
API}。现在，\texttt{useMouse()} 的功能可以在任何组件中轻易复用了。
\switchcolumn[0]*%%%%%%%
The cooler part about composables though, is that you can also nest
them: one composable function can call one or more other composable
functions. This enables us to compose complex logic using small,
isolated units, similar to how we compose an entire application using
components. In fact, this is why we decided to call the collection of
APIs that make this pattern possible Composition API.
\switchcolumn
更酷的是，你还可以嵌套多个组合式函数：一个组合式函数可以调用一个或多个其他的组合式函数。这使得我们可以像使用多个组件组合成整个应用一样，用多个较小且逻辑独立的单元来组合形成复杂的逻辑。实际上，这正是为什么我们决定将实现了这一设计模式的
API 集合命名为组合式 API。
\switchcolumn[0]*%%%%%%%
For example, we can extract the logic of adding and removing a DOM event
listener into its own composable:
\switchcolumn
举例来说，我们可以将添加和清除 DOM
事件监听器的逻辑也封装进一个组合式函数中：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// event.js
import { onMounted, onUnmounted } from 'vue'
export function useEventListener(target, event, callback) {
  // 如果你想的话，
  // 也可以用字符串形式的 CSS 选择器来寻找目标 DOM 元素
  onMounted(() => target.addEventListener(event, callback))
  onUnmounted(() => target.removeEventListener(event, callback))
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
// event.js
import { onMounted, onUnmounted } from 'vue'
export function useEventListener(target, event, callback) {
  // 如果你想的话，
  // 也可以用字符串形式的 CSS 选择器来寻找目标 DOM 元素
  onMounted(() => target.addEventListener(event, callback))
  onUnmounted(() => target.removeEventListener(event, callback))
}
\end{codeJs}
\switchcolumn[0]*%%%%%%%
And now our \texttt{useMouse()} composable can be simplified to:
\switchcolumn
有了它，之前的 \texttt{useMouse()} 组合式函数可以被简化为：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// mouse.js
import { ref } from 'vue'
import { useEventListener } from './event'
export function useMouse() {
  const x = ref(0)
  const y = ref(0)
  useEventListener(window, 'mousemove', (event) => {
    x.value = event.pageX
    y.value = event.pageY
  })
  return { x, y }
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
// mouse.js
import { ref } from 'vue'
import { useEventListener } from './event'
export function useMouse() {
  const x = ref(0)
  const y = ref(0)
  useEventListener(window, 'mousemove', (event) => {
    x.value = event.pageX
    y.value = event.pageY
  })
  return { x, y }
}
\end{codeJs}
\switchcolumn[0]*%%%%%%%
\begin{codeVue}{TIP}
Each component instance calling \texttt{useMouse()} will create its own
copies of \texttt{x} and \texttt{y} state so they won't interfere with
one another. If you want to manage shared state between components, read
the
\href{https://vuejs.org/guide/scaling-up/state-management.html}{State
Management} chapter.
\end{codeVue}
\switchcolumn
\begin{codeVue}{TIP}
每一个调用 \texttt{useMouse()} 的组件实例会创建其独有的
\texttt{x}、\texttt{y}
状态拷贝，因此他们不会互相影响。如果你想要在组件之间共享状态，请阅读\href{https://cn.vuejs.org/guide/scaling-up/state-management.html}{状态管理}这一章。
\end{codeVue}
\end{paracol}

\columnratio{0.55}
\begin{paracol}{2}
 
\switchcolumn[0]*%%%%%%%
\subsection{Async State Example}
\switchcolumn
\subsection{异步状态示例}
\switchcolumn[0]*%%%%%%%
The \texttt{useMouse()} composable doesn't take any arguments, so let's
take a look at another example that makes use of one. When doing async
data fetching, we often need to handle different states: loading,
success, and error:
\switchcolumn
\texttt{useMouse()}
组合式函数没有接收任何参数，因此让我们再来看一个需要接收一个参数的组合式函数示例。在做异步数据请求时，我们常常需要处理不同的状态：加载中、加载成功和加载失败。
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<script setup>
import { ref } from 'vue'
const data = ref(null)
const error = ref(null)
fetch('...')
  .then((res) => res.json())
  .then((json) => (data.value = json))
  .catch((err) => (error.value = err))
</script>
<template>
  <div v-if="error">Oops! Error encountered: {{ error.message }}</div>
  <div v-else-if="data">
    Data loaded:
    <pre>{{ data }}</pre>
  </div>
  <div v-else>Loading...</div>
</template>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<script setup>
import { ref } from 'vue'
const data = ref(null)
const error = ref(null)
fetch('...')
  .then((res) => res.json())
  .then((json) => (data.value = json))
  .catch((err) => (error.value = err))
</script>
<template>
  <div v-if="error">Oops! Error encountered: {{ error.message }}</div>
  <div v-else-if="data">
    Data loaded:
    <pre>{{ data }}</pre>
  </div>
  <div v-else>Loading...</div>
</template>
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
It would be tedious to have to repeat this pattern in every component
that needs to fetch data. Let's extract it into a composable:
\switchcolumn
如果在每个需要获取数据的组件中都要重复这种模式，那就太繁琐了。让我们把它抽取成一个组合式函数：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// fetch.js
import { ref } from 'vue'
export function useFetch(url) {
  const data = ref(null)
  const error = ref(null)
  fetch(url)
    .then((res) => res.json())
    .then((json) => (data.value = json))
    .catch((err) => (error.value = err))
  return { data, error }
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
// fetch.js
import { ref } from 'vue'
export function useFetch(url) {
  const data = ref(null)
  const error = ref(null)
  fetch(url)
    .then((res) => res.json())
    .then((json) => (data.value = json))
    .catch((err) => (error.value = err))
  return { data, error }
}
\end{codeJs}
\switchcolumn[0]*%%%%%%%
Now in our component we can just do:
\switchcolumn
现在我们在组件里只需要：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<script setup>
import { useFetch } from './fetch.js'
const { data, error } = useFetch('...')
</script>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<script setup>
import { useFetch } from './fetch.js'
const { data, error } = useFetch('...')
</script>
\end{codeHtml}
\end{paracol}

\columnratio{0.55}
\begin{paracol}{2}
 
\switchcolumn[0]*%%%%%%%
\subsubsection{Accepting Reactive State}
\switchcolumn
\subsubsection{接收响应式状态}
\switchcolumn[0]*%%%%%%%
\texttt{useFetch()} takes a static URL string as input - so it performs
the fetch only once and is then done. What if we want it to re-fetch
whenever the URL changes? In order to achieve this, we need to pass
reactive state into the composable function, and let the composable
create watchers that perform actions using the passed state.
\switchcolumn
\texttt{useFetch()} 接收一个静态 URL
字符串作为输入------因此它只会执行一次 fetch
并且就此结束。如果我们想要在 URL 改变时重新 fetch
呢？为了实现这一点，我们需要将响应式状态传入组合式函数，并让它基于传入的状态来创建执行操作的侦听器。
\switchcolumn[0]*%%%%%%%
For example, \texttt{useFetch()} should be able to accept a ref:
\switchcolumn
举例来说，\texttt{useFetch()} 应该能够接收一个 ref：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
const url = ref('/initial-url')
const { data, error } = useFetch(url)
// 这将会重新触发 fetch
url.value = '/new-url'
\end{codeJs}
\switchcolumn
\begin{codeJs}
const url = ref('/initial-url')
const { data, error } = useFetch(url)
// 这将会重新触发 fetch
url.value = '/new-url'
\end{codeJs}
\switchcolumn[0]*%%%%%%%
Or, accept a getter function:
\switchcolumn
或者接收一个 getter 函数：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// 当 props.id 改变时重新 fetch
const { data, error } = useFetch(() => `/posts/${props.id}`)
\end{codeJs}
\switchcolumn
\begin{codeJs}
// 当 props.id 改变时重新 fetch
const { data, error } = useFetch(() => `/posts/${props.id}`)
\end{codeJs}
\switchcolumn[0]*%%%%%%%
We can refactor our existing implementation with the
\href{https://vuejs.org/api/reactivity-core.html\#watcheffect}{\texttt{watchEffect()}}
and
\href{https://vuejs.org/api/reactivity-utilities.html\#tovalue}{\texttt{toValue()}}
APIs:
\switchcolumn
我们可以用
\href{https://cn.vuejs.org/api/reactivity-core.html\#watcheffect}{\texttt{watchEffect()}}
和
\href{https://cn.vuejs.org/api/reactivity-utilities.html\#tovalue}{\texttt{toValue()}}
API 来重构我们现有的实现：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// fetch.js
import { ref, watchEffect, toValue } from 'vue'
export function useFetch(url) {
  const data = ref(null)
  const error = ref(null)
  const fetchData = () => {
    // reset state before fetching..
    data.value = null
    error.value = null
    fetch(toValue(url))
      .then((res) => res.json())
      .then((json) => (data.value = json))
      .catch((err) => (error.value = err))
  }
  watchEffect(() => {
    fetchData()
  })
  return { data, error }
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
// fetch.js
import { ref, watchEffect, toValue } from 'vue'
export function useFetch(url) {
  const data = ref(null)
  const error = ref(null)
  const fetchData = () => {
    // reset state before fetching..
    data.value = null
    error.value = null
    fetch(toValue(url))
      .then((res) => res.json())
      .then((json) => (data.value = json))
      .catch((err) => (error.value = err))
  }
  watchEffect(() => {
    fetchData()
  })
  return { data, error }
}
\end{codeJs}
\switchcolumn[0]*%%%%%%%
\texttt{toValue()} is an API added in 3.3. It is designed to normalize
refs or getters into values. If the argument is a ref, it returns the
ref's value; if the argument is a function, it will call the function
and return its return value. Otherwise, it returns the argument as-is.
It works similarly to
\href{https://vuejs.org/api/reactivity-utilities.html\#unref}{\texttt{unref()}},
but with special treatment for functions.
\switchcolumn
\texttt{toValue()} 是一个在 3.3 版本中新增的 API。它的设计目的是将 ref
或 getter 规范化为值。如果参数是 ref，它会返回 ref
的值；如果参数是函数，它会调用函数并返回其返回值。否则，它会原样返回参数。它的工作方式类似于
\href{https://cn.vuejs.org/api/reactivity-utilities.html\#unref}{\texttt{unref()}}，但对函数有特殊处理。
\switchcolumn[0]*%%%%%%%
Notice that \texttt{toValue(url)} is called \textbf{inside} the
\texttt{watchEffect} callback. This ensures that any reactive
dependencies accessed during the \texttt{toValue()} normalization are
tracked by the watcher.
\switchcolumn
注意 \texttt{toValue(url)} 是在 \texttt{watchEffect}
回调函数的\textbf{内部}调用的。这确保了在 \texttt{toValue()}
规范化期间访问的任何响应式依赖项都会被侦听器跟踪。
\switchcolumn[0]*%%%%%%%
This version of \texttt{useFetch()} now accepts static URL strings,
refs, and getters, making it much more flexible. The watch effect will
run immediately, and will track any dependencies accessed during
\texttt{toValue(url)}. If no dependencies are tracked (e.g. url is
already a string), the effect runs only once; otherwise, it will re-run
whenever a tracked dependency changes.
\switchcolumn
这个版本的 \texttt{useFetch()} 现在能接收静态 URL 字符串、ref 和
getter，使其更加灵活。watch effect 会立即运行，并且会跟踪
\texttt{toValue(url)} 期间访问的任何依赖项。如果没有跟踪到依赖项（例如
url 已经是字符串），则 effect
只会运行一次；否则，它将在跟踪到的任何依赖项更改时重新运行。
\switchcolumn[0]*%%%%%%%
Here's
\href{https://play.vuejs.org/\#eNp9Vdtu40YM/RVWL1ZQr5RF0JfAMXpLgRZtd5Fu90kvY4mKJ5FnhLnYMQz/+5IcSZF3g30IbPNyyHPIYU7ZL31f7CNmt9nK1073ATyG2K8ro3e9dQFO4LBdQm13fQzYwBlaZ3ewoKTFLCh6/ANDvZ38RTmaiidPkZWprfEBNsrj/66DO1hsQ+j9bVk+eWv6TtW4tV2DrgjHXte2wYKKlsE21pcEkNJ1Q5nUUb54v7gajVHwxhbz/Aru1lOhHymn2KsuIsWPGSdoVFBLQOeso57vJgI5gc0CHQZ3JHfCPFUGJjimQH1dGt6T5VyZVZnUJB3pR8Ad8QtIvwD+tqqB3gqXWzasNjEEa2D/rrXurso0aAM/VRn8XHe6fmYLk9ZVtj6dQMP5vCpTiqBXYdXoPWXrlkKFEEUyMEH36w+29z/AvfBEIhVNQIfNLRCWBBc79F49ouDy4CVx6GlqQXQg3Af+nNWn0JLKp2+pD+w8pmZYY8r5nT6gI9pcdtU7ZB7sSyXp95sYa1ZKm8eiKEb/qpykzJbZbMFofy/39aDIcd+2WIclBPtZ5nO5u5XBF0lpo6mDJrYXO5CGnbZAmk17Z2LH+zF60gJ95eK/WQO58kdTz1cIoCwphZ4a+EBsYIM0e4SWqwvlFMV1p91i+GROc/vWPoe23R4hbFEeRwrlLrbOGht9dwRvQYeFh+BU/UwPW3lQE0CDPZqG9uUIm+MFFyE4sifspOzdqPHwfF674eczcBZk5YJuda1VR0U6dQTqVpmGxpJWl+ULAOqgdICgd2jjUJTNBBANa30FB911/DyjM8KTrANP3SZmim38QIbSlsLcQfukS4oVlA1nM5DI8E77gUAYb4AngqkjmRCTFLZ8KAT9YlApkrJoMa0ZFTtDzTJCjsNqfTtJHCL54yxHCEaGXx0sOTKVeUPPykzrPKmX6g1IBg/wkZ4B6ZDnw6IsyflE051vKC3npwHgYnPp3rWQ/6PCtkiDI+8aroubGS0uJsAjeabPb/oyhEvm3I+cp3zxkBZBfi2uXlMHWZZwc30tVhbnTBcgeJpQqx9FaLoBgl5l/J9Ad+g+9KyDrzK6dsNIM9V19vCX2IKLuBzt9Rbr5zfsT/6FbVX2kd+r22OVTb6g3COG5L7/7198oe+Tc2eb2FH0d5wPLFLkHlPYr9E01PYsTrr9Uy4bnYVP/v4loPEjKW5U5JD4KqO79tt3qL+2e1PcSB6reP4CbzCltA==}{the
updated version of \texttt{useFetch()}}, with an artificial delay and
randomized error for demo purposes.
\switchcolumn
这是\href{https://play.vuejs.org/\#eNptVMFu2zAM/RXOFztYZncodgmSYAPWnTZsKLadfFFsulHrSIZEJwuC/PtIyXaTtkALxxT5yPf45FPypevyfY/JIln6yumOwCP13bo0etdZR3ACh80cKrvresIaztA4u4OUi9KLpN7jN6RqO53nxRjKHz1nlqayxhNslMc/roUVpFuizi+K4tFb07Wqwq1ta3Q5HTtd2RpzblqQra0vGCCW65oreaIs/ZjOxmAf8MYRs2wGq/XU6D3X5HvV9sj5Y8UJakVqDuicdXMGJHfk0VcTj4wxOX9ZRFVYD34h3PGchPwG8N2qGjobZlpIYLnpiayB/YfGulWZaNAGPpUJfK5aXT1JRIbXZbI+nUDD+bwsYklAL2lZ6z1X64ZTw2CcKcAM3a1/2s6/gzsJAzKL3hA6rBfAWCE536H36gEDriwwFA4zTSMEpox7L8+L/pxacPv4K86Brcc4jGjFNV/5AS3TlrbLzqHwkLPYkt/fxFiLUto85Hk+ni+LScpknlwYhX147buD4oO7psGK5kD2r+zxhQdLg/9CSdObijSzvVoinGSeuPYwbPSP6VtZ8HgSJHx5JP8XA2TKH00F0V4BFaAouISvDHhiNrBB3j1CI90D5ZglfaMHuYXAx3Dc2+v4JbRt9wi0xWDymCpTbJ01tvftEbwFTakHcqp64guqPKgJoMYOTc1+OcLmeMUlEBzZM3ZUdjVqPPj/eRq5IAPngKwc6UZXWrXcpFVH4GmVqXkt0boiHwGog9IEpHdo+6GphBmgN6L1DA66beUC9s4EnhwdeOomMlMSkwsytLac5g7aR11ibkDZSLUABRk+aD8QoMiS1WSCcaKwISEZ2MqXIaBfLSpmchUb05pRsTNUIiNkOFjr9SZxyJTHOXx1YGR49eGRDP4rzRt6lmay86Re7DcgGTzAL74GrEOWDUaRL9kjb/fSoWzO3wPAlXNB9M1+KNrmcXF8uoab/PaCljQLwCN5oS93+jpFWmYyT/g8Zel9NEJ4S2fPpYMsc7i9uQlREeecnP8DWEwr0Q==}{更新后的
\texttt{useFetch()}}，为了便于演示，添加了人为延迟和随机错误。
\end{paracol}

\columnratio{0.55}
\begin{paracol}{2}
 
\switchcolumn[0]*%%%%%%%
\subsection{Conventions and Best Practices}
\switchcolumn
\subsection{约定和最佳实践}
\switchcolumn[0]*%%%%%%%
\subsubsection{Naming}
\switchcolumn
\subsubsection{命名}
\switchcolumn[0]*%%%%%%%
It is a convention to name composable functions with camelCase names
that start with "use".
\switchcolumn
组合式函数约定用驼峰命名法命名，并以``use''作为开头。
\switchcolumn[0]*%%%%%%%
\subsubsection{Input Arguments}
\switchcolumn
\subsubsection{输入参数}
\switchcolumn[0]*%%%%%%%
A composable can accept ref or getter arguments even if it doesn't rely
on them for reactivity. If you are writing a composable that may be used
by other developers, it's a good idea to handle the case of input
arguments being refs or getters instead of raw values. The
\href{https://vuejs.org/api/reactivity-utilities.html\#tovalue}{\texttt{toValue()}}
utility function will come in handy for this purpose:
\switchcolumn
即便不依赖于 ref 或 getter
的响应性，组合式函数也可以接收它们作为参数。如果你正在编写一个可能被其他开发者使用的组合式函数，最好处理一下输入参数是
ref 或 getter 而非原始值的情况。可以利用
\href{https://cn.vuejs.org/api/reactivity-utilities.html\#tovalue}{\texttt{toValue()}}
工具函数来实现：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
import { toValue } from 'vue'
function useFeature(maybeRefOrGetter) {
  // 如果 maybeRefOrGetter 是一个 ref 或 getter，
  // 将返回它的规范化值。
  // 否则原样返回。
  const value = toValue(maybeRefOrGetter)
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
import { toValue } from 'vue'
function useFeature(maybeRefOrGetter) {
  // 如果 maybeRefOrGetter 是一个 ref 或 getter，
  // 将返回它的规范化值。
  // 否则原样返回。
  const value = toValue(maybeRefOrGetter)
}
\end{codeJs}
\switchcolumn[0]*%%%%%%%
If your composable creates reactive effects when the input is a ref or a
getter, make sure to either explicitly watch the ref / getter with
\texttt{watch()}, or call \texttt{toValue()} inside a
\texttt{watchEffect()} so that it is properly tracked.
\switchcolumn
如果你的组合式函数在输入参数是 ref 或 getter 的情况下创建了响应式
effect，为了让它能够被正确追踪，请确保要么使用 \texttt{watch()}
显式地监视 ref 或 getter，要么在 \texttt{watchEffect()} 中调用
\texttt{toValue()}。
\switchcolumn[0]*%%%%%%%
The
\href{https://vuejs.org/guide/reusability/composables.html\#accepting-reactive-state}{useFetch()
implementation discussed earlier} provides a concrete example of a
composable that accepts refs, getters and plain values as input
argument.
\switchcolumn
\href{https://cn.vuejs.org/guide/reusability/composables.html\#accepting-reactive-state}{前面讨论过的
useFetch() 实现}提供了一个接受 ref、getter
或普通值作为输入参数的组合式函数的具体示例。
\end{paracol}


\columnratio{0.55}
\begin{paracol}{2}
 
\switchcolumn[0]*%%%%%%%
\subsubsection{Return Values}
\switchcolumn
\subsubsection{返回值}
\switchcolumn[0]*%%%%%%%
You have probably noticed that we have been exclusively using
\texttt{ref()} instead of \texttt{reactive()} in composables. The
recommended convention is for composables to always return a plain,
non-reactive object containing multiple refs. This allows it to be
destructured in components while retaining reactivity:
\switchcolumn
你可能已经注意到了，我们一直在组合式函数中使用 \texttt{ref()} 而不是
\texttt{reactive()}。我们推荐的约定是组合式函数始终返回一个包含多个 ref
的普通的非响应式对象，这样该对象在组件中被解构为 ref
之后仍可以保持响应性：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// x 和 y 是两个 ref
const { x, y } = useMouse()
\end{codeJs}
\switchcolumn
\begin{codeJs}
// x 和 y 是两个 ref
const { x, y } = useMouse()
\end{codeJs}
\switchcolumn[0]*%%%%%%%
Returning a reactive object from a composable will cause such
destructures to lose the reactivity connection to the state inside the
composable, while the refs will retain that connection.
\switchcolumn
从组合式函数返回一个响应式对象会导致在对象解构过程中丢失与组合式函数内状态的响应性连接。与之相反，ref
则可以维持这一响应性连接。
\switchcolumn[0]*%%%%%%%
If you prefer to use returned state from composables as object
properties, you can wrap the returned object with \texttt{reactive()} so
that the refs are unwrapped. For example:
\switchcolumn
如果你更希望以对象属性的形式来使用组合式函数中返回的状态，你可以将返回的对象用
\texttt{reactive()} 包装一次，这样其中的 ref 会被自动解包，例如：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
const mouse = reactive(useMouse())
// mouse.x 链接到了原来的 x ref
console.log(mouse.x)
\end{codeJs}
\switchcolumn
\begin{codeJs}
const mouse = reactive(useMouse())
// mouse.x 链接到了原来的 x ref
console.log(mouse.x)
\end{codeJs}
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
Mouse position is at: {{ mouse.x }}, {{ mouse.y }}
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
Mouse position is at: {{ mouse.x }}, {{ mouse.y }}
\end{codeHtml}
\end{paracol}

\columnratio{0.55}
\begin{paracol}{2}
 
\switchcolumn[0]*%%%%%%%
\subsubsection{Side Effects}
\switchcolumn
\subsubsection{副作用}
\switchcolumn[0]*%%%%%%%
It is OK to perform side effects (e.g. adding DOM event listeners or
fetching data) in composables, but pay attention to the following rules:
\switchcolumn
在组合式函数中的确可以执行副作用 (例如：添加 DOM
事件监听器或者请求数据)，但请注意以下规则：
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  If you are working on an application that uses
  \href{https://vuejs.org/guide/scaling-up/ssr.html}{Server-Side
  Rendering} (SSR), make sure to perform DOM-specific side effects in
  post-mount lifecycle hooks, e.g. \texttt{onMounted()}. These hooks are
  only called in the browser, so you can be sure that code inside them
  has access to the DOM.
\item
  Remember to clean up side effects in \texttt{onUnmounted()}. For
  example, if a composable sets up a DOM event listener, it should
  remove that listener in \texttt{onUnmounted()} as we have seen in the
  \texttt{useMouse()} example. It can be a good idea to use a composable
  that automatically does this for you, like the
  \texttt{useEventListener()} example.
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  如果你的应用用到了\href{https://cn.vuejs.org/guide/scaling-up/ssr.html}{服务端渲染}
  (SSR)，请确保在组件挂载后才调用的生命周期钩子中执行 DOM
  相关的副作用，例如：\texttt{onMounted()}。这些钩子仅会在浏览器中被调用，因此可以确保能访问到
  DOM。
\item
  确保在 \texttt{onUnmounted()}
  时清理副作用。举例来说，如果一个组合式函数设置了一个事件监听器，它就应该在
  \texttt{onUnmounted()} 中被移除 (就像我们在 \texttt{useMouse()}
  示例中看到的一样)。当然也可以像之前的 \texttt{useEventListener()}
  示例那样，使用一个组合式函数来自动帮你做这些事。
\end{itemize}
\end{paracol}


\columnratio{0.55}
\begin{paracol}{2}
  
\switchcolumn[0]*%%%%%%%
\subsubsection{Usage Restrictions}
\switchcolumn
\subsubsection{使用限制}
\switchcolumn[0]*%%%%%%%
Composables should only be called in
\texttt{\textless{}script\ setup\textgreater{}} or the \texttt{setup()}
hook. They should also be called \textbf{synchronously} in these
contexts. In some cases, you can also call them in lifecycle hooks like
\texttt{onMounted()}.
\switchcolumn
组合式函数只能在 \texttt{\textless{}script\ setup\textgreater{}} 或
\texttt{setup()}
钩子中被调用。在这些上下文中，它们也只能被\textbf{同步}调用。在某些情况下，你也可以在像
\texttt{onMounted()} 这样的生命周期钩子中调用它们。
\switchcolumn[0]*%%%%%%%
These restrictions are important because these are the contexts where
Vue is able to determine the current active component instance. Access
to an active component instance is necessary so that:
\switchcolumn
这些限制很重要，因为这些是 Vue
用于确定当前活跃的组件实例的上下文。访问活跃的组件实例很有必要，这样才能：
\switchcolumn[0]*%%%%%%%
\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Lifecycle hooks can be registered to it.
\item
  Computed properties and watchers can be linked to it, so that they can
  be disposed when the instance is unmounted to prevent memory leaks.
\end{enumerate}
\switchcolumn
\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  将生命周期钩子注册到该组件实例上
\item
  将计算属性和监听器注册到该组件实例上，以便在该组件被卸载时停止监听，避免内存泄漏。
\end{enumerate}
\switchcolumn[0]*%%%%%%%
\begin{codeVue}{TIP}
<script setup> is the only place where you can call composables after using await. The compiler automatically restores the active instance context for you after the async operation.
\end{codeVue}
\switchcolumn
\begin{codeVue}{TIP}
<script setup> 是唯一在调用 await 之后仍可调用组合式函数的地方。编译器会在异步操作之后自动为你恢复当前的组件实例。
\end{codeVue}
\end{paracol}

\columnratio{0.55}
\begin{paracol}{2}

\switchcolumn[0]*%%%%%%%
\subsection{Extracting Composables for Code Organization}
\switchcolumn
\subsection{通过抽取组合式函数改善代码结构}
\switchcolumn[0]*%%%%%%%
Composables can be extracted not only for reuse, but also for code
organization. As the complexity of your components grow, you may end up
with components that are too large to navigate and reason about.
Composition API gives you the full flexibility to organize your
component code into smaller functions based on logical concerns:
\switchcolumn
抽取组合式函数不仅是为了复用，也是为了代码组织。随着组件复杂度的增高，你可能会最终发现组件多得难以查询和理解。组合式
API
会给予你足够的灵活性，让你可以基于逻辑问题将组件代码拆分成更小的函数：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<script setup>
import { useFeatureA } from './featureA.js'
import { useFeatureB } from './featureB.js'
import { useFeatureC } from './featureC.js'
const { foo, bar } = useFeatureA()
const { baz } = useFeatureB(foo)
const { qux } = useFeatureC(baz)
</script>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<script setup>
import { useFeatureA } from './featureA.js'
import { useFeatureB } from './featureB.js'
import { useFeatureC } from './featureC.js'
const { foo, bar } = useFeatureA()
const { baz } = useFeatureB(foo)
const { qux } = useFeatureC(baz)
</script>
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
To some extent, you can think of these extracted composables as
component-scoped services that can talk to one another.
\switchcolumn
在某种程度上，你可以将这些提取出的组合式函数看作是可以相互通信的组件范围内的服务。
\end{paracol}

\columnratio{0.55}
\begin{paracol}{2}
  
\switchcolumn[0]*%%%%%%%
\subsection{Using Composables in Options API}
\switchcolumn
\subsection{在选项式 API 中使用组合式函数}
\switchcolumn[0]*%%%%%%%
If you are using Options API, composables must be called inside
\texttt{setup()}, and the returned bindings must be returned from
\texttt{setup()} so that they are exposed to \texttt{this} and the
template:
\switchcolumn
如果你正在使用选项式 API，组合式函数必须在 \texttt{setup()}
中调用。且其返回的绑定必须在 \texttt{setup()} 中返回，以便暴露给
\texttt{this} 及其模板：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
import { useMouse } from './mouse.js'
import { useFetch } from './fetch.js'
export default {
  setup() {
    const { x, y } = useMouse()
    const { data, error } = useFetch('...')
    return { x, y, data, error }
  },
  mounted() {
    // setup() 暴露的属性可以在通过 `this` 访问到
    console.log(this.x)
  }
  // ...其他选项
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
import { useMouse } from './mouse.js'
import { useFetch } from './fetch.js'
export default {
  setup() {
    const { x, y } = useMouse()
    const { data, error } = useFetch('...')
    return { x, y, data, error }
  },
  mounted() {
    // setup() 暴露的属性可以在通过 `this` 访问到
    console.log(this.x)
  }
  // ...其他选项
}
\end{codeJs}
\end{paracol}

\columnratio{0.55}
\begin{paracol}{2}
 
\switchcolumn[0]*%%%%%%%
\subsection{Comparisons with Other Techniques}
\switchcolumn
\subsection{与其他模式的比较}
\switchcolumn[0]*%%%%%%%
\subsubsection{vs. Mixins}
\switchcolumn
\subsubsection{和 Mixin 的对比}
\switchcolumn[0]*%%%%%%%
Users coming from Vue 2 may be familiar with the
\href{https://vuejs.org/api/options-composition.html\#mixins}{mixins}
option, which also allows us to extract component logic into reusable
units. There are three primary drawbacks to mixins:
\switchcolumn
Vue 2 的用户可能会对
\href{https://cn.vuejs.org/api/options-composition.html\#mixins}{mixins}
选项比较熟悉。它也让我们能够把组件逻辑提取到可复用的单元里。然而 mixins
有三个主要的短板：
\switchcolumn[0]*%%%%%%%
\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Unclear source of properties}: when using many mixins, it
  becomes unclear which instance property is injected by which mixin,
  making it difficult to trace the implementation and understand the
  component's behavior. This is also why we recommend using the refs +
  destructure pattern for composables: it makes the property source
  clear in consuming components.
\item
  \textbf{Namespace collisions}: multiple mixins from different authors
  can potentially register the same property keys, causing namespace
  collisions. With composables, you can rename the destructured
  variables if there are conflicting keys from different composables.
\item
  \textbf{Implicit cross-mixin communication}: multiple mixins that need
  to interact with one another have to rely on shared property keys,
  making them implicitly coupled. With composables, values returned from
  one composable can be passed into another as arguments, just like
  normal functions.
\end{enumerate}
\switchcolumn
\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{不清晰的数据来源}：当使用了多个 mixin
  时，实例上的数据属性来自哪个 mixin
  变得不清晰，这使追溯实现和理解组件行为变得困难。这也是我们推荐在组合式函数中使用
  ref + 解构模式的理由：让属性的来源在消费组件时一目了然。
\item
  \textbf{命名空间冲突}：多个来自不同作者的 mixin
  可能会注册相同的属性名，造成命名冲突。若使用组合式函数，你可以通过在解构变量时对变量进行重命名来避免相同的键名。
\item
  \textbf{隐式的跨 mixin 交流}：多个 mixin
  需要依赖共享的属性名来进行相互作用，这使得它们隐性地耦合在一起。而一个组合式函数的返回值可以作为另一个组合式函数的参数被传入，像普通函数那样。
\end{enumerate}
\switchcolumn[0]*%%%%%%%
For the above reasons, we no longer recommend using mixins in Vue 3. The
feature is kept only for migration and familiarity reasons.
\switchcolumn
基于上述理由，我们不再推荐在 Vue 3 中继续使用
mixin。保留该功能只是为了项目迁移的需求和照顾熟悉它的用户。
\switchcolumn[0]*%%%%%%%
\subsubsection{vs. Renderless Components}
\switchcolumn
\subsubsection{和无渲染组件的对比}
\switchcolumn[0]*%%%%%%%
In the component slots chapter, we discussed the
\href{https://vuejs.org/guide/components/slots.html\#renderless-components}{Renderless
Component} pattern based on scoped slots. We even implemented the same
mouse tracking demo using renderless components.
\switchcolumn
在组件插槽一章中，我们讨论过了基于作用域插槽的\href{https://cn.vuejs.org/guide/components/slots.html\#renderless-components}{无渲染组件}。我们甚至用它实现了一样的鼠标追踪器示例。
\switchcolumn[0]*%%%%%%%
The main advantage of composables over renderless components is that
composables do not incur the extra component instance overhead. When
used across an entire application, the amount of extra component
instances created by the renderless component pattern can become a
noticeable performance overhead.
\switchcolumn
组合式函数相对于无渲染组件的主要优势是：组合式函数不会产生额外的组件实例开销。当在整个应用中使用时，由无渲染组件产生的额外组件实例会带来无法忽视的性能开销。
\switchcolumn[0]*%%%%%%%
The recommendation is to use composables when reusing pure logic, and
use components when reusing both logic and visual layout.
\switchcolumn
我们推荐在纯逻辑复用时使用组合式函数，在需要同时复用逻辑和视图布局时使用无渲染组件。
\end{paracol}

\columnratio{0.55}
\begin{paracol}{2}
 
\switchcolumn[0]*%%%%%%%
\subsubsection{vs. React Hooks}
\switchcolumn
\subsubsection{和 React Hooks 的对比}
\switchcolumn[0]*%%%%%%%
If you have experience with React, you may notice that this looks very
similar to custom React hooks. Composition API was in part inspired by
React hooks, and Vue composables are indeed similar to React hooks in
terms of logic composition capabilities. However, Vue composables are
based on Vue's fine-grained reactivity system, which is fundamentally
different from React hooks' execution model. This is discussed in more
detail in the
\href{https://vuejs.org/guide/extras/composition-api-faq.html\#comparison-with-react-hooks}{Composition
API FAQ}.
\switchcolumn
如果你有 React 的开发经验，你可能注意到组合式函数和自定义 React hooks
非常相似。组合式 API 的一部分灵感正来自于 React hooks，Vue
的组合式函数也的确在逻辑组合能力上与 React hooks 相近。然而，Vue
的组合式函数是基于 Vue 细粒度的响应性系统，这和 React hooks
的执行模型有本质上的不同。这一话题在\href{https://cn.vuejs.org/guide/extras/composition-api-faq.html\#comparison-with-react-hooks}{组合式
API 的常见问题}中有更细致的讨论。
\switchcolumn[0]*%%%%%%%
\subsection{Further Reading}
\switchcolumn
\subsection{延伸阅读}
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  \href{https://vuejs.org/guide/extras/reactivity-in-depth.html}{Reactivity
  In Depth}: for a low-level understanding of how Vue's reactivity
  system works.
\item
  \href{https://vuejs.org/guide/scaling-up/state-management.html}{State
  Management}: for patterns of managing state shared by multiple
  components.
\item
  \href{https://vuejs.org/guide/scaling-up/testing.html\#testing-composables}{Testing
  Composables}: tips on unit testing composables.
\item
  \href{https://vueuse.org/}{VueUse}: an ever-growing collection of Vue
  composables. The source code is also a great learning resource.
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  \href{https://cn.vuejs.org/guide/extras/reactivity-in-depth.html}{深入响应性原理}：理解
  Vue 响应性系统的底层细节。
\item
  \href{https://cn.vuejs.org/guide/scaling-up/state-management.html}{状态管理}：多个组件间共享状态的管理模式。
\item
  \href{https://cn.vuejs.org/guide/scaling-up/testing.html\#testing-composables}{测试组合式函数}：组合式函数的单元测试技巧。
\item
  \href{https://vueuse.org/}{VueUse}：一个日益增长的 Vue
  组合式函数集合。源代码本身就是一份不错的学习资料。
\end{itemize}
\end{paracol} 