\columnratio{0.55}
\begin{paracol}{2}
\switchcolumn[0]*%%%%%%%
\section{Watchers}
\switchcolumn
\section{侦听器}
\switchcolumn[0]*%%%%%%%
\subsection{Basic Example}
\switchcolumn
\subsection{基本示例}
\switchcolumn[0]*%%%%%%%
Computed properties allow us to declaratively compute derived values.
However, there are cases where we need to perform "side effects" in
reaction to state changes - for example, mutating the DOM, or changing
another piece of state based on the result of an async operation.
\switchcolumn
计算属性允许我们声明性地计算衍生值。然而在有些情况下，我们需要在状态变化时执行一些``副作用''：例如更改
DOM，或是根据异步操作的结果去修改另一处的状态。

\switchcolumn[0]*%%%%%%%
With Composition API, we can use the
\href{https://vuejs.org/api/reactivity-core.html\#watch}{\texttt{watch}
function} to trigger a callback whenever a piece of reactive state
changes:
\switchcolumn
在组合式 API 中，我们可以使用
\href{https://cn.vuejs.org/api/reactivity-core.html\#watch}{\texttt{watch}
函数}在每次响应式状态发生变化时触发回调函数：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<script setup>
import { ref, watch } from 'vue'
//
const question = ref('')
const answer = ref('Questions usually contain a question mark. ;-)')
//
// 可以直接侦听一个 ref
watch(question, async (newQuestion, oldQuestion) => {
  if (newQuestion.indexOf('?') > -1) {
    answer.value = 'Thinking...'
    try {
      const res = await fetch('https://yesno.wtf/api')
      answer.value = (await res.json()).answer
    } catch (error) {
      answer.value = 'Error! Could not reach the API. ' + error
    }
  }
})
</script>
//
<template>
  <p>
    Ask a yes/no question:
    <input v-model="question" />
  </p>
  <p>{{ answer }}</p>
</template>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<script setup>
import { ref, watch } from 'vue'
//
const question = ref('')
const answer = ref('Questions usually contain a question mark. ;-)')
//
// 可以直接侦听一个 ref
watch(question, async (newQuestion, oldQuestion) => {
  if (newQuestion.indexOf('?') > -1) {
    answer.value = 'Thinking...'
    try {
      const res = await fetch('https://yesno.wtf/api')
      answer.value = (await res.json()).answer
    } catch (error) {
      answer.value = 'Error! Could not reach the API. ' + error
    }
  }
})
</script>
//
<template>
  <p>
    Ask a yes/no question:
    <input v-model="question" />
  </p>
  <p>{{ answer }}</p>
</template>
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
\href{https://play.vuejs.org/\#eNp9U8Fy0zAQ/ZVFF9tDah96C2mZ0umhHKBAj7oIe52oUSQjyXEyGf87KytyoDC9JPa+p+e3b1cndtd15b5HtmQrV1vZeXDo++6Wa7nrjPVwAovtAgbh6w2M0Fqzg4xOZFxzXRvtPPzq0XlpNNwEbp5lRUKEdgPaVP925jnoXS+UOgKxvJAaxEVjJ+y2hA9XxUVFGdFIvT7LtEI5JIzrqjrbGozdOmikxdqTKqmIQOV6gvOkvQDhjrqGXOOQvCzAqCa9FHBzCyeuAWT7F6uUulZ9gy7PPmZFETmQjJV7oXoke972GJHY+Axkzxupt4FalhRcYHh7TDIQcqA+LTriikFIDy0G59nG+84tq+qITpty8G0lOhmSiedefSaPZ0mnfHFG50VRRkbkj1BPceVorbFzF/+6fQj4O7g3vWpAm6Ao6JzfINw9PZaQwXuYNJJuK/U0z1nxdTLT0M7s8Ec/I3WxquLS0brRi8ddp4RHegNYhR0M/Du3pXFSAJU285osI7aSuus97K92pkF1w1nCOYNlI534qbCh8tkOVasoXkV1+sjplLZ0HGN5Vc1G2IJ5R8Np5XpKlK7J1CJntdl1UqH92k0bzdkyNc8ZRWGGz1MtbMQi1esN1tv/1F/cIdQ4e6LJod0jZzPmhV2jj/DDjy94oOcZpK57Rew3wO/ojOpjJIH2qdcN2f6DN7l9nC47RfTsHg4etUtNpZUeJz5ndPPv32j9Yve6vE6DZuNvu1R2Tg==}{Try
it in the Playground}
\switchcolumn
\href{https://play.vuejs.org/\#eNplkkGPmzAQhf/KKxdA3Rj1mpJUUdVDT22lHrlYxDRuYOzaJjRC/PcdxyGr3b2A7PfmmzcMc3awVlxGlW2z2rdO2wCvwmj3DenBGhcww6nuCZMM7QkLOmcG5FyRN9RQa8gH/BuVD9oQdtFb5Hm5KpL8pNx6/+vu8xj9KPv+CnYFqQnyhTFIdxb4vCkjpaFb32JVnyD9lVoUpKaVVmK3x9wQoLtXgtB0VP9/cOMveYk9Np/K5MM9l7jIflScLv990nTW9EcIwXNFR3DX1YwYk4dxyrNXTlIHdCrGyk8hWL+tqqvyZMQUukpaHYOnujdtilTLHPHXGyrKUiRH8i9obx+5UM4Z98j6Pu23qH/AVzP2R5CJRMl14aRw+PldIMdH3Bh3bnzxY+FcdZW2zPvlQ1CD7WVQfALquPToP/gzL4RHqsg89rJNWq3JjgGXzWCOqt812ao3GaqEqRKHcfO8/gDLkq7r6tEyW54Bf5TTlg==}{在演练场中尝试一下}


\switchcolumn[0]*%%%%%%%
\subsubsection{Watch Source Types}
\switchcolumn
\subsubsection{侦听数据源类型}
\switchcolumn[0]*%%%%%%%
\texttt{watch}'s first argument can be different types of reactive
"sources": it can be a ref (including computed refs), a reactive object,
a getter function, or an array of multiple sources:
\switchcolumn
\texttt{watch} 的第一个参数可以是不同形式的``数据源''：它可以是一个 ref
(包括计算属性)、一个响应式对象、一个 getter
函数、或多个数据源组成的数组：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
const x = ref(0)
const y = ref(0)
//
// 单个 ref
watch(x, (newX) => {
  console.log(`x is ${newX}`)
})
//
// getter 函数
watch(
  () => x.value + y.value,
  (sum) => {
    console.log(`sum of x + y is: ${sum}`)
  }
)
//
// 多个来源组成的数组
watch([x, () => y.value], ([newX, newY]) => {
  console.log(`x is ${newX} and y is ${newY}`)
})
\end{codeJs}
\switchcolumn
\begin{codeJs}
const x = ref(0)
const y = ref(0)
//
// 单个 ref
watch(x, (newX) => {
  console.log(`x is ${newX}`)
})
//
// getter 函数
watch(
  () => x.value + y.value,
  (sum) => {
    console.log(`sum of x + y is: ${sum}`)
  }
)
//
// 多个来源组成的数组
watch([x, () => y.value], ([newX, newY]) => {
  console.log(`x is ${newX} and y is ${newY}`)
})
\end{codeJs}


\switchcolumn[0]*%%%%%%%
Do note that you can't watch a property of a reactive object like this:
\switchcolumn
注意，你不能直接侦听响应式对象的属性值，例如:
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
const obj = reactive({ count: 0 })
//
// 错误，因为 watch() 得到的参数是一个 number
watch(obj.count, (count) => {
  console.log(`count is: ${count}`)
})
\end{codeJs}
\switchcolumn
\begin{codeJs}
const obj = reactive({ count: 0 })
//
// 错误，因为 watch() 得到的参数是一个 number
watch(obj.count, (count) => {
  console.log(`count is: ${count}`)
})
\end{codeJs}
\switchcolumn[0]*%%%%%%%
Instead, use a getter:
\switchcolumn
这里需要用一个返回该属性的 getter 函数：


\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// 提供一个 getter 函数
watch(
  () => obj.count,
  (count) => {
    console.log(`count is: ${count}`)
  }
)
\end{codeJs}
\switchcolumn
\begin{codeJs}
// 提供一个 getter 函数
watch(
  () => obj.count,
  (count) => {
    console.log(`count is: ${count}`)
  }
)
\end{codeJs}
\end{paracol}

\columnratio{0.55}
\begin{paracol}{2}

\switchcolumn[0]*%%%%%%%
\subsection{Deep Watchers}
\switchcolumn
\subsection{深层侦听器}
\switchcolumn[0]*%%%%%%%
When you call \texttt{watch()} directly on a reactive object, it will
implicitly create a deep watcher - the callback will be triggered on all
nested mutations:
\switchcolumn
直接给 \texttt{watch()}
传入一个响应式对象，会隐式地创建一个深层侦听器------该回调函数在所有嵌套的变更时都会被触发：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
const obj = reactive({ count: 0 })
//
watch(obj, (newValue, oldValue) => {
    // 在嵌套的属性变更时触发
    // 注意：`newValue` 此处和 `oldValue` 是相等的
    // 因为它们是同一个对象！
})
//
obj.count++
\end{codeJs}
\switchcolumn
\begin{codeJs}
const obj = reactive({ count: 0 })
//
watch(obj, (newValue, oldValue) => {
    // 在嵌套的属性变更时触发
    // 注意：`newValue` 此处和 `oldValue` 是相等的
    // 因为它们是同一个对象！
})
//
obj.count++
\end{codeJs}


\switchcolumn[0]*%%%%%%%
This should be differentiated with a getter that returns a reactive
object - in the latter case, the callback will only fire if the getter
returns a different object:
\switchcolumn
相比之下，一个返回响应式对象的 getter
函数，只有在返回不同的对象时，才会触发回调：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
watch(
  () => state.someObject,
  () => {
    // 仅当 state.someObject 被替换时触发
  }
)
\end{codeJs}
\switchcolumn
\begin{codeJs}
watch(
  () => state.someObject,
  () => {
    // 仅当 state.someObject 被替换时触发
  }
)
\end{codeJs}
\switchcolumn[0]*%%%%%%%
You can, however, force the second case into a deep watcher by
explicitly using the \texttt{deep} option:
\switchcolumn
你也可以给上面这个例子显式地加上 \texttt{deep}
选项，强制转成深层侦听器：


\switchcolumn[0]*%%%%%%%
\begin{codeJs}
watch(
  () => state.someObject,
  (newValue, oldValue) => {
    // 注意：`newValue` 此处和 `oldValue` 是相等的
    // *除非* state.someObject 被整个替换了
  },
  { deep: true }
)
\end{codeJs}
\switchcolumn
\begin{codeJs}
watch(
  () => state.someObject,
  (newValue, oldValue) => {
    // 注意：`newValue` 此处和 `oldValue` 是相等的
    // *除非* state.someObject 被整个替换了
  },
  { deep: true }
)
\end{codeJs}
\switchcolumn[0]*%%%%%%%
\begin{vueQuoteWarn}{Use with Caution}
Deep watch requires traversing all nested properties in the watched
object, and can be expensive when used on large data structures. Use it
only when necessary and beware of the performance implications.
\end{vueQuoteWarn}
\switchcolumn
\begin{vueQuoteWarn}{谨慎使用}
深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请只在必要时才使用它，并且要留意性能。
\end{vueQuoteWarn}
\end{paracol}

\columnratio{0.55}
\begin{paracol}{2}

\switchcolumn[0]*%%%%%%%
\subsection{Eager Watchers}
\switchcolumn
\subsection{即时回调的侦听器}
\switchcolumn[0]*%%%%%%%
\texttt{watch} is lazy by default: the callback won't be called until
the watched source has changed. But in some cases we may want the same
callback logic to be run eagerly - for example, we may want to fetch
some initial data, and then re-fetch the data whenever relevant state
changes.
\switchcolumn
\texttt{watch}
默认是懒执行的：仅当数据源变化时，才会执行回调。但在某些场景中，我们希望在创建侦听器时，立即执行一遍回调。举例来说，我们想请求一些初始数据，然后在相关状态更改时重新请求数据。
\switchcolumn[0]*%%%%%%%
We can force a watcher's callback to be executed immediately by passing
the \texttt{immediate:\ true} option:
\switchcolumn
我们可以通过传入 \texttt{immediate:\ true}
选项来强制侦听器的回调立即执行：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
watch(source, (newValue, oldValue) => {
    // 立即执行，且当 `source` 改变时再次执行
}, { immediate: true })
\end{codeJs}
\switchcolumn
\begin{codeJs}
watch(source, (newValue, oldValue) => {
    // 立即执行，且当 `source` 改变时再次执行
}, { immediate: true })
\end{codeJs}
\switchcolumn[0]*%%%%%%%
\subsection{watchEffect()}
\switchcolumn
\subsection{watchEffect()}



\switchcolumn[0]*%%%%%%%
It is common for the watcher callback to use exactly the same reactive
state as the source. For example, consider the following code, which
uses a watcher to load a remote resource whenever the \texttt{todoId}
ref changes:
\switchcolumn
侦听器的回调使用与源完全相同的响应式状态是很常见的。例如下面的代码，在每当
\texttt{todoId} 的引用发生变化时使用侦听器来加载一个远程资源：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
const todoId = ref(1)
const data = ref(null)
//
watch(todoId, async () => {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
  )
  data.value = await response.json()
}, { immediate: true })
\end{codeJs}
\switchcolumn
\begin{codeJs}
const todoId = ref(1)
const data = ref(null)
//
watch(todoId, async () => {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
  )
  data.value = await response.json()
}, { immediate: true })
\end{codeJs}
\switchcolumn[0]*%%%%%%%
In particular, notice how the watcher uses \texttt{todoId} twice, once
as the source and then again inside the callback.
\switchcolumn
特别是注意侦听器是如何两次使用 \texttt{todoId}
的，一次是作为源，另一次是在回调中。
\switchcolumn[0]*%%%%%%%
This can be simplified with
\href{https://vuejs.org/api/reactivity-core.html\#watcheffect}{\texttt{watchEffect()}}.
\texttt{watchEffect()} allows us to track the callback's reactive
dependencies automatically. The watcher above can be rewritten as:
\switchcolumn
我们可以用
\href{https://cn.vuejs.org/api/reactivity-core.html\#watcheffect}{\texttt{watchEffect}
函数} 来简化上面的代码。\texttt{watchEffect()}
允许我们自动跟踪回调的响应式依赖。上面的侦听器可以重写为：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
watchEffect(async () => {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
  )
  data.value = await response.json()
})
\end{codeJs}
\switchcolumn
\begin{codeJs}
watchEffect(async () => {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
  )
  data.value = await response.json()
})
\end{codeJs}


\switchcolumn[0]*%%%%%%%
Here, the callback will run immediately, there's no need to specify
\texttt{immediate:\ true}. During its execution, it will automatically
track \texttt{todoId.value} as a dependency (similar to computed
properties). Whenever \texttt{todoId.value} changes, the callback will
be run again. With \texttt{watchEffect()}, we no longer need to pass
\texttt{todoId} explicitly as the source value.
\switchcolumn
这个例子中，回调会立即执行，不需要指定
\texttt{immediate:\ true}。在执行期间，它会自动追踪
\texttt{todoId.value} 作为依赖（和计算属性类似）。每当
\texttt{todoId.value} 变化时，回调会再次执行。有了
\texttt{watchEffect()}，我们不再需要明确传递 \texttt{todoId} 作为源值。
\switchcolumn[0]*%%%%%%%
You can check out \href{https://vuejs.org/examples/\#fetching-data}{this
example} of \texttt{watchEffect()} and reactive data-fetching in action.
\switchcolumn
你可以参考一下\href{https://cn.vuejs.org/examples/\#fetching-data}{这个例子}的
\texttt{watchEffect} 和响应式的数据请求的操作。
\switchcolumn[0]*%%%%%%%
For examples like these, with only one dependency, the benefit of
\texttt{watchEffect()} is relatively small. But for watchers that have
multiple dependencies, using \texttt{watchEffect()} removes the burden
of having to maintain the list of dependencies manually. In addition, if
you need to watch several properties in a nested data structure,
\texttt{watchEffect()} may prove more efficient than a deep watcher, as
it will only track the properties that are used in the callback, rather
than recursively tracking all of them.
\switchcolumn
对于这种只有一个依赖项的例子来说，\texttt{watchEffect()}
的好处相对较小。但是对于有多个依赖项的侦听器来说，使用
\texttt{watchEffect()}
可以消除手动维护依赖列表的负担。此外，如果你需要侦听一个嵌套数据结构中的几个属性，\texttt{watchEffect()}
可能会比深度侦听器更有效，因为它将只跟踪回调中被使用到的属性，而不是递归地跟踪所有的属性。
\switchcolumn[0]*%%%%%%%
\begin{vueQuote}{TIP}
\texttt{watchEffect} only tracks dependencies during its
\textbf{synchronous} execution. When using it with an async callback,
only properties accessed before the first \texttt{await} tick will be
tracked.
\end{vueQuote}
\switchcolumn
\begin{vueQuote}{TIP}
\texttt{watchEffect}
仅会在其\textbf{同步}执行期间，才追踪依赖。在使用异步回调时，只有在第一个
\texttt{await} 正常工作前访问到的属性才会被追踪。
\end{vueQuote}
\end{paracol}

\columnratio{0.55}
\begin{paracol}{2}

\switchcolumn[0]*%%%%%%%
\subsubsection{watch vs. watchEffect}
\switchcolumn
\subsubsection{watch vs. watchEffect}
\switchcolumn[0]*%%%%%%%
\texttt{watch} and \texttt{watchEffect} both allow us to reactively
perform side effects. Their main difference is the way they track their
reactive dependencies:
\switchcolumn
\texttt{watch} 和 \texttt{watchEffect}
都能响应式地执行有副作用的回调。它们之间的主要区别是追踪响应式依赖的方式：
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
    \texttt{watch} only tracks the explicitly watched source. It won't
    track anything accessed inside the callback. In addition, the callback
    only triggers when the source has actually changed. \texttt{watch}
    separates dependency tracking from the side effect, giving us more
    precise control over when the callback should fire.
\item
    \texttt{watchEffect}, on the other hand, combines dependency tracking
    and side effect into one phase. It automatically tracks every reactive
    property accessed during its synchronous execution. This is more
    convenient and typically results in terser code, but makes its
    reactive dependencies less explicit.
\end{itemize}
\switchcolumn
\begin{itemize}
\item
    \texttt{watch}
    只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。\texttt{watch}
    会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。
\item
    \texttt{watchEffect}，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。
\end{itemize}
\switchcolumn[0]*%%%%%%%
\subsection{Callback Flush Timing}
\switchcolumn
\subsection{回调的触发时机}


\switchcolumn[0]*%%%%%%%
When you mutate reactive state, it may trigger both Vue component
updates and watcher callbacks created by you.
\switchcolumn
当你更改了响应式状态，它可能会同时触发 Vue 组件更新和侦听器回调。
\switchcolumn[0]*%%%%%%%
By default, user-created watcher callbacks are called \textbf{before}
Vue component updates. This means if you attempt to access the DOM
inside a watcher callback, the DOM will be in the state before Vue has
applied any updates.
\switchcolumn
默认情况下，用户创建的侦听器回调，都会在 Vue
组件更新\textbf{之前}被调用。这意味着你在侦听器回调中访问的 DOM 将是被
Vue 更新之前的状态。
\switchcolumn[0]*%%%%%%%
If you want to access the DOM in a watcher callback \textbf{after} Vue
has updated it, you need to specify the
\texttt{flush:\ \textquotesingle{}post\textquotesingle{}} option:
\switchcolumn
如果想在侦听器回调中能访问被 Vue 更新\textbf{之后}的 DOM，你需要指明
\texttt{flush:\ \textquotesingle{}post\textquotesingle{}} 选项：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
watch(source, callback, {
  flush: 'post'
})
//
watchEffect(callback, {
  flush: 'post'
})
\end{codeJs}
\switchcolumn
\begin{codeJs}
watch(source, callback, {
  flush: 'post'
})
//
watchEffect(callback, {
  flush: 'post'
})
\end{codeJs}


\switchcolumn[0]*%%%%%%%
Post-flush \texttt{watchEffect()} also has a convenience alias,
\texttt{watchPostEffect()}:
\switchcolumn
后置刷新的 \texttt{watchEffect()} 有个更方便的别名
\texttt{watchPostEffect()}：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
import { watchPostEffect } from 'vue'
//
watchPostEffect(() => {
  /* 在 Vue 更新后执行 */
})
\end{codeJs}
\switchcolumn
\begin{codeJs}
import { watchPostEffect } from 'vue'
//
watchPostEffect(() => {
  /* 在 Vue 更新后执行 */
})
\end{codeJs}
\end{paracol}

\columnratio{0.55}
\begin{paracol}{2}

\switchcolumn[0]*%%%%%%%
\subsection{Stopping a Watcher}
\switchcolumn
\subsection{停止侦听器}
\switchcolumn[0]*%%%%%%%
Watchers declared synchronously inside \texttt{setup()} or
\texttt{\textless{}script\ setup\textgreater{}} are bound to the owner
component instance, and will be automatically stopped when the owner
component is unmounted. In most cases, you don't need to worry about
stopping the watcher yourself.
\switchcolumn
在 \texttt{setup()} 或 \texttt{\textless{}script\ setup\textgreater{}}
中用同步语句创建的侦听器，会自动绑定到宿主组件实例上，并且会在宿主组件卸载时自动停止。因此，在大多数情况下，你无需关心怎么停止一个侦听器。
\switchcolumn[0]*%%%%%%%
The key here is that the watcher must be created \textbf{synchronously}:
if the watcher is created in an async callback, it won't be bound to the
owner component and must be stopped manually to avoid memory leaks.
Here's an example:
\switchcolumn
一个关键点是，侦听器必须用\textbf{同步}语句创建：如果用异步回调创建一个侦听器，那么它不会绑定到当前组件上，你必须手动停止它，以防内存泄漏。如下方这个例子：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<script setup>
import { watchEffect } from 'vue'
//
// 它会自动停止
watchEffect(() => {})
//
// ...这个则不会！
setTimeout(() => {
    watchEffect(() => {})
}, 100)
</script>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<script setup>
import { watchEffect } from 'vue'
//
// 它会自动停止
watchEffect(() => {})
//
// ...这个则不会！
setTimeout(() => {
    watchEffect(() => {})
}, 100)
</script>
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
To manually stop a watcher, use the returned handle function. This works
for both \texttt{watch} and \texttt{watchEffect}:
\switchcolumn
要手动停止一个侦听器，请调用 \texttt{watch} 或 \texttt{watchEffect}
返回的函数：


\switchcolumn[0]*%%%%%%%
\begin{codeJs}
const unwatch = watchEffect(() => {})
//
// ...当该侦听器不再需要时
unwatch()
\end{codeJs}
\switchcolumn
\begin{codeJs}
const unwatch = watchEffect(() => {})
//
// ...当该侦听器不再需要时
unwatch()
\end{codeJs}
\switchcolumn[0]*%%%%%%%
Note that there should be very few cases where you need to create
watchers asynchronously, and synchronous creation should be preferred
whenever possible. If you need to wait for some async data, you can make
your watch logic conditional instead:
\switchcolumn
注意，需要异步创建侦听器的情况很少，请尽可能选择同步创建。如果需要等待一些异步数据，你可以使用条件式的侦听逻辑：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// 需要异步请求得到的数据
const data = ref(null)
//
watchEffect(() => {
  if (data.value) {
    // 数据加载后执行某些操作...
  }
})
\end{codeJs}
\switchcolumn
\begin{codeJs}
// 需要异步请求得到的数据
const data = ref(null)
//
watchEffect(() => {
  if (data.value) {
    // 数据加载后执行某些操作...
  }
})
\end{codeJs}
\end{paracol}

