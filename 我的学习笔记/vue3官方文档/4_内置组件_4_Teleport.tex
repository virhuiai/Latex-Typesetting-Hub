\columnratio{0.55}
\begin{paracol}{2}
\switchcolumn[0]*%%%%%%%
\section{Teleport}
\switchcolumn
\section{Teleport}
\switchcolumn[0]*%%%%%%%
\texttt{\textless{}Teleport\textgreater{}} is a built-in component that
allows us to "teleport" a part of a component's template into a DOM node
that exists outside the DOM hierarchy of that component.
\switchcolumn
\texttt{\textless{}Teleport\textgreater{}}
是一个内置组件，它可以将一个组件内部的一部分模板``传送''到该组件的 DOM
结构外层的位置去。
\switchcolumn[0]*%%%%%%%
\subsection{Basic Usage}
\switchcolumn
\subsection{基本用法}
\switchcolumn[0]*%%%%%%%
Sometimes we may run into the following scenario: a part of a
component's template belongs to it logically, but from a visual
standpoint, it should be displayed somewhere else in the DOM, outside of
the Vue application.
\switchcolumn
有时我们可能会遇到这样的场景：一个组件模板的一部分在逻辑上从属于该组件，但从整个应用视图的角度来看，它在
DOM 中应该被渲染在整个 Vue 应用外部的其他地方。
\switchcolumn[0]*%%%%%%%
The most common example of this is when building a full-screen modal.
Ideally, we want the modal's button and the modal itself to live within
the same component, since they are both related to the open / close
state of the modal. But that means the modal will be rendered alongside
the button, deeply nested in the application's DOM hierarchy. This can
create some tricky issues when positioning the modal via CSS.
\switchcolumn
这类场景最常见的例子就是全屏的模态框。理想情况下，我们希望触发模态框的按钮和模态框本身是在同一个组件中，因为它们都与组件的开关状态有关。但这意味着该模态框将与按钮一起渲染在应用
DOM 结构里很深的地方。这会导致该模态框的 CSS 布局代码很难写。
\switchcolumn[0]*%%%%%%%
Consider the following HTML structure.
\switchcolumn
试想下面这样的 HTML 结构：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<div class="outer">
  <h3>Tooltips with Vue 3 Teleport</h3>
  <div>
    <MyModal />
  </div>
</div>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<div class="outer">
  <h3>Tooltips with Vue 3 Teleport</h3>
  <div>
    <MyModal />
  </div>
</div>
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
And here is the implementation of
\texttt{\textless{}MyModal\textgreater{}}:
\switchcolumn
接下来我们来看看 \texttt{\textless{}MyModal\textgreater{}} 的实现：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<script setup>
import { ref } from 'vue'
const open = ref(false)
</script>
<template>
  <button @click="open = true">Open Modal</button>
  <div v-if="open" class="modal">
    <p>Hello from the modal!</p>
    <button @click="open = false">Close</button>
  </div>
</template>
<style scoped>
.modal {
  position: fixed;
  z-index: 999;
  top: 20%;
  left: 50%;
  width: 300px;
  margin-left: -150px;
}
</style>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<script setup>
import { ref } from 'vue'
const open = ref(false)
</script>
<template>
  <button @click="open = true">Open Modal</button>
  <div v-if="open" class="modal">
    <p>Hello from the modal!</p>
    <button @click="open = false">Close</button>
  </div>
</template>
<style scoped>
.modal {
  position: fixed;
  z-index: 999;
  top: 20%;
  left: 50%;
  width: 300px;
  margin-left: -150px;
}
</style>
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
The component contains a \texttt{\textless{}button\textgreater{}} to
trigger the opening of the modal, and a
\texttt{\textless{}div\textgreater{}} with a class of \texttt{.modal},
which will contain the modal's content and a button to self-close.
\switchcolumn
这个组件中有一个 \texttt{\textless{}button\textgreater{}}
按钮来触发打开模态框，和一个 class 名为 \texttt{.modal} 的
\texttt{\textless{}div\textgreater{}}，它包含了模态框的内容和一个用来关闭的按钮。
\switchcolumn[0]*%%%%%%%
When using this component inside the initial HTML structure, there are a
number of potential issues:
\switchcolumn
当在初始 HTML 结构中使用这个组件时，会有一些潜在的问题：
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  \texttt{position:\ fixed} only places the element relative to the
  viewport when no ancestor element has \texttt{transform},
  \texttt{perspective} or \texttt{filter} property set. If, for example,
  we intend to animate the ancestor
  \texttt{\textless{}div\ class="outer"\textgreater{}} with a CSS
  transform, it would break the modal layout!
\item
  The modal's \texttt{z-index} is constrained by its containing
  elements. If there is another element that overlaps with
  \texttt{\textless{}div\ class="outer"\textgreater{}} and has a higher
  \texttt{z-index}, it would cover our modal.
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  \texttt{position:\ fixed}
  能够相对于浏览器窗口放置有一个条件，那就是不能有任何祖先元素设置了
  \texttt{transform}、\texttt{perspective} 或者 \texttt{filter}
  样式属性。也就是说如果我们想要用 CSS \texttt{transform} 为祖先节点
  \texttt{\textless{}div\ class="outer"\textgreater{}}
  设置动画，就会不小心破坏模态框的布局！
\item
  这个模态框的 \texttt{z-index} 受限于它的容器元素。如果有其他元素与
  \texttt{\textless{}div\ class="outer"\textgreater{}} 重叠并有更高的
  \texttt{z-index}，则它会覆盖住我们的模态框。
\end{itemize}
\switchcolumn[0]*%%%%%%%
\texttt{\textless{}Teleport\textgreater{}} provides a clean way to work
around these, by allowing us to break out of the nested DOM structure.
Let's modify \texttt{\textless{}MyModal\textgreater{}} to use
\texttt{\textless{}Teleport\textgreater{}}:
\switchcolumn
\texttt{\textless{}Teleport\textgreater{}}
提供了一个更简单的方式来解决此类问题，让我们不需要再顾虑 DOM
结构的问题。让我们用 \texttt{\textless{}Teleport\textgreater{}} 改写一下
\texttt{\textless{}MyModal\textgreater{}}：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<button @click="open = true">Open Modal</button>
<Teleport to="body">
  <div v-if="open" class="modal">
    <p>Hello from the modal!</p>
    <button @click="open = false">Close</button>
  </div>
</Teleport>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<button @click="open = true">Open Modal</button>
<Teleport to="body">
  <div v-if="open" class="modal">
    <p>Hello from the modal!</p>
    <button @click="open = false">Close</button>
  </div>
</Teleport>
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
The \texttt{to} target of \texttt{\textless{}Teleport\textgreater{}}
expects a CSS selector string or an actual DOM node. Here, we are
essentially telling Vue to "\textbf{teleport} this template fragment
\textbf{to} the \textbf{\texttt{body}} tag".
\switchcolumn
\texttt{\textless{}Teleport\textgreater{}} 接收一个 \texttt{to} prop
来指定传送的目标。\texttt{to} 的值可以是一个 CSS
选择器字符串，也可以是一个 DOM 元素对象。这段代码的作用就是告诉
Vue``把以下模板片段\textbf{传送到 \texttt{body}} 标签下''。
\switchcolumn[0]*%%%%%%%
You can click the button below and inspect the
\texttt{\textless{}body\textgreater{}} tag via your browser's devtools:
\switchcolumn
你可以点击下面这个按钮，然后通过浏览器的开发者工具，在
\texttt{\textless{}body\textgreater{}} 标签下找到模态框元素：
\switchcolumn[0]*%%%%%%%
You can combine \texttt{\textless{}Teleport\textgreater{}} with
\href{https://vuejs.org/guide/built-ins/transition.html}{``} to create
animated modals - see \href{https://vuejs.org/examples/\#modal}{Example
here}.
\switchcolumn
我们也可以将 \texttt{\textless{}Teleport\textgreater{}} 和
\href{https://cn.vuejs.org/guide/built-ins/transition.html}{``}
结合使用来创建一个带动画的模态框。你可以看看\href{https://cn.vuejs.org/examples/\#modal}{这个示例}。
\switchcolumn[0]*%%%%%%%
\begin{vueQuote}{TIP}
The teleport \texttt{to} target must be already in the DOM when the
\texttt{\textless{}Teleport\textgreater{}} component is mounted.
Ideally, this should be an element outside the entire Vue application.
If targeting another element rendered by Vue, you need to make sure that
element is mounted before the
\texttt{\textless{}Teleport\textgreater{}}.
\end{vueQuote} 
\switchcolumn
\begin{vueQuote}{TIP}
\texttt{\textless{}Teleport\textgreater{}} 挂载时，传送的 \texttt{to}
目标必须已经存在于 DOM 中。理想情况下，这应该是整个 Vue 应用 DOM
树外部的一个元素。如果目标元素也是由 Vue 渲染的，你需要确保在挂载
\texttt{\textless{}Teleport\textgreater{}} 之前先挂载该元素。
\end{vueQuote} 
\end{paracol}

\columnratio{0.55}
\begin{paracol}{2}
 
\switchcolumn[0]*%%%%%%%
\subsection{Using with Components}
\switchcolumn
\subsection{搭配组件使用}
\switchcolumn[0]*%%%%%%%
\texttt{\textless{}Teleport\textgreater{}} only alters the rendered DOM
structure - it does not affect the logical hierarchy of the components.
That is to say, if \texttt{\textless{}Teleport\textgreater{}} contains a
component, that component will remain a logical child of the parent
component containing the \texttt{\textless{}Teleport\textgreater{}}.
Props passing and event emitting will continue to work the same way.
\switchcolumn
\texttt{\textless{}Teleport\textgreater{}} 只改变了渲染的 DOM
结构，它不会影响组件间的逻辑关系。也就是说，如果
\texttt{\textless{}Teleport\textgreater{}}
包含了一个组件，那么该组件始终和这个使用了
\texttt{\textless{}teleport\textgreater{}}
的组件保持逻辑上的父子关系。传入的 props 和触发的事件也会照常工作。
\switchcolumn[0]*%%%%%%%
This also means that injections from a parent component work as
expected, and that the child component will be nested below the parent
component in the Vue Devtools, instead of being placed where the actual
content moved to.
\switchcolumn
这也意味着来自父组件的注入也会按预期工作，子组件将在 Vue Devtools
中嵌套在父级组件下面，而不是放在实际内容移动到的地方。
\switchcolumn[0]*%%%%%%%
\subsection{Disabling Teleport}
\switchcolumn
\subsection{禁用 Teleport}
\switchcolumn[0]*%%%%%%%
In some cases, we may want to conditionally disable
\texttt{\textless{}Teleport\textgreater{}}. For example, we may want to
render a component as an overlay for desktop, but inline on mobile.
\texttt{\textless{}Teleport\textgreater{}} supports the
\texttt{disabled} prop which can be dynamically toggled:
\switchcolumn
在某些场景下可能需要视情况禁用
\texttt{\textless{}Teleport\textgreater{}}。举例来说，我们想要在桌面端将一个组件当做浮层来渲染，但在移动端则当作行内组件。我们可以通过对
\texttt{\textless{}Teleport\textgreater{}} 动态地传入一个
\texttt{disabled} prop 来处理这两种不同情况。
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<Teleport :disabled="isMobile">
  ...
</Teleport>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<Teleport :disabled="isMobile">
  ...
</Teleport>
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
Where the \texttt{isMobile} state can be dynamically updated by
detecting media query changes.
\switchcolumn
这里的 \texttt{isMobile} 状态可以根据 CSS media query
的不同结果动态地更新。
\switchcolumn[0]*%%%%%%%
\subsection{Multiple Teleports on the Same Target}
\switchcolumn
\subsection{多个 Teleport 共享目标}
\switchcolumn[0]*%%%%%%%
A common use case would be a reusable
\texttt{\textless{}Modal\textgreater{}} component, with the potential
for multiple instances to be active at the same time. For this kind of
scenario, multiple \texttt{\textless{}Teleport\textgreater{}} components
can mount their content to the same target element. The order will be a
simple append - later mounts will be located after earlier ones within
the target element.
\switchcolumn
一个可重用的模态框组件可能同时存在多个实例。对于此类场景，多个
\texttt{\textless{}Teleport\textgreater{}}
组件可以将其内容挂载在同一个目标元素上，而顺序就是简单的顺次追加，后挂载的将排在目标元素下更后面的位置上。
\switchcolumn[0]*%%%%%%%
Given the following usage:
\switchcolumn
比如下面这样的用例：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<Teleport to="#modals">
  <div>A</div>
</Teleport>
<Teleport to="#modals">
  <div>B</div>
</Teleport>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<Teleport to="#modals">
  <div>A</div>
</Teleport>
<Teleport to="#modals">
  <div>B</div>
</Teleport>
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
The rendered result would be:
\switchcolumn
渲染的结果为：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<div id="modals">
  <div>A</div>
  <div>B</div>
</div>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<div id="modals">
  <div>A</div>
  <div>B</div>
</div>
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}
\switchcolumn
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}
\switchcolumn[0]*%%%%%%%
\textbf{Related}
\switchcolumn
\textbf{参考}
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  \href{https://vuejs.org/api/built-in-components.html\#teleport}{`` API
  reference}
\item
  \href{https://vuejs.org/guide/scaling-up/ssr.html\#teleports}{Handling
  Teleports in SSR}
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  \href{https://cn.vuejs.org/api/built-in-components.html\#teleport}{``
  API 参考}
\item
  \href{https://cn.vuejs.org/guide/scaling-up/ssr.html\#teleports}{在
  SSR 中处理 Teleports}
\end{itemize}
\end{paracol}
 