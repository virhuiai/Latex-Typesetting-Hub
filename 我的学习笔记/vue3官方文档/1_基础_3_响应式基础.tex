\columnratio{0.55}
\begin{paracol}{2}
\switchcolumn[0]*%%%%%%%
\section{Reactivity Fundamentals}
\switchcolumn
\section{响应式基础}
\switchcolumn[0]*%%%%%%%
\begin{vueQuote}{API Preference}
This page and many other chapters later in the guide contain different
content for the Options API and the Composition API. Your current
preference is Composition API. You can toggle between the API styles
using the "API Preference" switches at the top of the left sidebar.
\end{vueQuote} 
\switchcolumn
\begin{vueQuote}{API 参考}
本页和后面很多页面中都分别包含了选项式 API 和组合式 API
的示例代码。现在你选择的是 组合式 API。你可以使用左侧侧边栏顶部的 ``API
风格偏好'' 开关在 API 风格之间切换。
\end{vueQuote} 
\switchcolumn[0]*%%%%%%%
\subsection{Declaring Reactive State}
\switchcolumn
\subsection{声明响应式状态}
\switchcolumn[0]*%%%%%%%
\subsubsection{ref()}
\switchcolumn
\subsubsection{ref()}
\switchcolumn[0]*%%%%%%%
In Composition API, the recommended way to declare reactive state is
using the
\href{https://vuejs.org/api/reactivity-core.html\#ref}{\texttt{ref()}}
function:
\switchcolumn
在组合式 API 中，推荐使用
\href{https://cn.vuejs.org/api/reactivity-core.html\#ref}{\texttt{ref()}}
函数来声明响应式状态：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
import { ref } from 'vue'

const count = ref(0)
\end{codeJs}
\switchcolumn
\begin{codeJs}
import { ref } from 'vue'

const count = ref(0)
\end{codeJs}
\switchcolumn[0]*%%%%%%%
\texttt{ref()} takes the argument and returns it wrapped within a ref
object with a \texttt{.value} property:
\switchcolumn
\texttt{ref()} 接收参数，并将其包裹在一个带有 \texttt{.value} 属性的 ref
对象中返回：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
const count = ref(0)

console.log(count) // { value: 0 }
console.log(count.value) // 0

count.value++
console.log(count.value) // 1
\end{codeJs}
\switchcolumn
\begin{codeJs}
const count = ref(0)

console.log(count) // { value: 0 }
console.log(count.value) // 0

count.value++
console.log(count.value) // 1
\end{codeJs}

\switchcolumn[0]*%%%%%%%
\begin{quote}
See also:
\href{https://vuejs.org/guide/typescript/composition-api.html\#typing-ref}{Typing
Refs}
\end{quote}
\switchcolumn
\begin{quote}
参考：\href{https://cn.vuejs.org/guide/typescript/composition-api.html\#typing-ref}{为
refs 标注类型}
\end{quote}
\switchcolumn[0]*%%%%%%%
To access refs in a component's template, declare and return them from a
component's \texttt{setup()} function:
\switchcolumn
要在组件模板中访问 ref，请从组件的 \texttt{setup()}
函数中声明并返回它们：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
import { ref } from 'vue'

export default {
    // `setup` 是一个特殊的钩子，专门用于组合式 API。
    setup() {
    const count = ref(0)

    // 将 ref 暴露给模板
    return {
        count
    }
    }
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
import { ref } from 'vue'

export default {
    // `setup` 是一个特殊的钩子，专门用于组合式 API。
    setup() {
    const count = ref(0)

    // 将 ref 暴露给模板
    return {
        count
    }
    }
}
\end{codeJs}
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<div>{{ count }}</div>
\end{codeHtml}  
\switchcolumn
\begin{codeHtml}
<div>{{ count }}</div>
\end{codeHtml}  

\switchcolumn[0]*%%%%%%%
Notice that we did \textbf{not} need to append \texttt{.value} when
using the ref in the template. For convenience, refs are automatically
unwrapped when used inside templates (with a few
\href{https://vuejs.org/guide/essentials/reactivity-fundamentals.html\#caveat-when-unwrapping-in-templates}{caveats}).
\switchcolumn
注意，在模板中使用 ref 时，我们\textbf{不}需要附加
\texttt{.value}。为了方便起见，当在模板中使用时，ref 会自动解包
(有一些\href{https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html\#caveat-when-unwrapping-in-templates}{注意事项})。
\switchcolumn[0]*%%%%%%%
You can also mutate a ref directly in event handlers:
\switchcolumn
你也可以直接在事件监听器中改变一个 ref：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<button @click="count++">
{{ count }}
</button>
\end{codeHtml}  
\switchcolumn
\begin{codeHtml}
<button @click="count++">
{{ count }}
</button>
\end{codeHtml}  

\switchcolumn[0]*%%%%%%%
For more complex logic, we can declare functions that mutate refs in the
same scope and expose them as methods alongside the state:
\switchcolumn
对于更复杂的逻辑，我们可以在同一作用域内声明更改 ref
的函数，并将它们作为方法与状态一起公开：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
import { ref } from 'vue'

export default {
    setup() {
    const count = ref(0)

    function increment() {
        // .value is needed in JavaScript
        count.value++
    }

    // don't forget to expose the function as well.
    return {
        count,
        increment
    }
    }
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
import { ref } from 'vue'

export default {
    setup() {
    const count = ref(0)

    function increment() {
        // 在 JavaScript 中需要 .value
        count.value++
    }

    // 不要忘记同时暴露 increment 函数
    return {
        count,
        increment
    }
    }
}
\end{codeJs}

\switchcolumn[0]*%%%%%%%
Exposed methods can then be used as event handlers:
\switchcolumn
然后，暴露的方法可以被用作事件监听器：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<button @click="increment">
{{ count }}
</button>
\end{codeHtml}  
\switchcolumn
\begin{codeHtml}
<button @click="increment">
{{ count }}
</button>
\end{codeHtml}  
\switchcolumn[0]*%%%%%%%
Here's the example live on
\href{https://codepen.io/vuejs-examples/pen/WNYbaqo}{Codepen}, without
using any build tools.
\switchcolumn
这里是 \href{https://codepen.io/vuejs-examples/pen/WNYbaqo}{Codepen}
上的例子，没有使用任何构建工具。
\switchcolumn[0]*%%%%%%%
\subsubsection{\textless script setup\textgreater{}}
\switchcolumn
\subsubsection{\textless script setup\textgreater{}}
\switchcolumn[0]*%%%%%%%
Manually exposing state and methods via \texttt{setup()} can be verbose.
Luckily, it can be avoided when using
\href{https://vuejs.org/guide/scaling-up/sfc.html}{Single-File
Components (SFCs)}. We can simplify the usage with
\texttt{\textless{}script\ setup\textgreater{}}:
\switchcolumn
在 \texttt{setup()}
函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过使用\href{https://cn.vuejs.org/guide/scaling-up/sfc.html}{单文件组件
(SFC)} 来避免这种情况。我们可以使用
\texttt{\textless{}script\ setup\textgreater{}} 来大幅度地简化代码：
\switchcolumn[0]*%%%%%%%
\begin{codeVue}
<script setup>
import { ref } from 'vue'

const count = ref(0)

function increment() {
    count.value++
}
</script>

<template>
    <button @click="increment">
    {{ count }}
    </button>
</template>
\end{codeVue}
\switchcolumn
\begin{codeVue}
<script setup>
import { ref } from 'vue'

const count = ref(0)

function increment() {
    count.value++
}
</script>

<template>
    <button @click="increment">
    {{ count }}
    </button>
</template>
\end{codeVue}
\switchcolumn[0]*%%%%%%%
\href{https://play.vuejs.org/\#eNo9jUEKgzAQRa8yZKMiaNcllvYe2dgwQqiZhDhxE3L3jrW4/DPvv1/UK8Zhz6juSm82uciwIef4MOR8DImhQMIFKiwpeGgEbQwZsoE2BhsyMUwH0d66475ksuwCgSOb0CNx20ExBCc77POase8NVUN6PBdlSwKjj+vMKAlAvzOzWJ52dfYzGXXpjPoBAKX856uopDGeFfnq8XKp+gWq4FAi}{Try
it in the Playground}
\switchcolumn
\href{https://play.vuejs.org/\#eNo9jUEKgzAQRa8yZKMiaNcllvYe2dgwQqiZhDhxE3L3jrW4/DPvv1/UK8Zhz6juSm82uciwIef4MOR8DImhQMIFKiwpeGgEbQwZsoE2BhsyMUwH0d66475ksuwCgSOb0CNx20ExBCc77POase8NVUN6PBdlSwKjj+vMKAlAvzOzWJ52dfYzGXXpjPoBAKX856uopDGeFfnq8XKp+gWq4FAi}{在演练场中尝试一下}
\switchcolumn[0]*%%%%%%%
Top-level imports, variables and functions declared in
\texttt{\textless{}script\ setup\textgreater{}} are automatically usable
in the template of the same component. Think of the template as a
JavaScript function declared in the same scope - it naturally has access
to everything declared alongside it.
\switchcolumn
\texttt{\textless{}script\ setup\textgreater{}} 中的顶层的导入、声明的变量和函数可在同一组件的模板中直接使用。你可以理解为模板是在同一作用域内声明的一个 JavaScript 函数——它自然可以访问与它一起声明的所有内容。
\switchcolumn[0]*%%%%%%%
\begin{vueQuote}{TIP}
For the rest of the guide, we will be primarily using SFC +
\texttt{\textless{}script\ setup\textgreater{}} syntax for the
Composition API code examples, as that is the most common usage for Vue
developers.

If you are not using SFC, you can still use Composition API with the
\href{https://vuejs.org/api/composition-api-setup.html}{\texttt{setup()}}
option.
\end{vueQuote} 
\switchcolumn
\begin{vueQuote}{TIP}
在指南的后续章节中，我们基本上都会在组合式 API 示例中使用单文件组件 +
\texttt{\textless{}script\ setup\textgreater{}} 的语法，因为大多数 Vue
开发者都会这样使用。

如果你没有使用单文件组件，你仍然可以在
\href{https://cn.vuejs.org/api/composition-api-setup.html}{\texttt{setup()}}
选项中使用组合式 API。
\end{vueQuote} 

\switchcolumn[0]*%%%%%%%
\subsubsection{Why Refs?}
\switchcolumn
\subsubsection{为什么要使用 ref？}
\switchcolumn[0]*%%%%%%%
You might be wondering why we need refs with the \texttt{.value} instead
of plain variables. To explain that, we will need to briefly discuss how
Vue's reactivity system works.
\switchcolumn
你可能会好奇：为什么我们需要使用带有 \texttt{.value} 的
ref，而不是普通的变量？为了解释这一点，我们需要简单地讨论一下 Vue
的响应式系统是如何工作的。
\switchcolumn[0]*%%%%%%%
When you use a ref in a template, and change the ref's value later, Vue
automatically detects the change and updates the DOM accordingly. This
is made possible with a dependency-tracking based reactivity system.
When a component is rendered for the first time, Vue \textbf{tracks}
every ref that was used during the render. Later on, when a ref is
mutated, it will \textbf{trigger} a re-render for components that are
tracking it.
\switchcolumn
当你在模板中使用了一个 ref，然后改变了这个 ref 的值时，Vue
会自动检测到这个变化，并且相应地更新
DOM。这是通过一个基于依赖追踪的响应式系统实现的。当一个组件首次渲染时，Vue
会\textbf{追踪}在渲染过程中使用的每一个 ref。然后，当一个 ref
被修改时，它会\textbf{触发}追踪它的组件的一次重新渲染。
\switchcolumn[0]*%%%%%%%
In standard JavaScript, there is no way to detect the access or mutation
of plain variables. However, we can intercept the get and set operations
of an object's properties using getter and setter methods.
\switchcolumn
在标准的 JavaScript
中，检测普通变量的访问或修改是行不通的。然而，我们可以通过 getter 和
setter 方法来拦截对象属性的 get 和 set 操作。
\switchcolumn[0]*%%%%%%%
The \texttt{.value} property gives Vue the opportunity to detect when a
ref has been accessed or mutated. Under the hood, Vue performs the
tracking in its getter, and performs triggering in its setter.
Conceptually, you can think of a ref as an object that looks like this:
\switchcolumn
该 \texttt{.value} 属性给予了 Vue 一个机会来检测 ref
何时被访问或修改。在其内部，Vue 在它的 getter 中执行追踪，在它的 setter
中执行触发。从概念上讲，你可以将 ref 看作是一个像这样的对象：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
%
\end{codeJs}
\switchcolumn
\begin{codeJs}
%
\end{codeJs}

\end{paracol}



\end{document}]%%%%%%%]*%%%%%%%]*%%%%%%%]*%%%%%%%]*%%%%%%%]*%%%%%%%]*%%%%%%%]*%%%%%%%]*%%%%%%%]*%%%%%%%
\switchcolumn[0]*%%%%%%%
\begin{vueQuote}{}
\end{vueQuote} 
\switchcolumn
\begin{vueQuote}{}
\end{vueQuote} 




\switchcolumn[0]*%%%%%%%
\begin{codeHtml}

\end{codeHtml}  
\switchcolumn
\begin{codeHtml}

\end{codeHtml}  