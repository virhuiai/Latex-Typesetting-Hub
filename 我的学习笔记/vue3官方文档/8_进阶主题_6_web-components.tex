
\columnratio{0.55}
\begin{paracol}{2} 
\switchcolumn[0]*%%%%%%%
\section{Vue and Web Components}
\switchcolumn
\section{Vue 与 Web Components}
\switchcolumn[0]*%%%%%%%
\href{https://developer.mozilla.org/en-US/docs/Web/Web_Components}{Web
Components} is an umbrella term for a set of web native APIs that allows
developers to create reusable custom elements.
\switchcolumn
\href{https://developer.mozilla.org/en-US/docs/Web/Web_Components}{Web
Components} 是一组 web 原生 API 的统称，允许开发者创建可复用的自定义元素
(custom elements)。
\switchcolumn[0]*%%%%%%%
We consider Vue and Web Components to be primarily complementary
technologies. Vue has excellent support for both consuming and creating
custom elements. Whether you are integrating custom elements into an
existing Vue application, or using Vue to build and distribute custom
elements, you are in good company.
\switchcolumn
我们认为 Vue 和 Web Components 是互补的技术。Vue
为使用和创建自定义元素提供了出色的支持。无论你是将自定义元素集成到现有的
Vue 应用中，还是使用 Vue 来构建和分发自定义元素都很方便。
\switchcolumn[0]*%%%%%%%
\subsection{Using Custom Elements in Vue}
\switchcolumn
\subsection{在 Vue 中使用自定义元素}
\switchcolumn[0]*%%%%%%%
Vue
\href{https://custom-elements-everywhere.com/libraries/vue/results/results.html}{scores
a perfect 100\% in the Custom Elements Everywhere tests}. Consuming
custom elements inside a Vue application largely works the same as using
native HTML elements, with a few things to keep in mind:
\switchcolumn
Vue
\href{https://custom-elements-everywhere.com/libraries/vue/results/results.html}{在
Custom Elements Everywhere 测试中取得了 100\% 的分数}。在 Vue
应用中使用自定义元素基本上与使用原生 HTML
元素的效果相同，但需要留意以下几点：
\switchcolumn[0]*%%%%%%%
\subsubsection{Skipping Component Resolution}
\switchcolumn
\subsubsection{跳过组件解析}
\switchcolumn[0]*%%%%%%%
By default, Vue will attempt to resolve a non-native HTML tag as a
registered Vue component before falling back to rendering it as a custom
element. This will cause Vue to emit a "failed to resolve component"
warning during development. To let Vue know that certain elements should
be treated as custom elements and skip component resolution, we can
specify the
\href{https://vuejs.org/api/application.html\#app-config-compileroptions}{\texttt{compilerOptions.isCustomElement}
option}.
\switchcolumn
默认情况下，Vue 会将任何非原生的 HTML 标签优先当作 Vue
组件处理，而将``渲染一个自定义元素''作为后备选项。这会在开发时导致 Vue
抛出一个``解析组件失败''的警告。要让 Vue
知晓特定元素应该被视为自定义元素并跳过组件解析，我们可以指定
\href{https://cn.vuejs.org/api/application.html\#app-config-compileroptions}{\texttt{compilerOptions.isCustomElement}
这个选项}。
\switchcolumn[0]*%%%%%%%
If you are using Vue with a build setup, the option should be passed via
build configs since it is a compile-time option.
\switchcolumn
如果在开发 Vue
应用时进行了构建配置，则应该在构建配置中传递该选项，因为它是一个编译时选项。
\switchcolumn[0]*%%%%%%%
\textbf{Example In-Browser Config}
\switchcolumn
\textbf{浏览器内编译时的示例配置}
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// 仅在浏览器内编译时才会工作
// 如果使用了构建工具，请看下面的配置示例
app.config.compilerOptions.isCustomElement = (tag) => tag.includes('-')
\end{codeJs}
\switchcolumn
\begin{codeJs}
// 仅在浏览器内编译时才会工作
// 如果使用了构建工具，请看下面的配置示例
app.config.compilerOptions.isCustomElement = (tag) => tag.includes('-')
\end{codeJs}
\switchcolumn[0]*%%%%%%%
\textbf{Example Vite Config}
\switchcolumn
\textbf{Vite 示例配置}
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// vite.config.js
import vue from '@vitejs/plugin-vue'
export default {
  plugins: [
    vue({
      template: {
        compilerOptions: {
          // 将所有带短横线的标签名都视为自定义元素
          isCustomElement: (tag) => tag.includes('-')
        }
      }
    })
  ]
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
// vite.config.js
import vue from '@vitejs/plugin-vue'
export default {
  plugins: [
    vue({
      template: {
        compilerOptions: {
          // 将所有带短横线的标签名都视为自定义元素
          isCustomElement: (tag) => tag.includes('-')
        }
      }
    })
  ]
}
\end{codeJs}
\switchcolumn[0]*%%%%%%%
\textbf{Example Vue CLI Config}
\switchcolumn
\textbf{Vue CLI 示例配置}
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
// vue.config.js
module.exports = {
  chainWebpack: config => {
    config.module
      .rule('vue')
      .use('vue-loader')
      .tap(options => ({
        ...options,
        compilerOptions: {
          // 将所有以 ion- 开头的标签都视为自定义元素
          isCustomElement: tag => tag.startsWith('ion-')
        }
      }))
  }
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
// vue.config.js
module.exports = {
  chainWebpack: config => {
    config.module
      .rule('vue')
      .use('vue-loader')
      .tap(options => ({
        ...options,
        compilerOptions: {
          // 将所有以 ion- 开头的标签都视为自定义元素
          isCustomElement: tag => tag.startsWith('ion-')
        }
      }))
  }
}
\end{codeJs}
\switchcolumn[0]*%%%%%%%
\subsubsection{Passing DOM Properties}
\switchcolumn
\subsubsection{传递 DOM 属性}
\switchcolumn[0]*%%%%%%%
Since DOM attributes can only be strings, we need to pass complex data
to custom elements as DOM properties. When setting props on a custom
element, Vue 3 automatically checks DOM-property presence using the
\texttt{in} operator and will prefer setting the value as a DOM property
if the key is present. This means that, in most cases, you won't need to
think about this if the custom element follows the
\href{https://web.dev/custom-elements-best-practices/}{recommended best
practices}.
\switchcolumn
由于 DOM attribute 只能为字符串值，因此我们只能使用 DOM
对象的属性来传递复杂数据。当为自定义元素设置 props 时，Vue 3 将通过
\texttt{in} 操作符自动检查该属性是否已经存在于 DOM 对象上，并且在这个
key 存在时，更倾向于将值设置为一个 DOM
对象的属性。这意味着，在大多数情况下，如果自定义元素遵循\href{https://web.dev/custom-elements-best-practices/}{推荐的最佳实践}，你就不需要考虑这个问题。
\switchcolumn[0]*%%%%%%%
However, there could be rare cases where the data must be passed as a
DOM property, but the custom element does not properly define/reflect
the property (causing the \texttt{in} check to fail). In this case, you
can force a \texttt{v-bind} binding to be set as a DOM property using
the \texttt{.prop} modifier:
\switchcolumn
然而，也会有一些特别的情况：必须将数据以一个 DOM
对象属性的方式传递，但该自定义元素无法正确地定义/反射这个属性 (因为
\texttt{in} 检查失败)。在这种情况下，你可以强制使用一个 \texttt{v-bind}
绑定、通过 \texttt{.prop} 修饰符来设置该 DOM 对象的属性：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<my-element :user.prop="{ name: 'jack' }"></my-element>
<!-- 等价简写 -->
<my-element .user="{ name: 'jack' }"></my-element>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<my-element :user.prop="{ name: 'jack' }"></my-element>
<!-- 等价简写 -->
<my-element .user="{ name: 'jack' }"></my-element>
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
\subsection{Building Custom Elements with Vue}
\switchcolumn
\subsection{使用 Vue 构建自定义元素}
\switchcolumn[0]*%%%%%%%
The primary benefit of custom elements is that they can be used with any
framework, or even without a framework. This makes them ideal for
distributing components where the end consumer may not be using the same
frontend stack, or when you want to insulate the end application from
the implementation details of the components it uses.
\switchcolumn
自定义元素的主要好处是，它们可以在使用任何框架，甚至是在不使用框架的场景下使用。当你面向的最终用户可能使用了不同的前端技术栈，或是当你希望将最终的应用与它使用的组件实现细节解耦时，它们会是理想的选择。
\switchcolumn[0]*%%%%%%%
\subsubsection{defineCustomElement}
\switchcolumn
\subsubsection{defineCustomElement}
\switchcolumn[0]*%%%%%%%
Vue supports creating custom elements using exactly the same Vue
component APIs via the
\href{https://vuejs.org/api/general.html\#definecustomelement}{\texttt{defineCustomElement}}
method. The method accepts the same argument as
\href{https://vuejs.org/api/general.html\#definecomponent}{\texttt{defineComponent}},
but instead returns a custom element constructor that extends
\texttt{HTMLElement}:
\switchcolumn
Vue 提供了一个和定义一般 Vue 组件几乎完全一致的
\href{https://cn.vuejs.org/api/general.html\#definecustomelement}{\texttt{defineCustomElement}}
方法来支持创建自定义元素。这个方法接收的参数和
\href{https://cn.vuejs.org/api/general.html\#definecomponent}{\texttt{defineComponent}}
完全相同。但它会返回一个继承自 \texttt{HTMLElement} 的自定义元素构造器：
\switchcolumn[0]*%%%%%%%
\begin{codeHtml}
<my-vue-element></my-vue-element>
\end{codeHtml}
\switchcolumn
\begin{codeHtml}
<my-vue-element></my-vue-element>
\end{codeHtml}
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
import { defineCustomElement } from 'vue'
const MyVueElement = defineCustomElement({
  // 这里是同平常一样的 Vue 组件选项
  props: {},
  emits: {},
  template: `...`,
  // defineCustomElement 特有的：注入进 shadow root 的 CSS
  styles: [`/* inlined css */`]
})
// 注册自定义元素
// 注册之后，所有此页面中的 `<my-vue-element>` 标签
// 都会被升级
customElements.define('my-vue-element', MyVueElement)
// 你也可以编程式地实例化元素：
// （必须在注册之后）
document.body.appendChild(
  new MyVueElement({
    // 初始化 props（可选）
  })
)
\end{codeJs}
\switchcolumn
\begin{codeJs}
import { defineCustomElement } from 'vue'
const MyVueElement = defineCustomElement({
  // 这里是同平常一样的 Vue 组件选项
  props: {},
  emits: {},
  template: `...`,
  // defineCustomElement 特有的：注入进 shadow root 的 CSS
  styles: [`/* inlined css */`]
})
// 注册自定义元素
// 注册之后，所有此页面中的 `<my-vue-element>` 标签
// 都会被升级
customElements.define('my-vue-element', MyVueElement)
// 你也可以编程式地实例化元素：
// （必须在注册之后）
document.body.appendChild(
  new MyVueElement({
    // 初始化 props（可选）
  })
)
\end{codeJs}
\end{paracol}

\columnratio{0.55}
\begin{paracol}{2} 
\switchcolumn[0]*
%%%%%%%
\textbf{Lifecycle}
\switchcolumn
\textbf{生命周期}
\end{paracol}
%%%%%%%%%%%%%%%


\columnratio{0.55}
\begin{paracol}{2}  

\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  A Vue custom element will mount an internal Vue component instance
  inside its shadow root when the element's
  \href{https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements\#using_the_lifecycle_callbacks}{\texttt{connectedCallback}}
  is called for the first time.
\item
  When the element's \texttt{disconnectedCallback} is invoked, Vue will
  check whether the element is detached from the document after a
  microtask tick.
  \begin{itemize}
  \item
    If the element is still in the document, it's a move and the
    component instance will be preserved;
  \item
    If the element is detached from the document, it's a removal and the
    component instance will be unmounted.
  \end{itemize}
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  当该元素的
  \href{https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements\#using_the_lifecycle_callbacks}{\texttt{connectedCallback}}
  初次调用时，一个 Vue 自定义元素会在内部挂载一个 Vue 组件实例到它的
  shadow root 上。
\item
  当此元素的 \texttt{disconnectedCallback} 被调用时，Vue
  会在一个微任务后检查元素是否还留在文档中。
  \begin{itemize}
  \item
    如果元素仍然在文档中，那么说明它是一次移动操作，组件实例将被保留；
  \item
    如果该元素不再存在于文档中，那么说明这是一次移除操作，组件实例将被销毁。
  \end{itemize}
\end{itemize}
\switchcolumn[0]*%%%%%%%
\textbf{Props}
\switchcolumn
\textbf{Props}
\end{paracol}



\columnratio{0.55}
\begin{paracol}{2} 
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  All props declared using the \texttt{props} option will be defined on
  the custom element as properties. Vue will automatically handle the
  reflection between attributes / properties where appropriate.
  \begin{itemize}
  \item
    Attributes are always reflected to corresponding properties.
  \item
    Properties with primitive values (\texttt{string}, \texttt{boolean}
    or \texttt{number}) are reflected as attributes.
  \end{itemize}
\item
  Vue also automatically casts props declared with \texttt{Boolean} or
  \texttt{Number} types into the desired type when they are set as
  attributes (which are always strings). For example, given the
  following props declaration:
~\begin{codeHtml}
props: {
  selected: Boolean,
  index: Number
}
\end{codeHtml}
  And the custom element usage:
~\begin{codeHtml}
<my-element selected index="1"></my-element>
\end{codeHtml}
  In the component, \texttt{selected} will be cast to \texttt{true}
  (boolean) and \texttt{index} will be cast to \texttt{1} (number).
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  所有使用 \texttt{props} 选项声明了的 props
  都会作为属性定义在该自定义元素上。Vue 会自动地、恰当地处理其作为
  attribute 还是属性的反射。
  \begin{itemize}
  \item
    attribute 总是根据需要反射为相应的属性类型。
  \item
    基础类型的属性值 (\texttt{string}，\texttt{boolean} 或
    \texttt{number}) 会被反射为 attribute。
  \end{itemize}
\item
  当它们被设为 attribute 时 (永远是字符串)，Vue 也会自动将以
  \texttt{Boolean} 或 \texttt{Number} 类型声明的 prop
  转换为所期望的类型。比如下面这样的 props 声明：
\begin{codeHtml}
props: {
  selected: Boolean,
  index: Number
}
\end{codeHtml}
  并以下面这样的方式使用自定义元素：
\begin{codeHtml}
<my-element selected index="1"></my-element>
\end{codeHtml}
  在组件中，\texttt{selected} 会被转换为 \texttt{true} (boolean 类型值)
  而 \texttt{index} 会被转换为 \texttt{1} (number 类型值)。
\end{itemize}
\end{paracol}


\columnratio{0.55}
\begin{paracol}{2} 
 
\switchcolumn[0]*%%%%%%%
\textbf{Events}
\switchcolumn
\textbf{事件}
\switchcolumn[0]*%%%%%%%
Events emitted via \texttt{this.\$emit} or setup \texttt{emit} are
dispatched as native
\href{https://developer.mozilla.org/en-US/docs/Web/Events/Creating_and_triggering_events\#adding_custom_data_–_customevent}{CustomEvents}
on the custom element. Additional event arguments (payload) will be
exposed as an array on the CustomEvent object as its \texttt{detail}
property.
\switchcolumn
通过 \texttt{this.\$emit} 或者 setup 中的 \texttt{emit}
触发的事件都会通过以
\href{https://developer.mozilla.org/en-US/docs/Web/Events/Creating_and_triggering_events\#adding_custom_data_–_customevent}{CustomEvents}
的形式从自定义元素上派发。额外的事件参数 (payload) 将会被暴露为
CustomEvent 对象上的一个 \texttt{detail} 数组。
\switchcolumn[0]*%%%%%%%
\textbf{Slots}
\switchcolumn
\textbf{插槽}
\switchcolumn[0]*%%%%%%%
Inside the component, slots can be rendered using the
\texttt{\textless{}slot/\textgreater{}} element as usual. However, when
consuming the resulting element, it only accepts
\href{https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots}{native
slots syntax}:
\switchcolumn
在一个组件中，插槽将会照常使用 \texttt{\textless{}slot/\textgreater{}}
渲染。然而，当使用最终的元素时，它只接受\href{https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots}{原生插槽的语法}：
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  \href{https://vuejs.org/guide/components/slots.html\#scoped-slots}{Scoped
  slots} are not supported.
\item
  When passing named slots, use the \texttt{slot} attribute instead of
  the \texttt{v-slot} directive:
\begin{codeHtml}
<my-element>
  <div slot="named">hello</div>
</my-element>
\end{codeHtml}
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  不支持\href{https://cn.vuejs.org/guide/components/slots.html\#scoped-slots}{作用域插槽}。
\item
  当传递具名插槽时，应使用 \texttt{slot} attribute 而不是
  \texttt{v-slot} 指令：
\begin{codeHtml}
<my-element>
  <div slot="named">hello</div>
</my-element>
\end{codeHtml}
\end{itemize}
\switchcolumn[0]*%%%%%%%
\textbf{Provide / Inject}
\switchcolumn
\textbf{依赖注入}
\switchcolumn[0]*%%%%%%%
The
\href{https://vuejs.org/guide/components/provide-inject.html\#provide-inject}{Provide
/ Inject API} and its
\href{https://vuejs.org/api/composition-api-dependency-injection.html\#provide}{Composition
API equivalent} also work between Vue-defined custom elements. However,
note that this works \textbf{only between custom elements}. i.e. a
Vue-defined custom element won't be able to inject properties provided
by a non-custom-element Vue component.
\switchcolumn
\href{https://cn.vuejs.org/guide/components/provide-inject.html\#provide-inject}{Provide
/ Inject API}
和\href{https://cn.vuejs.org/api/composition-api-dependency-injection.html\#provide}{相应的组合式
API} 在 Vue
定义的自定义元素中都可以正常工作。但是请注意，依赖关系\textbf{只在自定义元素之间}起作用。例如一个
Vue 定义的自定义元素就无法注入一个由常规 Vue 组件所提供的属性。
\switchcolumn[0]*%%%%%%%
\subsubsection{SFC as Custom Element}
\switchcolumn
\subsubsection{将 SFC 编译为自定义元素}
\switchcolumn[0]*%%%%%%%
\texttt{defineCustomElement} also works with Vue Single-File Components
(SFCs). However, with the default tooling setup, the
\texttt{\textless{}style\textgreater{}} inside the SFCs will still be
extracted and merged into a single CSS file during production build.
When using an SFC as a custom element, it is often desirable to inject
the \texttt{\textless{}style\textgreater{}} tags into the custom
element's shadow root instead.
\switchcolumn
\texttt{defineCustomElement} 也可以搭配 Vue 单文件组件 (SFC)
使用。但是，根据默认的工具链配置，SFC 中的
\texttt{\textless{}style\textgreater{}}
在生产环境构建时仍然会被抽取和合并到一个单独的 CSS 文件中。当正在使用
SFC 编写自定义元素时，通常需要改为注入
\texttt{\textless{}style\textgreater{}} 标签到自定义元素的 shadow root
上。
\switchcolumn[0]*%%%%%%%
The official SFC toolings support importing SFCs in "custom element
mode" (requires \texttt{@vitejs/plugin-vue@\^{}1.4.0} or
\texttt{vue-loader@\^{}16.5.0}). An SFC loaded in custom element mode
inlines its \texttt{\textless{}style\textgreater{}} tags as strings of
CSS and exposes them under the component's \texttt{styles} option. This
will be picked up by \texttt{defineCustomElement} and injected into the
element's shadow root when instantiated.
\switchcolumn
官方的 SFC 工具链支持以``自定义元素模式''导入 SFC (需要
\texttt{@vitejs/plugin-vue@\^{}1.4.0} 或
\texttt{vue-loader@\^{}16.5.0})。一个以自定义元素模式加载的 SFC
将会内联其 \texttt{\textless{}style\textgreater{}} 标签为 CSS
字符串，并将其暴露为组件的 \texttt{styles} 选项。这会被
\texttt{defineCustomElement} 提取使用，并在初始化时注入到元素的 shadow
root 上。
\switchcolumn[0]*%%%%%%%
To opt-in to this mode, simply end your component file name with
\texttt{.ce.vue}:
\switchcolumn
要开启这个模式，只需要将你的组件文件以 \texttt{.ce.vue} 结尾即可：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
import { defineCustomElement } from 'vue'
import Example from './Example.ce.vue'
console.log(Example.styles) // ["/* 内联 css */"]
// 转换为自定义元素构造器
const ExampleElement = defineCustomElement(Example)
// 注册
customElements.define('my-example', ExampleElement)
\end{codeJs}
\switchcolumn
\begin{codeJs}
import { defineCustomElement } from 'vue'
import Example from './Example.ce.vue'
console.log(Example.styles) // ["/* 内联 css */"]
// 转换为自定义元素构造器
const ExampleElement = defineCustomElement(Example)
// 注册
customElements.define('my-example', ExampleElement)
\end{codeJs}
\switchcolumn[0]*%%%%%%%
If you wish to customize what files should be imported in custom element
mode (for example, treating \emph{all} SFCs as custom elements), you can
pass the \texttt{customElement} option to the respective build plugins:
\switchcolumn
如果你想要自定义如何判断是否将文件作为自定义元素导入 (例如将所有的 SFC
都视为用作自定义元素)，你可以通过给构建插件传递相应插件的
\texttt{customElement} 选项来实现：
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  \href{https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue\#using-vue-sfcs-as-custom-elements}{@vitejs/plugin-vue}
\item
  \href{https://github.com/vuejs/vue-loader/tree/next\#v16-only-options}{vue-loader}
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  \href{https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue\#using-vue-sfcs-as-custom-elements}{@vitejs/plugin-vue}
\item
  \href{https://github.com/vuejs/vue-loader/tree/next\#v16-only-options}{vue-loader}
\end{itemize}
\switchcolumn[0]*%%%%%%%
\subsubsection{Tips for a Vue Custom Elements Library}
\switchcolumn
\subsubsection{基于 Vue 构建自定义元素库}
\switchcolumn[0]*%%%%%%%
When building custom elements with Vue, the elements will rely on Vue's
runtime. There is a \textasciitilde16kb baseline size cost depending on
how many features are being used. This means it is not ideal to use Vue
if you are shipping a single custom element - you may want to use
vanilla JavaScript,
\href{https://github.com/vuejs/petite-vue}{petite-vue}, or frameworks
that specialize in small runtime size. However, the base size is more
than justifiable if you are shipping a collection of custom elements
with complex logic, as Vue will allow each component to be authored with
much less code. The more elements you are shipping together, the better
the trade-off.
\switchcolumn
当使用 Vue 构建自定义元素时，该元素将依赖于 Vue 的运行时。这会有大约
16kb
的基本打包大小，并视功能的使用情况而增长。这意味着如果只编写一个自定义元素，那么使用
Vue 并不是理想的选择。你可能想要使用原生
JavaScript、\href{https://github.com/vuejs/petite-vue}{petite-vue}，或其他框架以追求更小的运行时体积。但是，如果你需要编写的是一组具有复杂逻辑的自定义元素，那么这个基本体积是非常合理的，因为
Vue 允许用更少的代码编写每个组件。在一起发布的元素越多，收益就会越高。
\switchcolumn[0]*%%%%%%%
If the custom elements will be used in an application that is also using
Vue, you can choose to externalize Vue from the built bundle so that the
elements will be using the same copy of Vue from the host application.
\switchcolumn
如果自定义元素将在同样使用 Vue 的应用中使用，那么你可以选择将构建包中的
Vue 外部化 (externalize)，这样这些自定义元素将与宿主应用使用同一份 Vue。
\switchcolumn[0]*%%%%%%%
It is recommended to export the individual element constructors to give
your users the flexibility to import them on-demand and register them
with desired tag names. You can also export a convenience function to
automatically register all elements. Here's an example entry point of a
Vue custom element library:
\switchcolumn
建议按元素分别导出构造函数，以便用户可以灵活地按需导入它们，并使用期望的标签名称注册它们。你还可以导出一个函数来方便用户自动注册所有元素。下面是一个
Vue 自定义元素库的入口文件示例：
\switchcolumn[0]*%%%%%%%
\begin{codeJs}
import { defineCustomElement } from 'vue'
import Foo from './MyFoo.ce.vue'
import Bar from './MyBar.ce.vue'
const MyFoo = defineCustomElement(Foo)
const MyBar = defineCustomElement(Bar)
// 分别导出元素
export { MyFoo, MyBar }
export function register() {
  customElements.define('my-foo', MyFoo)
  customElements.define('my-bar', MyBar)
}
\end{codeJs}
\switchcolumn
\begin{codeJs}
import { defineCustomElement } from 'vue'
import Foo from './MyFoo.ce.vue'
import Bar from './MyBar.ce.vue'
const MyFoo = defineCustomElement(Foo)
const MyBar = defineCustomElement(Bar)
// 分别导出元素
export { MyFoo, MyBar }
export function register() {
  customElements.define('my-foo', MyFoo)
  customElements.define('my-bar', MyBar)
}
\end{codeJs}
\switchcolumn[0]*%%%%%%%
If you have many components, you can also leverage build tool features
such as Vite's
\href{https://vitejs.dev/guide/features.html\#glob-import}{glob import}
or webpack's
\href{https://webpack.js.org/guides/dependency-management/\#requirecontext}{\texttt{require.context}}
to load all components from a directory.
\switchcolumn
如果你有非常多的组件，你也可以利用构建工具的功能，比如 Vite 的
\href{https://cn.vitejs.dev/guide/features.html\#glob-import}{glob
导入}或者 webpack 的
\href{https://webpack.js.org/guides/dependency-management/\#requirecontext}{\texttt{require.context}}
来从一个文件夹加载所有的组件。
\switchcolumn[0]*%%%%%%%
\subsubsection{Web Components and Typescript}
\switchcolumn
\subsubsection{Web Components 和 Typescript}
\end{paracol}



\columnratio{0.55}
\begin{paracol}{2} 
 
\switchcolumn[0]*%%%%%%%
If you are developing an application or a library, you may want to
\href{https://vuejs.org/guide/scaling-up/tooling.html\#typescript}{type
check} your Vue components, including those that are defined as custom
elements.
\switchcolumn
如果你正在开发一个应用或者库，你可能想要为你的 Vue
组件添加\href{https://cn.vuejs.org/guide/scaling-up/tooling.html\#typescript}{类型检查}，包括那些被定义为自定义元素的组件。
\switchcolumn[0]*%%%%%%%
Custom elements are registered globally using native APIs, so by default
they won't have type inference when used in Vue templates. To provide
type support for Vue components registered as custom elements, we can
register global component typings using the the
\href{https://github.com/vuejs/language-tools/blob/master/packages/vscode-vue/README.md\#usage}{\texttt{GlobalComponents}
interface} in Vue templates and/or in
\href{https://www.typescriptlang.org/docs/handbook/jsx.html\#intrinsic-elements}{JSX}:
\switchcolumn
自定义元素是使用原生 API 全局注册的，所以默认情况下，当在 Vue
模板中使用时，它们不会有类型推断。为了给注册为自定义元素的 Vue
组件提供类型支持，我们可以通过 Vue 模板和/或
\href{https://www.typescriptlang.org/docs/handbook/jsx.html\#intrinsic-elements}{JSX}
中的
\href{https://github.com/vuejs/language-tools/blob/master/packages/vscode-vue/README.md\#usage}{\texttt{GlobalComponents}
接口} 来注册全局组件的类型：
\switchcolumn[0]*%%%%%%%
%typescript
\begin{codeHtml}
import { defineCustomElement } from 'vue'
// vue 单文件组件
import CounterSFC from './src/components/counter.ce.vue'
// 将组件转换为 web components
export const Counter = defineCustomElement(CounterSFC)
// 注册全局类型
declare module 'vue' {
  export interface GlobalComponents {
    'Counter': typeof Counter,
  }
}
\end{codeHtml}
\switchcolumn
%typescript
\begin{codeHtml}
import { defineCustomElement } from 'vue'
// vue 单文件组件
import CounterSFC from './src/components/counter.ce.vue'
// 将组件转换为 web components
export const Counter = defineCustomElement(CounterSFC)
// 注册全局类型
declare module 'vue' {
  export interface GlobalComponents {
    'Counter': typeof Counter,
  }
}
\end{codeHtml}
\end{paracol}



\columnratio{0.55}
\begin{paracol}{2} 
 
\switchcolumn[0]*%%%%%%%
\subsection{Web Components vs. Vue Components}
\switchcolumn
\subsection{Web Components vs. Vue Components}
\switchcolumn[0]*%%%%%%%
Some developers believe that framework-proprietary component models
should be avoided, and that exclusively using Custom Elements makes an
application "future-proof". Here we will try to explain why we believe
that this is an overly simplistic take on the problem.
\switchcolumn
一些开发者认为应该避免使用框架专有的组件模型，而改为全部使用自定义元素来构建应用，因为这样可以使应用``永不过时''。在这里，我们将解释为什么我们认为这样的想法过于简单。
\switchcolumn[0]*%%%%%%%
There is indeed a certain level of feature overlap between Custom
Elements and Vue Components: they both allow us to define reusable
components with data passing, event emitting, and lifecycle management.
However, Web Components APIs are relatively low-level and bare-bones. To
build an actual application, we need quite a few additional capabilities
which the platform does not cover:
\switchcolumn
自定义元素和 Vue
组件之间确实存在一定程度的功能重叠：它们都允许我们定义具有数据传递、事件发射和生命周期管理的可重用组件。然而，Web
Components 的 API
相对来说是更底层的和更基础的。要构建一个实际的应用，我们需要相当多平台没有涵盖的附加功能：
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  A declarative and efficient templating system;
\item
  A reactive state management system that facilitates cross-component
  logic extraction and reuse;
\item
  A performant way to render the components on the server and hydrate
  them on the client (SSR), which is important for SEO and
  \href{https://web.dev/vitals/}{Web Vitals metrics such as LCP}. Native
  custom elements SSR typically involves simulating the DOM in Node.js
  and then serializing the mutated DOM, while Vue SSR compiles into
  string concatenation whenever possible, which is much more efficient.
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  一个声明式的、高效的模板系统；
\item
  一个响应式的，利于跨组件逻辑提取和重用的状态管理系统；
\item
  一种在服务器上呈现组件并在客户端``激活''(hydrate) 组件的高性能方法
  (SSR)，这对 SEO 和 \href{https://web.dev/vitals/}{LCP 这样的 Web
  关键指标}非常重要。原生自定义元素 SSR 通常需要在 Node.js 中模拟
  DOM，然后序列化更改后的 DOM，而 Vue SSR
  则尽可能地将其编译为拼接起来的字符串，这会高效得多。
\end{itemize}
\switchcolumn[0]*%%%%%%%
Vue's component model is designed with these needs in mind as a coherent
system.
\switchcolumn
Vue 的组件模型在设计时同时兼顾了这些需求，因此是一个更内聚的系统。
\switchcolumn[0]*%%%%%%%
With a competent engineering team, you could probably build the
equivalent on top of native Custom Elements - but this also means you
are taking on the long-term maintenance burden of an in-house framework,
while losing out on the ecosystem and community benefits of a mature
framework like Vue.
\switchcolumn
当你的团队有足够的技术水平时，可能可以在原生自定义元素的基础上构建具备同等功能的组件。但这也意味着你将承担长期维护内部框架的负担，同时失去了像
Vue 这样成熟的框架生态社区所带来的收益。
\switchcolumn[0]*%%%%%%%
There are also frameworks built using Custom Elements as the basis of
their component model, but they all inevitably have to introduce their
proprietary solutions to the problems listed above. Using these
frameworks entails buying into their technical decisions on how to solve
these problems - which, despite what may be advertised, doesn't
automatically insulate you from potential future churns.
\switchcolumn
也有一些框架使用自定义元素作为其组件模型的基础，但它们都不可避免地要引入自己的专有解决方案来解决上面列出的问题。使用这些框架便意味着对它们针对这些问题的技术决策买单。不管这类框架怎么宣传它们``永不过时''，它们其实都无法保证你以后永远不需要重构。
\switchcolumn[0]*%%%%%%%
There are also some areas where we find custom elements to be limiting:
\switchcolumn
除此之外，我们还发现自定义元素存在以下限制：
\switchcolumn[0]*%%%%%%%
\begin{itemize}
\item
  Eager slot evaluation hinders component composition. Vue's
  \href{https://vuejs.org/guide/components/slots.html\#scoped-slots}{scoped
  slots} are a powerful mechanism for component composition, which can't
  be supported by custom elements due to native slots' eager nature.
  Eager slots also mean the receiving component cannot control when or
  whether to render a piece of slot content.
\item
  Shipping custom elements with shadow DOM scoped CSS today requires
  embedding the CSS inside JavaScript so that they can be injected into
  shadow roots at runtime. They also result in duplicated styles in
  markup in SSR scenarios. There are
  \href{https://github.com/whatwg/html/pull/4898/}{platform features}
  being worked on in this area - but as of now they are not yet
  universally supported, and there are still production performance /
  SSR concerns to be addressed. In the meanwhile, Vue SFCs provide
  \href{https://vuejs.org/api/sfc-css-features.html}{CSS scoping
  mechanisms} that support extracting the styles into plain CSS files.
\end{itemize}
\switchcolumn
\begin{itemize}
\item
  贪婪 (eager) 的插槽求值会阻碍组件之间的可组合性。Vue
  的\href{https://cn.vuejs.org/guide/components/slots.html\#scoped-slots}{作用域插槽}是一套强大的组件组合机制，而由于原生插槽的贪婪求值性质，自定义元素无法支持这样的设计。贪婪求值的插槽也意味着接收组件时不能控制何时或是否创建插槽内容的节点。
\item
  在当下要想使用 shadow DOM 书写局部作用域的 CSS，必须将样式嵌入到
  JavaScript 中才可以在运行时将其注入到 shadow root 上。这也导致了 SSR
  场景下需要渲染大量重复的样式标签。虽然有一些\href{https://github.com/whatwg/html/pull/4898/}{平台功能}在尝试解决这一领域的问题，但是直到现在还没有达到通用支持的状态，而且仍有生产性能
  / SSR 方面的问题需要解决。可与此同时，Vue 的 SFC 本身就提供了
  \href{https://cn.vuejs.org/api/sfc-css-features.html}{CSS
  局域化机制}，并支持抽取样式到纯 CSS 文件中。
\end{itemize}
\switchcolumn[0]*%%%%%%%
Vue will always stay up to date with the latest standards in the web
platform, and we will happily leverage whatever the platform provides if
it makes our job easier. However, our goal is to provide solutions that
work well and work today. That means we have to incorporate new platform
features with a critical mindset - and that involves filling the gaps
where the standards fall short while that is still the case.
\switchcolumn
Vue 将始终紧跟 Web
平台的最新标准，如果平台的新功能能让我们的工作变得更简单，我们将非常乐于利用它们。但是，我们的目标是提供``好用，且现在就能用''的解决方案。这意味着我们在采用新的原生功能时需要保持客观、批判性的态度，并在原生功能完成度不足的时候选择更适当的解决方案。
\end{paracol}

